---
title: Lean 递归函数
description: "了解如何在 Lean 中编写和使用递归函数，掌握递归的基本概念及其在函数式编程中的应用。"
---

# Lean 递归函数

在函数式编程中，**递归**是一种非常重要的技术。它允许函数通过调用自身来解决问题。Lean 作为一种函数式编程语言，天然支持递归。本文将带你了解 Lean 中的递归函数，并通过示例帮助你掌握这一概念。

## 什么是递归？

递归是指一个函数在其定义中调用自身的过程。递归通常用于解决可以分解为相同问题的子问题的情况。例如，计算阶乘、遍历列表或树结构等任务都可以通过递归来实现。

在 Lean 中，递归函数的定义与其他函数类似，但需要在函数体中调用自身。

## 递归函数的基本结构

一个典型的递归函数包含两个部分：
1. **基准条件（Base Case）**：这是递归的终止条件。当满足基准条件时，递归停止。
2. **递归条件（Recursive Case）**：这是函数调用自身的部分，通常会将问题分解为更小的子问题。

### 示例：计算阶乘

阶乘是一个经典的递归问题。`n!` 表示从 1 到 `n` 的所有整数的乘积。例如，`5! = 5 * 4 * 3 * 2 * 1 = 120`。

下面是一个计算阶乘的 Lean 递归函数：

```lean
def factorial : Nat → Nat
  | 0 => 1
  | n + 1 => (n + 1) * factorial n
```

在这个例子中：
- 基准条件是 `0 => 1`，即 `0! = 1`。
- 递归条件是 `n + 1 => (n + 1) * factorial n`，即 `(n+1)! = (n+1) * n!`。

### 输入和输出示例

```lean
#eval factorial 5  -- 输出: 120
#eval factorial 3  -- 输出: 6
```

## 递归的注意事项

在使用递归时，需要注意以下几点：
1. **基准条件**：必须确保递归函数有一个明确的基准条件，否则函数将无限递归，导致栈溢出。
2. **递归深度**：递归调用会占用栈空间，如果递归深度过大，可能会导致栈溢出。Lean 的编译器会优化尾递归，但在编写递归函数时仍需注意。

:::tip
Lean 支持**尾递归优化**，这意味着在某些情况下，递归调用不会增加栈空间。如果你的递归函数是尾递归的，Lean 会将其优化为循环，从而避免栈溢出。
:::

## 实际案例：斐波那契数列

斐波那契数列是另一个经典的递归问题。斐波那契数列的定义如下：
- `fib(0) = 0`
- `fib(1) = 1`
- `fib(n) = fib(n-1) + fib(n-2)` 对于 `n > 1`

下面是一个计算斐波那契数列的 Lean 递归函数：

```lean
def fib : Nat → Nat
  | 0 => 0
  | 1 => 1
  | n + 2 => fib (n + 1) + fib n
```

### 输入和输出示例

```lean
#eval fib 10  -- 输出: 55
#eval fib 20  -- 输出: 6765
```

:::caution
虽然递归是解决斐波那契数列的自然方式，但这种实现方式效率较低，因为它会重复计算相同的子问题。在实际应用中，可以使用**动态规划**或**记忆化**来优化递归函数。
:::

## 递归与列表处理

递归在处理列表时也非常有用。例如，我们可以使用递归来计算列表的长度：

```lean
def length {α : Type} : List α → Nat
  | [] => 0
  | _ :: xs => 1 + length xs
```

### 输入和输出示例

```lean
#eval length [1, 2, 3, 4]  -- 输出: 4
#eval length ["a", "b", "c"]  -- 输出: 3
```

## 总结

递归是函数式编程中的核心概念之一。通过递归，我们可以简洁地表达许多复杂的算法和数据结构操作。在 Lean 中，递归函数的定义直观且易于理解，但需要注意基准条件和递归深度，以避免无限递归和栈溢出。

## 附加资源与练习

1. **练习**：尝试编写一个递归函数来计算列表的和。
2. **挑战**：使用递归实现一个函数，判断一个字符串是否是回文。
3. **深入学习**：了解 Lean 中的尾递归优化，并尝试编写一个尾递归版本的斐波那契函数。

通过不断练习和实践，你将能够熟练掌握 Lean 中的递归函数，并在函数式编程中灵活运用这一强大的工具。