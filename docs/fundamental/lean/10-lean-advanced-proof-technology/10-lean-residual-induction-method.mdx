---
title: Lean 余归纳法
description: 了解Lean中的余归纳法，掌握如何利用余归纳法处理无限数据结构及其证明。
---

# Lean 余归纳法

在Lean中，**余归纳法**（Coinduction）是一种用于处理**无限数据结构**的证明技术。与归纳法（Induction）不同，归纳法通常用于处理有限的结构，而余归纳法则适用于那些可能无限延伸的结构，例如**流**（Streams）或**无限列表**。

## 什么是余归纳法？

余归纳法的核心思想是：**通过观察结构的有限部分来推断其无限行为**。它通常用于定义和证明那些无法通过有限步骤完全展开的结构。例如，一个无限流 `s` 可以被定义为一个头元素 `head s` 和一个尾流 `tail s`，而尾流本身又是一个无限流。

### 余归纳法的基本概念

1. **余数据类型**（Codata）：余数据类型是那些可能无限展开的数据类型。例如，`Stream α` 是一个余数据类型，表示一个无限的元素序列。
2. **余递归定义**（Corecursive Definition）：余递归定义允许我们定义一个无限结构，而不需要显式地写出所有元素。例如，定义一个无限流 `ones`，其中所有元素都是 `1`：
   ```lean
   def ones : Stream Nat :=
     Stream.corec (fun _ => 1) ()
   ```
   这里，`Stream.corec` 是一个余递归构造器，它通过一个生成函数和一个初始状态来定义一个无限流。

3. **余归纳原理**（Coinductive Principle）：余归纳原理允许我们通过观察有限部分来证明无限结构的性质。例如，证明两个无限流相等，只需要证明它们的每个对应元素相等。

## 余归纳法的实际应用

### 案例1：定义无限流

让我们定义一个无限流 `nats`，表示自然数序列 `0, 1, 2, 3, ...`：

```lean
def nats : Stream Nat :=
  Stream.corec (fun n => (n, n + 1)) 0
```

在这个定义中，`Stream.corec` 接受一个生成函数 `fun n => (n, n + 1)` 和一个初始状态 `0`。生成函数返回当前元素 `n` 和下一个状态 `n + 1`，从而生成无限的自然数序列。

### 案例2：证明流的相等性

假设我们有两个无限流 `s1` 和 `s2`，我们想证明它们相等。根据余归纳原理，我们只需要证明它们的每个对应元素相等。

```lean
theorem stream_eq (s1 s2 : Stream Nat) :
  (∀ n, Stream.get s1 n = Stream.get s2 n) → s1 = s2 :=
by
  intro h
  apply Stream.ext
  intro n
  exact h n
```

在这个证明中，`Stream.ext` 是Lean中的一个定理，它表明两个流相等当且仅当它们的每个对应元素相等。

### 案例3：余归纳法的实际应用

考虑一个无限流 `fib`，表示斐波那契数列。我们可以通过余递归定义来构造这个流：

```lean
def fib : Stream Nat :=
  Stream.corec (fun (a, b) => (a, (b, a + b))) (0, 1)
```

在这个定义中，`Stream.corec` 接受一个生成函数 `fun (a, b) => (a, (b, a + b))` 和一个初始状态 `(0, 1)`。生成函数返回当前元素 `a` 和下一个状态 `(b, a + b)`，从而生成无限的斐波那契数列。

## 总结

余归纳法是Lean中处理无限数据结构的重要工具。通过余递归定义和余归纳原理，我们可以轻松地定义和证明无限流的性质。余归纳法的核心思想是通过观察有限部分来推断无限行为，这使得它在处理无限结构时非常强大。

### 附加资源与练习

1. **练习1**：定义一个无限流 `twos`，其中所有元素都是 `2`，并证明它与 `ones` 的每个元素相加等于 `threes`。
2. **练习2**：定义一个无限流 `evens`，表示所有偶数，并证明它的每个元素都是偶数。
3. **附加资源**：阅读Lean官方文档中关于余数据类型和余归纳法的部分，深入了解其理论基础和应用场景。

:::tip
余归纳法在处理无限结构时非常有用，但在实际应用中需要注意避免无限循环。确保你的余递归定义是良定义的，并且能够生成有意义的结果。
:::