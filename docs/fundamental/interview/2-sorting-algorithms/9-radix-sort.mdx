---
title: 基数排序
description: 了解基数排序的工作原理、实现方式及其实际应用场景。适合编程初学者学习。
---

# 基数排序

基数排序（Radix Sort）是一种非比较型整数排序算法，它通过将整数按位数切割成不同的数字，然后按每个位数分别进行比较和排序。基数排序的核心思想是“分配”和“收集”，它适用于整数或字符串的排序。

## 基数排序的基本概念

基数排序的基本思想是将整数按位数切割成不同的数字，然后按每个位数分别进行排序。具体来说，基数排序从最低位（个位）开始，依次对每一位进行排序，直到最高位。每次排序时，使用稳定的排序算法（如计数排序）来确保相同位数的数字保持原有的顺序。

### 基数排序的步骤

1. **确定最大数的位数**：首先，找到数组中最大数的位数，确定需要排序的轮数。
2. **按位排序**：从最低位开始，依次对每一位进行排序。每次排序使用稳定的排序算法（如计数排序）。
3. **收集结果**：将每一轮排序后的结果收集起来，作为下一轮排序的输入。
4. **重复步骤2和3**：直到所有位数都排序完毕。

### 基数排序的代码示例

以下是一个使用基数排序对整数数组进行排序的Python代码示例：

```python
def counting_sort(arr, exp):
    n = len(arr)
    output = [0] * n
    count = [0] * 10

    # 统计每个数字出现的次数
    for i in range(n):
        index = arr[i] // exp
        count[index % 10] += 1

    # 计算每个数字的累积次数
    for i in range(1, 10):
        count[i] += count[i - 1]

    # 根据统计结果将数字放入输出数组
    i = n - 1
    while i >= 0:
        index = arr[i] // exp
        output[count[index % 10] - 1] = arr[i]
        count[index % 10] -= 1
        i -= 1

    # 将排序结果复制回原数组
    for i in range(n):
        arr[i] = output[i]

def radix_sort(arr):
    # 找到数组中的最大值
    max_num = max(arr)

    # 从最低位开始，依次对每一位进行排序
    exp = 1
    while max_num // exp > 0:
        counting_sort(arr, exp)
        exp *= 10

# 示例输入
arr = [170, 45, 75, 90, 802, 24, 2, 66]
radix_sort(arr)
print("排序后的数组:", arr)
```

**输出：**
```
排序后的数组: [2, 24, 45, 66, 75, 90, 170, 802]
```

### 基数排序的复杂度分析

- **时间复杂度**：基数排序的时间复杂度为 `O(d * (n + k))`，其中 `d` 是最大数的位数，`n` 是数组的长度，`k` 是基数（通常为10）。
- **空间复杂度**：基数排序的空间复杂度为 `O(n + k)`，其中 `n` 是数组的长度，`k` 是基数。

## 基数排序的实际应用

基数排序在实际应用中主要用于对整数或字符串进行排序。以下是一些常见的应用场景：

1. **电话号码排序**：基数排序可以用于对电话号码进行排序，因为电话号码通常由固定长度的数字组成。
2. **身份证号排序**：基数排序可以用于对身份证号进行排序，因为身份证号也是由固定长度的数字组成。
3. **大规模数据处理**：基数排序在处理大规模数据时表现良好，尤其是在数据分布较为均匀的情况下。

## 总结

基数排序是一种高效的排序算法，特别适用于对整数或字符串进行排序。它通过按位排序的方式，避免了比较操作，从而在某些情况下比传统的比较排序算法（如快速排序、归并排序）更加高效。然而，基数排序的空间复杂度较高，因此在内存有限的情况下需要谨慎使用。

## 附加资源与练习

- **练习**：尝试实现一个基数排序算法，对一组字符串进行排序。
- **进一步学习**：了解其他非比较型排序算法，如桶排序和计数排序。

:::tip
基数排序在处理大规模数据时表现优异，但在实际应用中需要注意数据的分布情况，以确保算法的效率。
:::