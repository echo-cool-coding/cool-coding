---
title: 二分图的判定
description: 了解什么是二分图，学习如何通过算法判定一个图是否为二分图，并掌握其实际应用场景。
---

## 介绍

二分图（Bipartite Graph）是一种特殊的图，其顶点集可以被划分为两个互不相交的子集，使得每条边的两个端点分别属于这两个子集。换句话说，二分图中不存在奇数长度的环。

判定一个图是否为二分图是图论中的一个基本问题，它在许多实际应用中都有重要作用，例如任务分配、社交网络分析等。

## 二分图的定义

一个图 \( G = (V, E) \) 是二分图，当且仅当它的顶点集 \( V \) 可以被划分为两个不相交的子集 \( U \) 和 \( V \)，使得每一条边 \( (u, v) \in E \) 都满足 \( u \in U \) 且 \( v \in V \)。

## 二分图的判定方法

判定一个图是否为二分图的常用方法是使用**深度优先搜索（DFS）**或**广度优先搜索（BFS）**。我们可以通过给图中的顶点着色来判定图是否为二分图。具体步骤如下：

1. 选择一个起始顶点，将其着色为颜色1。
2. 遍历该顶点的所有邻接顶点，将它们着色为颜色2。
3. 继续遍历邻接顶点的邻接顶点，将它们着色为颜色1，依此类推。
4. 如果在遍历过程中发现某个顶点的邻接顶点已经被着色，并且颜色与当前顶点相同，则该图不是二分图。

### 代码示例

以下是一个使用 BFS 判定二分图的 Python 代码示例：

```python
from collections import deque

def is_bipartite(graph):
    n = len(graph)
    color = [-1] * n  # -1 表示未着色，0 和 1 表示两种颜色

    for i in range(n):
        if color[i] == -1:
            color[i] = 0
            queue = deque([i])

            while queue:
                node = queue.popleft()
                for neighbor in graph[node]:
                    if color[neighbor] == -1:
                        color[neighbor] = 1 - color[node]
                        queue.append(neighbor)
                    elif color[neighbor] == color[node]:
                        return False
    return True

# 示例输入
graph = [
    [1, 3],
    [0, 2],
    [1, 3],
    [0, 2]
]

# 输出结果
print(is_bipartite(graph))  # 输出: True
```

### 输入和输出解释

- **输入**：`graph` 是一个邻接表表示的图，其中 `graph[i]` 表示顶点 `i` 的邻接顶点列表。
- **输出**：如果图是二分图，返回 `True`；否则返回 `False`。

## 实际应用场景

二分图的判定在许多实际场景中都有应用，例如：

1. **任务分配**：在任务分配问题中，可以将任务和工人分别表示为二分图的两个子集，通过二分图的判定来确保每个任务只能分配给一个工人。
2. **社交网络分析**：在社交网络中，可以将用户和兴趣分别表示为二分图的两个子集，通过二分图的判定来分析用户与兴趣之间的关系。
3. **匹配问题**：在匹配问题中，二分图的判定可以帮助我们找到最大匹配或完美匹配。

## 总结

二分图是一种特殊的图结构，其顶点集可以被划分为两个互不相交的子集。通过使用 BFS 或 DFS 算法，我们可以有效地判定一个图是否为二分图。二分图在许多实际应用中都有重要作用，例如任务分配、社交网络分析等。

## 附加资源与练习

- **练习**：尝试编写一个使用 DFS 判定二分图的代码，并与 BFS 方法进行比较。
- **资源**：推荐阅读《算法导论》中的图论章节，深入了解二分图及其相关算法。

:::tip
在实际应用中，二分图的判定算法可以帮助我们解决许多复杂的问题。掌握这一算法不仅有助于理解图论的基本概念，还能为后续学习更高级的算法打下坚实的基础。
:::