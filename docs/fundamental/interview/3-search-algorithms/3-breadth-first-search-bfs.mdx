---
title: 广度优先搜索(BFS)
description: 了解广度优先搜索(BFS)的基本概念、实现方法及其实际应用场景。适合编程初学者学习。
---

# 广度优先搜索(BFS)

广度优先搜索（Breadth-First Search，简称 BFS）是一种用于遍历或搜索树或图的算法。它从根节点（或任意节点）开始，逐层访问所有相邻节点，直到找到目标节点或遍历完整个结构。BFS 的核心思想是“先广后深”，即优先访问离起点最近的节点。

## BFS 的基本概念

BFS 通常使用队列（Queue）来实现。队列是一种先进先出（FIFO）的数据结构，非常适合 BFS 的逐层访问特性。以下是 BFS 的基本步骤：

1. 将起始节点放入队列中。
2. 从队列中取出一个节点，访问它。
3. 将该节点的所有未访问过的相邻节点放入队列中。
4. 重复步骤 2 和 3，直到队列为空。

:::note
BFS 保证在无权图中找到的路径是最短路径，因为它总是优先访问离起点最近的节点。
:::

## BFS 的代码实现

以下是一个使用 Python 实现的 BFS 示例。我们将遍历一个图，并打印出访问顺序。

```python
from collections import deque

def bfs(graph, start):
    visited = set()  # 用于记录已访问的节点
    queue = deque([start])  # 使用队列存储待访问的节点

    while queue:
        node = queue.popleft()  # 从队列中取出一个节点
        if node not in visited:
            print(node)  # 访问节点
            visited.add(node)  # 标记为已访问
            # 将该节点的所有未访问过的相邻节点加入队列
            for neighbor in graph[node]:
                if neighbor not in visited:
                    queue.append(neighbor)

# 示例图
graph = {
    'A': ['B', 'C'],
    'B': ['A', 'D', 'E'],
    'C': ['A', 'F'],
    'D': ['B'],
    'E': ['B', 'F'],
    'F': ['C', 'E']
}

# 从节点 'A' 开始进行 BFS
bfs(graph, 'A')
```

**输入：**
```python
graph = {
    'A': ['B', 'C'],
    'B': ['A', 'D', 'E'],
    'C': ['A', 'F'],
    'D': ['B'],
    'E': ['B', 'F'],
    'F': ['C', 'E']
}
```

**输出：**
```
A
B
C
D
E
F
```

## BFS 的实际应用场景

BFS 在许多实际场景中都有广泛应用，以下是一些常见的例子：

1. **最短路径问题**：在无权图中，BFS 可以找到从起点到目标节点的最短路径。
2. **社交网络中的“六度分隔”理论**：BFS 可以用于查找两个人之间的最短关系链。
3. **迷宫求解**：BFS 可以用于在迷宫中找到从起点到终点的最短路径。
4. **网络爬虫**：BFS 可以用于按层级抓取网页，确保先抓取离起始页面最近的页面。

:::tip
在实际应用中，BFS 通常需要结合其他数据结构（如哈希表）来记录节点的状态，以避免重复访问。
:::

## BFS 的复杂度分析

- **时间复杂度**：在最坏情况下，BFS 需要访问图中的所有节点和边。对于有 V 个节点和 E 条边的图，时间复杂度为 O(V + E)。
- **空间复杂度**：BFS 需要使用队列来存储待访问的节点。在最坏情况下，队列中可能存储所有节点，因此空间复杂度为 O(V)。

## 总结

广度优先搜索（BFS）是一种简单但强大的算法，适用于许多与图相关的问题。它的核心思想是逐层访问节点，确保优先访问离起点最近的节点。BFS 不仅可以用于遍历图，还可以解决最短路径问题、迷宫求解等实际问题。

:::caution
BFS 适用于无权图或边权相同的图。如果图中边的权重不同，则需要使用其他算法（如 Dijkstra 算法）来找到最短路径。
:::

## 附加资源与练习

1. **练习**：尝试修改上述代码，使其能够找到从起点到目标节点的最短路径。
2. **扩展阅读**：学习深度优先搜索（DFS），并与 BFS 进行比较，理解它们的区别与适用场景。
3. **挑战**：使用 BFS 解决一个实际的迷宫问题，并输出最短路径。

通过不断练习和应用，你将能够更好地掌握 BFS 算法，并将其应用于更复杂的问题中。