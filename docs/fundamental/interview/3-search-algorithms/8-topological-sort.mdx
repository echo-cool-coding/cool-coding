---
title: 拓扑排序
description: 了解拓扑排序的基本概念、实现方法及其在实际中的应用场景。适合编程初学者学习。
---

# 拓扑排序

拓扑排序（Topological Sorting）是一种用于有向无环图（DAG, Directed Acyclic Graph）的线性排序算法。它可以将图中的所有节点排成一个线性序列，使得对于图中的每一条有向边 (u, v)，节点 u 在序列中都位于节点 v 的前面。拓扑排序常用于解决依赖关系问题，例如任务调度、课程安排等。

## 什么是拓扑排序？

在有向图中，如果存在一条从节点 A 到节点 B 的路径，那么在拓扑排序中，节点 A 必须排在节点 B 的前面。拓扑排序的结果不一定是唯一的，因为可能存在多个节点没有依赖关系，它们的顺序可以任意排列。

:::note
拓扑排序只适用于有向无环图（DAG）。如果图中存在环，则无法进行拓扑排序。
:::

## 拓扑排序的实现

拓扑排序可以通过深度优先搜索（DFS）或广度优先搜索（BFS）来实现。下面我们将分别介绍这两种方法。

### 1. 深度优先搜索（DFS）实现

DFS 的实现思路是：从任意一个未访问的节点开始，递归地访问其所有邻接节点，直到没有未访问的节点为止。然后将当前节点加入结果列表的头部。

```python
from collections import defaultdict

def topological_sort_dfs(graph):
    visited = set()
    result = []

    def dfs(node):
        if node not in visited:
            visited.add(node)
            for neighbor in graph[node]:
                dfs(neighbor)
            result.append(node)

    for node in graph:
        dfs(node)

    return result[::-1]  # 反转结果列表

# 示例图
graph = {
    'A': ['C'],
    'B': ['C', 'D'],
    'C': ['E'],
    'D': ['F'],
    'E': ['F'],
    'F': []
}

print(topological_sort_dfs(graph))
```

**输入：**
```python
graph = {
    'A': ['C'],
    'B': ['C', 'D'],
    'C': ['E'],
    'D': ['F'],
    'E': ['F'],
    'F': []
}
```

**输出：**
```python
['B', 'D', 'A', 'C', 'E', 'F']
```

### 2. 广度优先搜索（BFS）实现

BFS 的实现思路是：首先计算每个节点的入度（即有多少条边指向该节点），然后将所有入度为 0 的节点加入队列。接着，依次从队列中取出节点，将其加入结果列表，并将其邻接节点的入度减 1。如果某个邻接节点的入度变为 0，则将其加入队列。

```python
from collections import defaultdict, deque

def topological_sort_bfs(graph):
    in_degree = {node: 0 for node in graph}
    for node in graph:
        for neighbor in graph[node]:
            in_degree[neighbor] += 1

    queue = deque([node for node in graph if in_degree[node] == 0])
    result = []

    while queue:
        node = queue.popleft()
        result.append(node)
        for neighbor in graph[node]:
            in_degree[neighbor] -= 1
            if in_degree[neighbor] == 0:
                queue.append(neighbor)

    return result

# 示例图
graph = {
    'A': ['C'],
    'B': ['C', 'D'],
    'C': ['E'],
    'D': ['F'],
    'E': ['F'],
    'F': []
}

print(topological_sort_bfs(graph))
```

**输入：**
```python
graph = {
    'A': ['C'],
    'B': ['C', 'D'],
    'C': ['E'],
    'D': ['F'],
    'E': ['F'],
    'F': []
}
```

**输出：**
```python
['A', 'B', 'C', 'D', 'E', 'F']
```

## 拓扑排序的应用场景

拓扑排序在实际中有广泛的应用，以下是一些常见的应用场景：

1. **任务调度**：在项目管理中，某些任务可能依赖于其他任务的完成。拓扑排序可以帮助确定任务的执行顺序。
2. **课程安排**：在大学课程中，某些课程可能有先修课程的要求。拓扑排序可以帮助学生确定课程的选修顺序。
3. **编译顺序**：在编译器中，源代码文件之间可能存在依赖关系。拓扑排序可以帮助确定文件的编译顺序。

## 总结

拓扑排序是一种用于有向无环图的线性排序算法，它可以帮助我们解决依赖关系问题。通过深度优先搜索（DFS）或广度优先搜索（BFS），我们可以有效地实现拓扑排序。拓扑排序在任务调度、课程安排和编译顺序等实际场景中有着广泛的应用。

:::tip
如果你对图论和算法感兴趣，可以尝试实现拓扑排序的其他变体，或者探索其他图算法，如最短路径算法、最小生成树算法等。
:::

## 附加资源与练习

- **练习**：尝试在给定的图中手动进行拓扑排序，并验证你的结果是否与代码输出一致。
- **资源**：你可以参考《算法导论》或《算法图解》等书籍，进一步学习图论和算法相关知识。