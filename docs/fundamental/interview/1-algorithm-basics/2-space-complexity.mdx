---
title: 空间复杂度
description: 了解空间复杂度的基本概念，学习如何分析算法在运行过程中占用的内存空间，并通过实际案例掌握其应用。
---

## 什么是空间复杂度？

空间复杂度（Space Complexity）是衡量算法在运行过程中占用内存空间大小的指标。它帮助我们理解算法在执行时所需的内存资源，尤其是在处理大规模数据时，空间复杂度的高低直接影响程序的性能和可扩展性。

与时间复杂度类似，空间复杂度通常也用大 O 表示法（Big O Notation）来描述。它表示算法在最坏情况下所需的内存空间随输入规模增长的趋势。

:::note
空间复杂度不仅包括算法中显式使用的变量和数据结构，还包括递归调用栈、临时变量等隐式占用的内存空间。
:::

---

## 如何计算空间复杂度？

计算空间复杂度时，我们需要关注以下几个方面：

1. **固定空间**：算法中使用的常量空间，例如变量、常量值等。
2. **可变空间**：算法中随输入规模变化的空间，例如数组、链表、递归栈等。

### 示例 1：固定空间复杂度

以下代码的空间复杂度为 O(1)，因为它只使用了固定数量的变量：

```python
def sum_of_two_numbers(a, b):
    result = a + b
    return result
```

在这个例子中，无论输入 `a` 和 `b` 的大小如何，算法始终只使用一个变量 `result` 来存储结果。

### 示例 2：可变空间复杂度

以下代码的空间复杂度为 O(n)，因为它使用了一个与输入规模 `n` 相关的数组：

```python
def create_array(n):
    arr = [0] * n  # 创建一个长度为 n 的数组
    return arr
```

在这个例子中，数组 `arr` 的长度与输入 `n` 成正比，因此空间复杂度为 O(n)。

---

## 递归与空间复杂度

递归算法的空间复杂度通常与递归深度相关。每次递归调用都会占用一定的栈空间，因此递归深度越大，空间复杂度越高。

### 示例 3：递归的空间复杂度

以下代码计算斐波那契数列的第 `n` 项，其空间复杂度为 O(n)：

```python
def fibonacci(n):
    if n <= 1:
        return n
    return fibonacci(n - 1) + fibonacci(n - 2)
```

在这个例子中，递归调用栈的深度为 `n`，因此空间复杂度为 O(n)。

:::caution
递归算法的空间复杂度可能较高，尤其是在递归深度较大的情况下。优化递归算法（例如使用尾递归或迭代）可以降低空间复杂度。
:::

---

## 实际应用场景

### 场景 1：排序算法

不同的排序算法具有不同的空间复杂度。例如：

- **冒泡排序**：空间复杂度为 O(1)，因为它只需要常数级别的额外空间。
- **归并排序**：空间复杂度为 O(n)，因为它需要额外的数组来存储合并后的结果。

### 场景 2：图的遍历

在图的深度优先搜索（DFS）中，空间复杂度取决于递归深度或栈的大小。对于具有 `V` 个顶点和 `E` 条边的图，空间复杂度为 O(V)。

---

## 总结

空间复杂度是算法分析中的重要概念，它帮助我们理解算法在运行过程中占用的内存资源。通过分析固定空间和可变空间，我们可以更好地优化算法，尤其是在处理大规模数据时。

:::tip
在实际开发中，除了关注时间复杂度，也要注意空间复杂度。合理选择数据结构和算法，可以有效降低内存占用。
:::

---

## 附加资源与练习

### 练习 1
分析以下代码的空间复杂度：

```python
def matrix_sum(matrix):
    total = 0
    for row in matrix:
        for num in row:
            total += num
    return total
```

### 练习 2
编写一个空间复杂度为 O(1) 的算法，计算数组中所有元素的和。

### 附加资源
- [Big O Notation 详解](https://example.com/big-o-notation)
- [递归与迭代的空间复杂度对比](https://example.com/recursion-vs-iteration)

通过学习和实践，你将能够更好地掌握空间复杂度的概念，并在实际编程中应用它！