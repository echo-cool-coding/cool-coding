---
title: 字符串匹配算法
description: 了解字符串匹配算法的基本概念、常见算法及其实现，掌握如何在实际问题中应用这些算法。
---

# 字符串匹配算法

字符串匹配是计算机科学中的一个经典问题，广泛应用于文本搜索、数据检索、生物信息学等领域。简单来说，字符串匹配的目标是**在一个主字符串（文本）中查找一个子字符串（模式）的出现位置**。本文将介绍几种常见的字符串匹配算法，并通过代码示例和实际案例帮助你理解它们的原理和应用。

## 1. 什么是字符串匹配？

字符串匹配问题可以描述为：给定一个**主字符串（Text）**和一个**模式字符串（Pattern）**，我们需要在 Text 中找到所有与 Pattern 完全匹配的子串，并返回它们的起始位置。

例如：
- 主字符串：`"ABABDABACDABABCABAB"`
- 模式字符串：`"ABABCABAB"`
- 目标：找到模式在主字符串中的所有匹配位置。

## 2. 常见的字符串匹配算法

### 2.1 朴素算法（Brute Force）

朴素算法是最简单的字符串匹配方法。它的思想是**逐个字符比较主字符串和模式字符串**，直到找到完全匹配的子串或遍历完整个主字符串。

#### 算法步骤：
1. 从主字符串的第一个字符开始，逐个与模式字符串的字符进行比较。
2. 如果所有字符都匹配，则记录匹配的起始位置。
3. 如果某个字符不匹配，则将模式字符串向右移动一位，重新开始比较。
4. 重复上述过程，直到遍历完主字符串。

#### 代码示例：
```python
def brute_force_search(text, pattern):
    n = len(text)
    m = len(pattern)
    positions = []

    for i in range(n - m + 1):
        j = 0
        while j < m and text[i + j] == pattern[j]:
            j += 1
        if j == m:
            positions.append(i)

    return positions

# 示例
text = "ABABDABACDABABCABAB"
pattern = "ABABCABAB"
print(brute_force_search(text, pattern))  # 输出: [10]
```

#### 时间复杂度：
- 最坏情况下，时间复杂度为 `O(n * m)`，其中 `n` 是主字符串的长度，`m` 是模式字符串的长度。

:::note
朴素算法虽然简单，但在某些情况下效率较低，尤其是当主字符串和模式字符串较长时。
:::

### 2.2 Knuth-Morris-Pratt (KMP) 算法

KMP 算法通过**预处理模式字符串**，利用部分匹配信息来避免不必要的字符比较，从而提高匹配效率。

#### 核心思想：
- 当发生不匹配时，KMP 算法不会将模式字符串向右移动一位，而是利用**部分匹配表（Partial Match Table）**来确定下一次匹配的起始位置。

#### 部分匹配表：
部分匹配表记录了模式字符串中每个前缀的最长公共前后缀的长度。

#### 代码示例：
```python
def compute_lps_array(pattern):
    m = len(pattern)
    lps = [0] * m
    length = 0
    i = 1

    while i < m:
        if pattern[i] == pattern[length]:
            length += 1
            lps[i] = length
            i += 1
        else:
            if length != 0:
                length = lps[length - 1]
            else:
                lps[i] = 0
                i += 1

    return lps

def kmp_search(text, pattern):
    n = len(text)
    m = len(pattern)
    lps = compute_lps_array(pattern)
    positions = []
    i = 0
    j = 0

    while i < n:
        if pattern[j] == text[i]:
            i += 1
            j += 1
            if j == m:
                positions.append(i - j)
                j = lps[j - 1]
        else:
            if j != 0:
                j = lps[j - 1]
            else:
                i += 1

    return positions

# 示例
text = "ABABDABACDABABCABAB"
pattern = "ABABCABAB"
print(kmp_search(text, pattern))  # 输出: [10]
```

#### 时间复杂度：
- KMP 算法的时间复杂度为 `O(n + m)`，其中 `n` 是主字符串的长度，`m` 是模式字符串的长度。

:::tip
KMP 算法通过预处理模式字符串，减少了不必要的字符比较，适合处理较长的字符串匹配问题。
:::

### 2.3 Boyer-Moore 算法

Boyer-Moore 算法是一种高效的字符串匹配算法，它通过**从右向左比较字符**，并利用**坏字符规则**和**好后缀规则**来跳过不必要的比较。

#### 核心思想：
- **坏字符规则**：当发现不匹配时，根据主字符串中的字符在模式字符串中的位置，尽可能多地跳过字符。
- **好后缀规则**：当发现部分匹配时，利用模式字符串中已匹配的后缀来跳过字符。

#### 代码示例：
```python
def boyer_moore_search(text, pattern):
    n = len(text)
    m = len(pattern)
    positions = []

    # 预处理坏字符规则
    bad_char = {}
    for i in range(m):
        bad_char[pattern[i]] = i

    # 搜索过程
    s = 0
    while s <= n - m:
        j = m - 1
        while j >= 0 and pattern[j] == text[s + j]:
            j -= 1
        if j < 0:
            positions.append(s)
            s += (m - bad_char.get(text[s + m], -1)) if s + m < n else 1
        else:
            s += max(1, j - bad_char.get(text[s + j], -1))

    return positions

# 示例
text = "ABABDABACDABABCABAB"
pattern = "ABABCABAB"
print(boyer_moore_search(text, pattern))  # 输出: [10]
```

#### 时间复杂度：
- 最坏情况下，时间复杂度为 `O(n * m)`，但在实际应用中，Boyer-Moore 算法通常表现优异。

:::caution
Boyer-Moore 算法在实际应用中效率较高，但在某些情况下（如模式字符串较短时），可能不如 KMP 算法高效。
:::

## 3. 实际应用场景

字符串匹配算法在以下场景中广泛应用：
- **文本编辑器中的查找功能**：如查找某个单词或短语在文档中的位置。
- **搜索引擎**：用于在大量文本数据中快速定位关键词。
- **生物信息学**：用于 DNA 序列匹配和基因分析。

## 4. 总结

字符串匹配算法是计算机科学中的重要基础，掌握这些算法不仅能帮助你解决实际问题，还能提升你的编程能力。本文介绍了三种常见的字符串匹配算法：
1. **朴素算法**：简单但效率较低。
2. **KMP 算法**：通过预处理模式字符串提高效率。
3. **Boyer-Moore 算法**：利用坏字符和好后缀规则进一步优化。

## 5. 附加资源与练习

- **练习**：尝试实现上述算法，并在不同长度的字符串上测试它们的性能。
- **扩展阅读**：学习更多高级字符串匹配算法，如 Rabin-Karp 算法和 Aho-Corasick 算法。

:::warning
在实际应用中，选择合适的算法需要根据具体问题的特点（如字符串长度、匹配频率等）进行权衡。
:::