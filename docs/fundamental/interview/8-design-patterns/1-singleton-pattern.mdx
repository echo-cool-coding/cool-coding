---
title: 单例模式
description: 单例模式是一种创建型设计模式，确保一个类只有一个实例，并提供一个全局访问点。本文详细介绍单例模式的概念、实现方式及其实际应用场景。
---

# 单例模式

单例模式（Singleton Pattern）是一种创建型设计模式，它确保一个类只有一个实例，并提供一个全局访问点。这种模式常用于需要全局唯一对象的场景，例如配置管理、日志记录、数据库连接池等。

## 为什么需要单例模式？

在某些情况下，我们希望某个类在整个应用程序中只有一个实例。例如，如果我们需要一个全局的配置管理器，多个地方都需要访问相同的配置信息，那么使用单例模式可以确保所有地方都使用同一个配置管理器实例，避免重复创建和资源浪费。

## 单例模式的实现

单例模式的实现方式有多种，下面我们将介绍几种常见的实现方式。

### 1. 懒汉式单例

懒汉式单例是指在第一次使用时才创建实例。这种方式可以延迟实例化，节省资源。

```javascript
class Singleton {
  constructor() {
    if (!Singleton.instance) {
      Singleton.instance = this;
    }
    return Singleton.instance;
  }

  static getInstance() {
    if (!Singleton.instance) {
      Singleton.instance = new Singleton();
    }
    return Singleton.instance;
  }
}

const instance1 = Singleton.getInstance();
const instance2 = Singleton.getInstance();

console.log(instance1 === instance2); // 输出: true
```

在上面的代码中，`Singleton` 类的构造函数会检查是否已经存在一个实例。如果不存在，则创建一个新实例并将其赋值给 `Singleton.instance`。`getInstance` 方法用于获取单例实例。

### 2. 饿汉式单例

饿汉式单例是指在类加载时就创建实例。这种方式可以避免多线程环境下的同步问题，但可能会浪费资源。

```javascript
class Singleton {
  static instance = new Singleton();

  constructor() {
    if (Singleton.instance) {
      throw new Error("Singleton instance already exists!");
    }
  }

  static getInstance() {
    return Singleton.instance;
  }
}

const instance1 = Singleton.getInstance();
const instance2 = Singleton.getInstance();

console.log(instance1 === instance2); // 输出: true
```

在上面的代码中，`Singleton` 类的实例在类加载时就已经创建好了。`getInstance` 方法直接返回这个实例。

### 3. 线程安全的单例

在多线程环境下，懒汉式单例可能会导致多个线程同时创建实例，从而破坏单例的唯一性。为了解决这个问题，可以使用同步机制来确保线程安全。

```javascript
class Singleton {
  static instance;

  constructor() {
    if (Singleton.instance) {
      throw new Error("Singleton instance already exists!");
    }
  }

  static getInstance() {
    if (!Singleton.instance) {
      synchronized(Singleton) {
        if (!Singleton.instance) {
          Singleton.instance = new Singleton();
        }
      }
    }
    return Singleton.instance;
  }
}

const instance1 = Singleton.getInstance();
const instance2 = Singleton.getInstance();

console.log(instance1 === instance2); // 输出: true
```

:::note
注意：上面的代码中使用了 `synchronized` 关键字来确保线程安全。在实际的 JavaScript 环境中，`synchronized` 并不存在，这里只是为了演示线程安全的实现思路。在 JavaScript 中，可以使用其他方式来实现线程安全，例如使用 `Promise` 或 `async/await`。
:::

## 单例模式的实际应用

单例模式在实际开发中有很多应用场景，下面我们来看几个常见的例子。

### 1. 配置管理器

在一个应用程序中，通常会有一些全局的配置信息，例如数据库连接信息、API 密钥等。这些配置信息通常只需要加载一次，并在整个应用程序中共享。使用单例模式可以确保配置管理器只有一个实例。

```javascript
class ConfigManager {
  static instance;

  constructor() {
    if (ConfigManager.instance) {
      return ConfigManager.instance;
    }
    this.config = {};
    ConfigManager.instance = this;
  }

  setConfig(key, value) {
    this.config[key] = value;
  }

  getConfig(key) {
    return this.config[key];
  }
}

const configManager1 = new ConfigManager();
configManager1.setConfig("apiKey", "123456");

const configManager2 = new ConfigManager();
console.log(configManager2.getConfig("apiKey")); // 输出: 123456
```

### 2. 日志记录器

日志记录器通常也需要在整个应用程序中共享。使用单例模式可以确保日志记录器只有一个实例，避免重复创建和资源浪费。

```javascript
class Logger {
  static instance;

  constructor() {
    if (Logger.instance) {
      return Logger.instance;
    }
    this.logs = [];
    Logger.instance = this;
  }

  log(message) {
    this.logs.push(message);
    console.log(`[LOG] ${message}`);
  }

  getLogs() {
    return this.logs;
  }
}

const logger1 = new Logger();
logger1.log("First log message");

const logger2 = new Logger();
logger2.log("Second log message");

console.log(logger2.getLogs()); // 输出: ["First log message", "Second log message"]
```

## 总结

单例模式是一种非常常用的设计模式，它确保一个类只有一个实例，并提供一个全局访问点。单例模式适用于需要全局唯一对象的场景，例如配置管理、日志记录、数据库连接池等。

在实际开发中，我们需要根据具体的需求选择合适的单例实现方式。例如，懒汉式单例可以延迟实例化，节省资源；饿汉式单例可以避免多线程环境下的同步问题；线程安全的单例可以确保在多线程环境下单例的唯一性。

## 附加资源与练习

- **练习 1**：尝试实现一个线程安全的单例模式，并在多线程环境下测试其唯一性。
- **练习 2**：思考单例模式的优缺点，并讨论在什么情况下不适合使用单例模式。
- **附加资源**：阅读更多关于设计模式的书籍或文章，例如《设计模式：可复用面向对象软件的基础》。

:::tip
提示：单例模式虽然简单，但在实际应用中需要注意其潜在的问题，例如全局状态的管理、测试的复杂性等。在使用单例模式时，务必谨慎考虑其适用性。
:::