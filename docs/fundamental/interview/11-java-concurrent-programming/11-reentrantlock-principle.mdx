---
title: ReentrantLock原理
description: 深入理解Java中的ReentrantLock，掌握其工作原理、使用场景以及如何在实际项目中应用。
---

# ReentrantLock原理

在Java并发编程中，`ReentrantLock`是一个非常重要的工具，它提供了比`synchronized`关键字更灵活的锁机制。本文将详细介绍`ReentrantLock`的工作原理、使用方式以及在实际项目中的应用场景。

## 什么是ReentrantLock？

`ReentrantLock`是Java并发包`java.util.concurrent.locks`中的一个类，它实现了`Lock`接口。与`synchronized`关键字不同，`ReentrantLock`提供了更高级的功能，例如可重入性、公平锁、非公平锁、可中断的锁获取等。

### 可重入性

`ReentrantLock`是可重入的锁，这意味着同一个线程可以多次获取同一个锁而不会导致死锁。例如：

```java
ReentrantLock lock = new ReentrantLock();

public void methodA() {
    lock.lock();
    try {
        methodB();
    } finally {
        lock.unlock();
    }
}

public void methodB() {
    lock.lock();
    try {
        // 执行一些操作
    } finally {
        lock.unlock();
    }
}
```

在上面的代码中，`methodA`和`methodB`都使用了同一个`ReentrantLock`实例。由于`ReentrantLock`是可重入的，`methodA`调用`methodB`时不会导致死锁。

## ReentrantLock的工作原理

`ReentrantLock`内部使用了一个同步器`AbstractQueuedSynchronizer`（AQS）来实现锁的获取和释放。AQS维护了一个FIFO队列，用于管理等待获取锁的线程。

### 公平锁与非公平锁

`ReentrantLock`支持公平锁和非公平锁两种模式：

- **公平锁**：线程按照请求锁的顺序获取锁，即先到先得。
- **非公平锁**：线程可以插队获取锁，可能会导致某些线程长时间等待。

默认情况下，`ReentrantLock`是非公平锁，但可以通过构造函数指定为公平锁：

```java
ReentrantLock fairLock = new ReentrantLock(true); // 公平锁
ReentrantLock unfairLock = new ReentrantLock();   // 非公平锁
```

### 锁的获取与释放

`ReentrantLock`的锁获取和释放是通过`lock()`和`unlock()`方法实现的。`lock()`方法用于获取锁，如果锁已被其他线程持有，则当前线程会被阻塞，直到锁被释放。`unlock()`方法用于释放锁。

```java
ReentrantLock lock = new ReentrantLock();

public void criticalSection() {
    lock.lock();
    try {
        // 临界区代码
    } finally {
        lock.unlock();
    }
}
```

:::note
**注意**：`unlock()`方法必须在`finally`块中调用，以确保锁在发生异常时也能被释放。
:::

## 实际应用场景

`ReentrantLock`在实际项目中有广泛的应用，特别是在需要更细粒度的锁控制时。以下是一个简单的应用场景：

### 场景：银行账户转账

假设我们有一个银行账户类`BankAccount`，我们需要确保在转账操作时，两个账户的余额更新是线程安全的。

```java
class BankAccount {
    private final ReentrantLock lock = new ReentrantLock();
    private int balance;

    public BankAccount(int balance) {
        this.balance = balance;
    }

    public void transfer(BankAccount target, int amount) {
        lock.lock();
        try {
            target.lock.lock();
            try {
                if (this.balance >= amount) {
                    this.balance -= amount;
                    target.balance += amount;
                }
            } finally {
                target.lock.unlock();
            }
        } finally {
            lock.unlock();
        }
    }
}
```

在这个例子中，`transfer`方法使用了两个`ReentrantLock`实例来确保转账操作的线程安全性。

## 总结

`ReentrantLock`是Java并发编程中一个非常强大的工具，它提供了比`synchronized`更灵活的锁机制。通过理解`ReentrantLock`的工作原理和使用方式，我们可以更好地控制多线程环境下的资源访问，避免竞争条件和死锁问题。

:::tip
**提示**：在实际项目中，建议优先使用`synchronized`关键字，除非你需要`ReentrantLock`提供的额外功能。
:::

## 附加资源与练习

- **练习**：尝试实现一个线程安全的队列，使用`ReentrantLock`来确保队列的线程安全性。
- **资源**：阅读Java官方文档中关于`ReentrantLock`和`AbstractQueuedSynchronizer`的详细说明。

通过不断练习和深入学习，你将能够更好地掌握`ReentrantLock`的使用，并在实际项目中灵活应用。