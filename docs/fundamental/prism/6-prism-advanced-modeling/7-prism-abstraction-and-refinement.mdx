---
title: PRISM 抽象与细化
description: 学习如何使用PRISM的概率模型检查工具进行抽象与细化操作，优化模型验证效率并保持精度。
---

# PRISM 抽象与细化

## 介绍

在PRISM模型检查中，**抽象（Abstraction）**和**细化（Refinement）**是处理复杂系统的关键技术。抽象通过简化模型状态空间来提升验证效率，而细化则用于逐步恢复关键细节以确保验证结果的正确性。本章将介绍这两种技术的原理、实现方法及实际应用场景。

---

## 抽象的基本概念

抽象的核心思想是**忽略不影响验证目标的系统细节**，从而减少状态空间。PRISM支持以下抽象方法：
1. **变量聚合**：将多个变量合并为一个抽象变量。
2. **行为抽象**：用概率范围代替精确转移概率（例如区间抽象）。
3. **模块抽象**：隐藏模块内部状态，仅暴露接口行为。

:::tip 何时使用抽象？
- 当模型状态爆炸导致验证无法完成时
- 需要快速验证系统整体性质时
:::

---

## 细化技术

细化是抽象的逆过程，用于逐步**恢复被抽象忽略的关键细节**。PRISM中常见的细化策略包括：
1. **基于反例的细化**：如果抽象模型验证失败，通过反例定位需要细化的部分。
2. **基于精度的细化**：逐步缩小概率转移的区间范围。

```prism
// 示例：抽象模型中的区间概率
module M
  x : [0..1];
  [] x=0 -> 0.5..0.7 : (x'=1);
endmodule
```

---

## 实际案例：网络协议验证

假设我们需要验证一个网络协议的超时重传机制：

1. **初始抽象模型**：将网络延迟抽象为`[low, high]`区间
2. **验证性质**：`P>=0.95 [ F<=T message_delivered ]`
3. **反例分析**：若验证失败，细化延迟分布的具体概率分支

```mermaid
graph LR
  A[抽象模型] -->|验证失败| B[定位反例]
  B --> C[细化延迟分布]
  C --> D[重新验证]
```

---

## 代码示例：逐步细化

以下展示如何在PRISM中实现抽象-细化循环：

```prism
// 步骤1：初始抽象模型
module sender
  sent : bool init false;
  [] !sent -> 0.8..1.0 : (sent'=true);
endmodule

// 步骤2：第一次细化（根据反例）
module sender_refined
  sent : bool init false;
  [] !sent -> 0.9 : (sent'=true) + 0.1 : (sent'=false);
endmodule
```

---

## 总结与练习

### 关键点总结
- 抽象是应对状态爆炸的必要技术
- 细化需要结合验证目标和反例分析
- PRISM支持概率区间的抽象表示

### 练习建议
1. 在PRISM GUI中尝试对简单模型进行抽象验证
2. 手动构造一个反例并设计细化步骤
3. 比较抽象前后验证时间和结果差异

### 扩展阅读
- PRISM手册中的"Abstraction-Refinement"章节
- 《Principles of Model Checking》第10章