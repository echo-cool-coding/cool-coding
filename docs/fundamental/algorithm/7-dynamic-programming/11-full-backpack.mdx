---
title: 完全背包问题
description: 了解完全背包问题的基本概念、解决方法以及实际应用场景。本文适合初学者，通过清晰的解释和代码示例帮助你掌握动态规划中的完全背包问题。
---

## 什么是完全背包问题？

完全背包问题是动态规划中的经典问题之一。与 0-1 背包问题不同，完全背包问题允许每种物品被选择多次。也就是说，每种物品的数量是无限的。我们的目标是在不超过背包容量的前提下，选择一些物品，使得这些物品的总价值最大。

### 问题描述

假设我们有一个容量为 `C` 的背包，以及 `n` 种物品。每种物品有一个重量 `w[i]` 和一个价值 `v[i]`。我们的任务是选择一些物品放入背包中，使得这些物品的总重量不超过 `C`，并且总价值最大。

## 完全背包问题的动态规划解法

### 状态定义

我们定义一个二维数组 `dp[i][j]`，其中 `i` 表示前 `i` 种物品，`j` 表示当前背包的容量。`dp[i][j]` 表示在前 `i` 种物品中，容量为 `j` 的背包所能获得的最大价值。

### 状态转移方程

对于每种物品 `i`，我们有两种选择：

1. **不选择该物品**：此时 `dp[i][j] = dp[i-1][j]`。
2. **选择该物品**：此时 `dp[i][j] = dp[i][j-w[i]] + v[i]`。

因此，状态转移方程为：

```
dp[i][j] = max(dp[i-1][j], dp[i][j-w[i]] + v[i])
```

### 代码示例

以下是一个使用动态规划解决完全背包问题的 Python 代码示例：

```python
def complete_knapsack(C, weights, values):
    n = len(weights)
    dp = [0] * (C + 1)
    
    for i in range(n):
        for j in range(weights[i], C + 1):
            dp[j] = max(dp[j], dp[j - weights[i]] + values[i])
    
    return dp[C]

# 示例输入
C = 10
weights = [2, 3, 4, 5]
values = [3, 4, 5, 6]

# 输出最大价值
print(complete_knapsack(C, weights, values))  # 输出: 13
```

### 解释

- `C` 是背包的容量。
- `weights` 是每种物品的重量列表。
- `values` 是每种物品的价值列表。
- `dp[j]` 表示容量为 `j` 的背包所能获得的最大价值。

在代码中，我们通过两层循环来更新 `dp` 数组。外层循环遍历每种物品，内层循环遍历背包的容量。通过这种方式，我们可以确保每种物品可以被选择多次。

## 实际应用场景

完全背包问题在实际生活中有许多应用场景。例如：

1. **资源分配**：在有限的资源下，如何选择项目以获得最大收益。
2. **投资组合**：在有限的资金下，如何选择投资项目以获得最大回报。
3. **生产计划**：在有限的生产能力下，如何选择产品组合以获得最大利润。

## 总结

完全背包问题是动态规划中的一个重要问题，它允许每种物品被选择多次。通过定义合适的状态和状态转移方程，我们可以有效地解决这个问题。本文通过清晰的解释和代码示例，帮助你理解完全背包问题的基本概念和解决方法。

## 附加资源与练习

- **练习**：尝试修改代码，使其能够输出选择的物品列表。
- **进一步学习**：了解 0-1 背包问题与完全背包问题的区别，并尝试解决其他变种背包问题。

:::tip
如果你对动态规划的其他问题感兴趣，可以继续学习 0-1 背包问题、多重背包问题等。这些问题的解决方法与完全背包问题类似，但有一些细微的差别。
:::