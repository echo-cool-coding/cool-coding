---
title: 广度优先搜索
description: 了解广度优先搜索（BFS）的基本概念、实现方法及其在实际中的应用场景。
---

# 广度优先搜索

广度优先搜索（Breadth-First Search，简称 BFS）是一种用于遍历或搜索树或图的算法。它从根节点开始，逐层访问所有相邻节点，直到找到目标节点或遍历完整个图。BFS 通常用于解决最短路径问题，因为它总是优先访问离起点最近的节点。

## 基本概念

BFS 的核心思想是使用队列（Queue）来存储待访问的节点。算法从起点开始，将其加入队列，然后依次访问队列中的节点，并将它们的未访问邻居加入队列。这个过程会一直持续，直到队列为空或找到目标节点。

### 算法步骤

1. 将起点加入队列，并标记为已访问。
2. 从队列中取出一个节点，访问它。
3. 将该节点的所有未访问邻居加入队列，并标记为已访问。
4. 重复步骤 2 和 3，直到队列为空。

### 代码示例

以下是一个使用 Python 实现的 BFS 示例，用于遍历一个图：

```python
from collections import deque

def bfs(graph, start):
    visited = set()
    queue = deque([start])
    
    while queue:
        node = queue.popleft()
        if node not in visited:
            print(node)  # 访问节点
            visited.add(node)
            queue.extend(neighbor for neighbor in graph[node] if neighbor not in visited)

# 示例图
graph = {
    'A': ['B', 'C'],
    'B': ['A', 'D', 'E'],
    'C': ['A', 'F'],
    'D': ['B'],
    'E': ['B', 'F'],
    'F': ['C', 'E']
}

# 从节点 'A' 开始 BFS
bfs(graph, 'A')
```

**输入：**
```python
graph = {
    'A': ['B', 'C'],
    'B': ['A', 'D', 'E'],
    'C': ['A', 'F'],
    'D': ['B'],
    'E': ['B', 'F'],
    'F': ['C', 'E']
}
```

**输出：**
```
A
B
C
D
E
F
```

:::note
在 BFS 中，节点的访问顺序是逐层进行的，因此它总是优先访问离起点最近的节点。
:::

## 实际应用场景

### 1. 最短路径问题

BFS 常用于解决无权图中的最短路径问题。由于 BFS 总是优先访问离起点最近的节点，因此它可以确保找到的路径是最短的。

### 2. 社交网络中的“六度分隔”理论

在社交网络中，BFS 可以用来查找两个人之间的最短连接路径。例如，查找两个人之间最少需要多少个共同朋友才能建立联系。

### 3. 迷宫求解

BFS 可以用来解决迷宫问题，找到从起点到终点的最短路径。通过逐层扩展搜索范围，BFS 可以确保找到的路径是最短的。

## 总结

广度优先搜索是一种简单但强大的算法，适用于许多场景，尤其是需要找到最短路径的问题。通过使用队列来存储待访问的节点，BFS 能够逐层扩展搜索范围，确保优先访问离起点最近的节点。

:::tip
如果你对 BFS 感兴趣，可以尝试以下练习：
1. 修改上述代码，使其能够找到从起点到目标节点的最短路径。
2. 尝试在加权图中使用 BFS，并思考它的局限性。
:::

## 附加资源

- [广度优先搜索 - Wikipedia](https://zh.wikipedia.org/wiki/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2)
- [BFS 可视化工具](https://visualgo.net/zh/dfsbfs)

通过学习和实践，你将能够更好地理解并应用广度优先搜索算法。