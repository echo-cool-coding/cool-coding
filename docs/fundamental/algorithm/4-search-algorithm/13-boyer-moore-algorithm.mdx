---
title: Boyer-Moore算法
description: 了解Boyer-Moore算法，一种高效的字符串搜索算法，适合初学者学习。
---

# Boyer-Moore算法

Boyer-Moore算法是一种高效的字符串搜索算法，由Robert S. Boyer和J Strother Moore在1977年提出。它通过预处理模式串（即要搜索的字符串），利用模式串中的信息来跳过不必要的比较，从而显著提高搜索效率。Boyer-Moore算法在实际应用中非常高效，尤其是在处理大文本时。

## 算法简介

Boyer-Moore算法的核心思想是从模式串的末尾开始比较，利用两种启发式规则来跳过尽可能多的字符：

1. **坏字符规则（Bad Character Rule）**：当发现不匹配的字符时，算法会根据模式串中该字符的位置来决定模式串的移动距离。
2. **好后缀规则（Good Suffix Rule）**：当发现匹配的后缀时，算法会根据模式串中该后缀的位置来决定模式串的移动距离。

通过结合这两种规则，Boyer-Moore算法能够在大多数情况下跳过大量不必要的比较，从而快速找到匹配的位置。

## 算法步骤

### 1. 预处理模式串

在搜索之前，Boyer-Moore算法需要对模式串进行预处理，生成两个表：

- **坏字符表（Bad Character Table）**：记录模式串中每个字符最后一次出现的位置。
- **好后缀表（Good Suffix Table）**：记录模式串中每个后缀的最佳移动距离。

### 2. 搜索过程

搜索过程从文本的开头开始，逐步移动模式串。每次比较时，从模式串的末尾开始向前比较字符。如果发现不匹配的字符，则根据坏字符规则或好后缀规则来决定模式串的移动距离。

### 3. 匹配成功

如果在某个位置，模式串的所有字符都与文本中的对应字符匹配，则找到了一个匹配的位置。

## 代码示例

以下是一个简单的Python实现Boyer-Moore算法的示例：

```python
def boyer_moore(text, pattern):
    def bad_char_table(pattern):
        table = {}
        length = len(pattern)
        for i in range(length - 1):
            table[pattern[i]] = length - i - 1
        return table

    def good_suffix_table(pattern):
        length = len(pattern)
        table = [length] * length
        last_prefix_position = length
        for i in range(length - 1, -1, -1):
            if is_prefix(pattern, i + 1):
                last_prefix_position = i + 1
            table[i] = last_prefix_position - i + length - 1
        for i in range(length - 1):
            slen = suffix_length(pattern, i)
            table[slen] = length - 1 - i + slen
        return table

    def is_prefix(pattern, p):
        length = len(pattern)
        j = 0
        for i in range(p, length):
            if pattern[i] != pattern[j]:
                return False
            j += 1
        return True

    def suffix_length(pattern, p):
        length = len(pattern)
        slen = 0
        i = p
        j = length - 1
        while i >= 0 and pattern[i] == pattern[j]:
            slen += 1
            i -= 1
            j -= 1
        return slen

    n = len(text)
    m = len(pattern)
    if m == 0:
        return 0
    bad_char = bad_char_table(pattern)
    good_suffix = good_suffix_table(pattern)
    i = 0
    while i <= n - m:
        j = m - 1
        while j >= 0 and pattern[j] == text[i + j]:
            j -= 1
        if j < 0:
            return i
        else:
            i += max(bad_char.get(text[i + j], m), good_suffix[j])
    return -1

# 示例输入
text = "ABAAABCD"
pattern = "ABC"
result = boyer_moore(text, pattern)
print(f"Pattern found at index: {result}")
```

**输出：**
```
Pattern found at index: 4
```

## 实际应用场景

Boyer-Moore算法在实际中有广泛的应用，尤其是在需要快速搜索大文本的场景中。例如：

- **文本编辑器**：在文本编辑器中查找特定字符串时，Boyer-Moore算法可以快速定位匹配的位置。
- **数据压缩**：在数据压缩算法中，Boyer-Moore算法可以用于快速查找重复的字符串模式。
- **生物信息学**：在DNA序列分析中，Boyer-Moore算法可以用于快速查找特定的基因序列。

## 总结

Boyer-Moore算法是一种高效的字符串搜索算法，通过预处理模式串并利用坏字符规则和好后缀规则，能够显著减少比较次数，提高搜索效率。虽然算法的实现相对复杂，但它在处理大文本时表现出色，是学习字符串搜索算法的重要一步。

## 附加资源与练习

- **练习**：尝试实现Boyer-Moore算法，并在不同的文本和模式串上进行测试，观察算法的性能。
- **资源**：
  - [Boyer-Moore算法的维基百科页面](https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_string-search_algorithm)
  - [《算法导论》](https://mitpress.mit.edu/books/introduction-algorithms) 中的字符串匹配章节

通过学习和实践，你将能够更好地理解Boyer-Moore算法的原理和应用，并在实际项目中灵活运用。