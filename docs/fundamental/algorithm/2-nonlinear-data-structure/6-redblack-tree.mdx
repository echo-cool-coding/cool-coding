---
title: 红黑树
description: 红黑树是一种自平衡的二叉搜索树，它通过颜色标记和旋转操作来保持树的平衡，确保在最坏情况下也能高效地进行插入、删除和查找操作。
---

# 红黑树

红黑树（Red-Black Tree）是一种自平衡的二叉搜索树（BST），它在插入和删除操作后通过颜色标记和旋转操作来保持树的平衡。红黑树的设计确保了在最坏情况下，树的高度仍然是 `O(log n)`，从而保证了高效的查找、插入和删除操作。

## 红黑树的基本性质

红黑树具有以下五个基本性质：

1. **每个节点要么是红色，要么是黑色。**
2. **根节点是黑色。**
3. **所有叶子节点（NIL节点）都是黑色。**
4. **如果一个节点是红色的，则它的两个子节点都是黑色的。**（即没有两个连续的红色节点）
5. **从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。**

这些性质确保了红黑树的平衡性。

## 红黑树的操作

### 插入操作

在红黑树中插入一个新节点时，首先按照二叉搜索树的规则找到插入位置，并将新节点标记为红色。然后，根据红黑树的性质进行调整，可能需要进行颜色翻转和旋转操作。

```python
class Node:
    def __init__(self, key, color='red'):
        self.key = key
        self.color = color
        self.left = None
        self.right = None
        self.parent = None

class RedBlackTree:
    def __init__(self):
        self.NIL = Node(None, 'black')
        self.root = self.NIL

    def insert(self, key):
        new_node = Node(key)
        new_node.left = self.NIL
        new_node.right = self.NIL
        self._insert(new_node)
        self._fix_insert(new_node)

    def _insert(self, node):
        y = None
        x = self.root
        while x != self.NIL:
            y = x
            if node.key < x.key:
                x = x.left
            else:
                x = x.right
        node.parent = y
        if y is None:
            self.root = node
        elif node.key < y.key:
            y.left = node
        else:
            y.right = node

    def _fix_insert(self, node):
        while node.parent.color == 'red':
            if node.parent == node.parent.parent.left:
                y = node.parent.parent.right
                if y.color == 'red':
                    node.parent.color = 'black'
                    y.color = 'black'
                    node.parent.parent.color = 'red'
                    node = node.parent.parent
                else:
                    if node == node.parent.right:
                        node = node.parent
                        self._left_rotate(node)
                    node.parent.color = 'black'
                    node.parent.parent.color = 'red'
                    self._right_rotate(node.parent.parent)
            else:
                y = node.parent.parent.left
                if y.color == 'red':
                    node.parent.color = 'black'
                    y.color = 'black'
                    node.parent.parent.color = 'red'
                    node = node.parent.parent
                else:
                    if node == node.parent.left:
                        node = node.parent
                        self._right_rotate(node)
                    node.parent.color = 'black'
                    node.parent.parent.color = 'red'
                    self._left_rotate(node.parent.parent)
        self.root.color = 'black'

    def _left_rotate(self, x):
        y = x.right
        x.right = y.left
        if y.left != self.NIL:
            y.left.parent = x
        y.parent = x.parent
        if x.parent is None:
            self.root = y
        elif x == x.parent.left:
            x.parent.left = y
        else:
            x.parent.right = y
        y.left = x
        x.parent = y

    def _right_rotate(self, y):
        x = y.left
        y.left = x.right
        if x.right != self.NIL:
            x.right.parent = y
        x.parent = y.parent
        if y.parent is None:
            self.root = x
        elif y == y.parent.right:
            y.parent.right = x
        else:
            y.parent.left = x
        x.right = y
        y.parent = x
```

### 删除操作

删除操作比插入操作更复杂，因为删除一个节点后可能会破坏红黑树的性质。删除操作通常需要调整颜色和进行旋转操作来恢复平衡。

```python
def delete(self, key):
    node = self._search(self.root, key)
    if node == self.NIL:
        return
    self._delete(node)

def _delete(self, node):
    y = node
    y_original_color = y.color
    if node.left == self.NIL:
        x = node.right
        self._transplant(node, node.right)
    elif node.right == self.NIL:
        x = node.left
        self._transplant(node, node.left)
    else:
        y = self._minimum(node.right)
        y_original_color = y.color
        x = y.right
        if y.parent == node:
            x.parent = y
        else:
            self._transplant(y, y.right)
            y.right = node.right
            y.right.parent = y
        self._transplant(node, y)
        y.left = node.left
        y.left.parent = y
        y.color = node.color
    if y_original_color == 'black':
        self._fix_delete(x)

def _fix_delete(self, x):
    while x != self.root and x.color == 'black':
        if x == x.parent.left:
            w = x.parent.right
            if w.color == 'red':
                w.color = 'black'
                x.parent.color = 'red'
                self._left_rotate(x.parent)
                w = x.parent.right
            if w.left.color == 'black' and w.right.color == 'black':
                w.color = 'red'
                x = x.parent
            else:
                if w.right.color == 'black':
                    w.left.color = 'black'
                    w.color = 'red'
                    self._right_rotate(w)
                    w = x.parent.right
                w.color = x.parent.color
                x.parent.color = 'black'
                w.right.color = 'black'
                self._left_rotate(x.parent)
                x = self.root
        else:
            w = x.parent.left
            if w.color == 'red':
                w.color = 'black'
                x.parent.color = 'red'
                self._right_rotate(x.parent)
                w = x.parent.left
            if w.right.color == 'black' and w.left.color == 'black':
                w.color = 'red'
                x = x.parent
            else:
                if w.left.color == 'black':
                    w.right.color = 'black'
                    w.color = 'red'
                    self._left_rotate(w)
                    w = x.parent.left
                w.color = x.parent.color
                x.parent.color = 'black'
                w.left.color = 'black'
                self._right_rotate(x.parent)
                x = self.root
    x.color = 'black'
```

## 红黑树的应用

红黑树广泛应用于需要高效查找、插入和删除操作的场景中。以下是一些常见的应用场景：

1. **关联容器**：C++的 `std::map` 和 `std::set` 通常使用红黑树作为底层数据结构。
2. **数据库索引**：许多数据库系统使用红黑树来实现索引结构，以支持快速的数据检索。
3. **内存管理**：操作系统中的内存管理模块可能会使用红黑树来管理内存块。

## 总结

红黑树是一种强大的自平衡二叉搜索树，它通过颜色标记和旋转操作来保持树的平衡，确保了高效的查找、插入和删除操作。虽然红黑树的实现较为复杂，但它在许多实际应用中表现出了优异的性能。

:::tip
如果你对红黑树的实现细节感兴趣，可以尝试自己实现一个红黑树，并通过插入和删除操作来观察树的变化。
:::

## 附加资源

- [红黑树 - 维基百科](https://zh.wikipedia.org/wiki/%E7%BA%A2%E9%BB%91%E6%A0%91)
- [Introduction to Algorithms](https://mitpress.mit.edu/books/introduction-algorithms) - 这本书详细介绍了红黑树及其相关算法。

## 练习

1. 实现一个红黑树，并测试其插入和删除操作。
2. 比较红黑树与普通二叉搜索树在插入和删除操作上的性能差异。
3. 研究红黑树在C++标准库中的应用，并尝试使用 `std::map` 和 `std::set` 进行实验。