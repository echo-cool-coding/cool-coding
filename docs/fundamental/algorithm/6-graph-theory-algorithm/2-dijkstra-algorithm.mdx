---
title: Dijkstra算法
description: 了解Dijkstra算法，一种用于在加权图中找到单源最短路径的经典算法。本文将从基础概念入手，逐步讲解算法原理，并提供代码示例和实际应用场景。
---

# Dijkstra算法

Dijkstra算法是图论中最经典的单源最短路径算法之一，由荷兰计算机科学家Edsger W. Dijkstra于1956年提出。它用于在加权图中找到从某个起点到所有其他节点的最短路径。Dijkstra算法适用于边权重为非负数的图。

## 算法简介

Dijkstra算法的核心思想是通过贪心策略逐步扩展最短路径。它维护一个优先队列（通常是最小堆），用于选择当前距离起点最近的节点，并更新其邻居节点的距离。通过不断重复这一过程，最终可以得到从起点到所有其他节点的最短路径。

### 算法步骤

1. **初始化**：将起点的距离设为0，其他节点的距离设为无穷大（表示尚未访问）。
2. **选择当前节点**：从优先队列中选择距离起点最近的节点（即当前距离最小的节点）。
3. **更新邻居节点**：对于当前节点的每个邻居节点，计算从起点经过当前节点到达邻居节点的距离。如果这个距离比已知的距离更短，则更新邻居节点的距离。
4. **标记为已访问**：将当前节点标记为已访问，不再参与后续的计算。
5. **重复**：重复步骤2-4，直到所有节点都被访问过或优先队列为空。

### 代码示例

以下是一个使用Python实现的Dijkstra算法示例：

```python
import heapq

def dijkstra(graph, start):
    # 初始化距离字典
    distances = {node: float('inf') for node in graph}
    distances[start] = 0
    # 优先队列，存储 (距离, 节点)
    priority_queue = [(0, start)]
    
    while priority_queue:
        current_distance, current_node = heapq.heappop(priority_queue)
        
        # 如果当前节点的距离已经大于已知距离，跳过
        if current_distance > distances[current_node]:
            continue
        
        # 遍历邻居节点
        for neighbor, weight in graph[current_node].items():
            distance = current_distance + weight
            # 如果找到更短的路径，更新距离并加入优先队列
            if distance < distances[neighbor]:
                distances[neighbor] = distance
                heapq.heappush(priority_queue, (distance, neighbor))
    
    return distances
```

#### 输入与输出

假设我们有以下图结构：

```python
graph = {
    'A': {'B': 1, 'C': 4},
    'B': {'A': 1, 'C': 2, 'D': 5},
    'C': {'A': 4, 'B': 2, 'D': 1},
    'D': {'B': 5, 'C': 1}
}
```

调用 `dijkstra(graph, 'A')` 将返回：

```python
{'A': 0, 'B': 1, 'C': 3, 'D': 4}
```

这表示从节点 `A` 到其他节点的最短距离。

### 实际应用场景

Dijkstra算法在许多实际场景中都有广泛应用，例如：

1. **导航系统**：在地图应用中，Dijkstra算法可以用于计算从一个地点到另一个地点的最短路径。
2. **网络路由**：在计算机网络中，路由器使用类似Dijkstra的算法来确定数据包的最佳传输路径。
3. **物流规划**：在物流和供应链管理中，Dijkstra算法可以帮助优化货物的运输路线。

### 总结

Dijkstra算法是一种高效且易于理解的单源最短路径算法，适用于边权重为非负数的图。通过贪心策略和优先队列的结合，它能够快速找到从起点到所有其他节点的最短路径。

:::tip
如果你对Dijkstra算法感兴趣，可以尝试以下练习：
1. 修改代码，使其能够输出最短路径的具体节点顺序。
2. 尝试在图中加入负权边，观察算法的行为。
:::

### 附加资源

- [Dijkstra算法的维基百科页面](https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm)
- 《算法导论》中的图论章节
- 在线算法可视化工具，如[VisuAlgo](https://visualgo.net/en/sssp)

通过学习和实践，你将能够更好地掌握Dijkstra算法及其应用！