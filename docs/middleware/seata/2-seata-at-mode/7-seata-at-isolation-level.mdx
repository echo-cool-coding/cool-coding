---
title: Seata AT隔离级别
description: "了解 Seata AT 模式中的隔离级别，掌握分布式事务的隔离性原理及其在实际场景中的应用。"
---

## 什么是 Seata AT 隔离级别？

在分布式事务中，隔离级别（Isolation Level）是一个关键概念，它定义了事务在并发执行时如何相互隔离。Seata 的 AT（Automatic Transaction）模式通过全局锁机制实现了分布式事务的隔离性，确保事务在并发执行时不会相互干扰。

Seata AT 模式支持以下隔离级别：

1. **读未提交（Read Uncommitted）**：允许事务读取其他事务未提交的数据。
2. **读已提交（Read Committed）**：事务只能读取其他事务已提交的数据。
3. **可重复读（Repeatable Read）**：确保事务在执行期间多次读取同一数据时，结果一致。
4. **串行化（Serializable）**：最高隔离级别，确保事务完全串行执行。

Seata AT 模式默认使用 **读已提交（Read Committed）** 隔离级别，这是大多数分布式事务场景的推荐选择。

---

## Seata AT 隔离级别的工作原理

Seata AT 模式通过全局锁机制实现隔离级别。当一个事务尝试修改数据时，Seata 会为该数据加锁，防止其他事务同时修改相同的数据。以下是 Seata AT 隔离级别的工作原理：

1. **事务开始**：事务开始时，Seata 会记录事务的上下文信息。
2. **数据修改**：当事务尝试修改数据时，Seata 会为该数据加全局锁。
3. **提交事务**：事务提交时，Seata 会释放全局锁，并提交数据修改。
4. **回滚事务**：如果事务失败，Seata 会释放全局锁，并回滚数据修改。

通过全局锁机制，Seata 确保了事务的隔离性，避免了脏读、不可重复读和幻读等问题。

---

## 代码示例

以下是一个简单的代码示例，展示了如何在 Seata AT 模式下使用读已提交隔离级别：

```java
@GlobalTransactional
public void transferMoney(String fromAccount, String toAccount, BigDecimal amount) {
    // 扣减 fromAccount 的余额
    accountService.decreaseBalance(fromAccount, amount);
    // 增加 toAccount 的余额
    accountService.increaseBalance(toAccount, amount);
}
```

在这个示例中，`@GlobalTransactional` 注解标记了一个全局事务。Seata 会确保 `transferMoney` 方法中的两个操作（扣减余额和增加余额）在同一个事务中执行，并且使用读已提交隔离级别。

---

## 实际应用场景

假设我们有一个电商系统，用户在下单时需要同时扣减库存和生成订单。以下是 Seata AT 隔离级别在实际场景中的应用：

1. **扣减库存**：事务 A 扣减商品 A 的库存。
2. **生成订单**：事务 A 生成订单记录。
3. **并发事务**：事务 B 同时尝试扣减商品 A 的库存。

在 Seata AT 模式下，事务 A 会为商品 A 的库存加全局锁，事务 B 需要等待事务 A 提交后才能继续执行。这确保了库存数据的正确性，避免了超卖问题。

---

## 总结

Seata AT 模式通过全局锁机制实现了分布式事务的隔离性，支持读已提交隔离级别。通过合理使用隔离级别，可以确保分布式事务在并发执行时的数据一致性。

在实际开发中，建议根据业务需求选择合适的隔离级别。对于大多数场景，读已提交隔离级别已经足够。

---

## 附加资源与练习

- **练习**：尝试在一个分布式系统中实现 Seata AT 模式，并测试不同隔离级别的效果。
- **资源**：阅读 [Seata 官方文档](https://seata.io/zh-cn/docs/overview/what-is-seata.html) 了解更多关于 AT 模式的细节。

:::tip
如果你对 Seata AT 模式的其他特性感兴趣，可以继续学习 Seata 的 TCC 模式和 Saga 模式。
:::