---
title: Seata 自定义事务注解
description: 了解如何在Seata中使用自定义事务注解来简化分布式事务管理，并通过实际案例掌握其应用场景。
---

# Seata 自定义事务注解

## 介绍

在分布式系统中，事务管理是一个复杂且关键的问题。Seata 是一个开源的分布式事务解决方案，它提供了简单易用的 API 来管理分布式事务。Seata 默认支持 `@GlobalTransactional` 注解来标记全局事务，但在某些场景下，我们可能需要自定义事务注解来满足特定的业务需求。

本文将详细介绍如何在 Seata 中创建和使用自定义事务注解，并通过实际案例展示其应用场景。

## 什么是自定义事务注解？

自定义事务注解是一种用户定义的注解，用于标记需要进行事务管理的方法。通过自定义注解，我们可以将事务管理的逻辑与业务逻辑解耦，从而提高代码的可读性和可维护性。

## 创建自定义事务注解

首先，我们需要定义一个自定义注解。以下是一个简单的示例：

```java
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface CustomTransactional {
    String timeout() default "60"; // 默认超时时间为60秒
    String rollbackFor() default "Exception"; // 默认回滚异常为Exception
}
```

在这个示例中，我们定义了一个名为 `CustomTransactional` 的注解，它包含两个属性：`timeout` 和 `rollbackFor`。`timeout` 用于设置事务的超时时间，`rollbackFor` 用于指定触发回滚的异常类型。

## 实现自定义事务注解的逻辑

接下来，我们需要实现自定义注解的逻辑。我们可以通过 AOP（面向切面编程）来实现这一点。以下是一个简单的 AOP 切面示例：

```java
import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.annotation.Aspect;
import org.springframework.stereotype.Component;

@Aspect
@Component
public class CustomTransactionalAspect {

    @Around("@annotation(customTransactional)")
    public Object around(ProceedingJoinPoint joinPoint, CustomTransactional customTransactional) throws Throwable {
        // 获取注解属性
        String timeout = customTransactional.timeout();
        String rollbackFor = customTransactional.rollbackFor();

        // 开启事务
        System.out.println("开启事务，超时时间：" + timeout + "秒");

        try {
            // 执行业务逻辑
            Object result = joinPoint.proceed();

            // 提交事务
            System.out.println("提交事务");
            return result;
        } catch (Exception e) {
            // 回滚事务
            System.out.println("回滚事务，异常类型：" + rollbackFor);
            throw e;
        }
    }
}
```

在这个示例中，我们定义了一个切面 `CustomTransactionalAspect`，它会在带有 `CustomTransactional` 注解的方法执行前后进行事务管理。`around` 方法中，我们首先获取注解的属性，然后开启事务、执行业务逻辑，最后根据执行结果提交或回滚事务。

## 使用自定义事务注解

现在，我们可以在业务代码中使用自定义事务注解了。以下是一个简单的示例：

```java
@Service
public class OrderService {

    @CustomTransactional(timeout = "30", rollbackFor = "RuntimeException")
    public void createOrder(Order order) {
        // 创建订单逻辑
        System.out.println("创建订单：" + order);
    }
}
```

在这个示例中，`createOrder` 方法被标记为 `CustomTransactional`，并且设置了超时时间为 30 秒，回滚异常为 `RuntimeException`。当 `createOrder` 方法被调用时，Seata 会自动管理事务。

## 实际案例

假设我们有一个电商系统，用户下单时需要同时更新库存和创建订单。我们可以使用自定义事务注解来确保这两个操作在同一个事务中执行：

```java
@Service
public class OrderService {

    @Autowired
    private InventoryService inventoryService;

    @CustomTransactional(timeout = "30", rollbackFor = "RuntimeException")
    public void placeOrder(Order order) {
        // 更新库存
        inventoryService.updateInventory(order.getProductId(), order.getQuantity());

        // 创建订单
        createOrder(order);
    }

    private void createOrder(Order order) {
        // 创建订单逻辑
        System.out.println("创建订单：" + order);
    }
}
```

在这个案例中，`placeOrder` 方法被标记为 `CustomTransactional`，确保更新库存和创建订单操作在同一个事务中执行。如果其中任何一个操作失败，事务将回滚，确保数据的一致性。

## 总结

通过自定义事务注解，我们可以将事务管理的逻辑与业务逻辑解耦，从而提高代码的可读性和可维护性。本文介绍了如何创建和使用自定义事务注解，并通过实际案例展示了其应用场景。

## 附加资源

- [Seata 官方文档](https://seata.io/zh-cn/docs/overview/what-is-seata.html)
- [Spring AOP 官方文档](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#aop)

## 练习

1. 尝试创建一个自定义事务注解，并设置不同的超时时间和回滚异常类型。
2. 在一个分布式系统中，使用自定义事务注解管理多个服务的调用，确保事务的一致性。
