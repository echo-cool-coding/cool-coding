---
title: Seata TM事务传播
description: 了解Seata事务管理器（TM）中的事务传播机制，掌握如何在分布式事务中正确传播事务上下文。
---

# Seata TM事务传播

在分布式系统中，事务管理是一个复杂但至关重要的任务。Seata（Simple Extensible Autonomous Transaction Architecture）是一个开源的分布式事务解决方案，它通过事务管理器（Transaction Manager, TM）来协调和管理分布式事务。本文将深入探讨Seata TM中的事务传播机制，帮助初学者理解其工作原理和应用场景。

## 什么是事务传播？

事务传播（Transaction Propagation）是指在多个事务方法调用之间，事务上下文如何传递和管理的机制。在分布式系统中，事务传播尤为重要，因为它决定了事务的边界和一致性。

在Seata中，事务传播主要通过TM来实现。TM负责协调全局事务的开始、提交和回滚，并确保事务上下文在分布式系统中的正确传播。

## Seata TM事务传播机制

### 1. 事务上下文

在Seata中，事务上下文（Transaction Context）是事务传播的核心。它包含了事务的全局唯一标识（XID）以及其他事务相关的信息。事务上下文通过RPC调用在服务之间传递，确保所有参与的服务都能识别并参与到同一个全局事务中。

### 2. 事务传播模式

Seata支持多种事务传播模式，常见的有：

- **REQUIRED**：如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新事务。
- **REQUIRES_NEW**：无论当前是否存在事务，都创建一个新事务。
- **SUPPORTS**：如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务方式执行。
- **NOT_SUPPORTED**：以非事务方式执行操作，如果当前存在事务，则挂起该事务。
- **MANDATORY**：如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。
- **NEVER**：以非事务方式执行操作，如果当前存在事务，则抛出异常。

### 3. 事务传播的实现

在Seata中，事务传播的实现依赖于TM和RM（Resource Manager）的协作。以下是一个简单的代码示例，展示了如何在Seata中使用事务传播：

```java
@GlobalTransactional
public void businessMethod() {
    // 调用服务A
    serviceA.methodA();
    // 调用服务B
    serviceB.methodB();
}

@Service
public class ServiceA {
    @Transactional(propagation = Propagation.REQUIRED)
    public void methodA() {
        // 业务逻辑
    }
}

@Service
public class ServiceB {
    @Transactional(propagation = Propagation.REQUIRES_NEW)
    public void methodB() {
        // 业务逻辑
    }
}
```

在这个示例中，`businessMethod`方法启动了一个全局事务，并在其中调用了`serviceA.methodA`和`serviceB.methodB`。`methodA`使用`REQUIRED`传播模式，因此它会加入到全局事务中；而`methodB`使用`REQUIRES_NEW`传播模式，因此它会创建一个新的事务。

### 4. 事务传播的实际应用场景

假设我们有一个电商系统，用户下单时需要同时扣减库存和创建订单。这两个操作分别由库存服务和订单服务处理。为了确保数据一致性，我们需要将这两个操作放在同一个事务中。

```java
@GlobalTransactional
public void placeOrder(Order order) {
    // 扣减库存
    inventoryService.deductStock(order.getProductId(), order.getQuantity());
    // 创建订单
    orderService.createOrder(order);
}

@Service
public class InventoryService {
    @Transactional(propagation = Propagation.REQUIRED)
    public void deductStock(String productId, int quantity) {
        // 扣减库存逻辑
    }
}

@Service
public class OrderService {
    @Transactional(propagation = Propagation.REQUIRED)
    public void createOrder(Order order) {
        // 创建订单逻辑
    }
}
```

在这个场景中，`placeOrder`方法启动了一个全局事务，并在其中调用了`inventoryService.deductStock`和`orderService.createOrder`。由于这两个方法都使用`REQUIRED`传播模式，因此它们都会加入到同一个全局事务中，确保数据的一致性。

## 总结

Seata TM的事务传播机制是分布式事务管理的关键。通过理解事务传播模式及其实现方式，开发者可以更好地设计和实现分布式系统中的事务管理逻辑。本文介绍了Seata TM中的事务传播机制，并通过代码示例和实际应用场景展示了其使用方法。

## 附加资源与练习

- **练习**：尝试在一个分布式系统中实现一个简单的业务逻辑，并使用Seata TM的事务传播机制来管理事务。
- **资源**：阅读Seata官方文档，了解更多关于事务传播和分布式事务管理的详细信息。

:::tip
提示：在实际开发中，合理选择事务传播模式可以显著提高系统的性能和一致性。
:::