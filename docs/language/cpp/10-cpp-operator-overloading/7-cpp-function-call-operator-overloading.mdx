---
title: C++ 函数调用运算符重载
description: 学习如何在C++中重载函数调用运算符，实现仿函数并理解其在现代C++中的重要应用
---

# C++ 函数调用运算符重载

## 概念介绍

在C++中，函数调用运算符 `()` 是一个可以被重载的运算符。当我们为一个类重载函数调用运算符时，该类的对象就可以像函数一样被调用。这种对象被称为**函数对象**或**仿函数**（Functor）。

函数调用运算符重载是C++中一个强大而灵活的特性，它为我们提供了创建可调用对象的能力，这些对象可以保存状态并以函数的形式被调用。

:::note 基本语法
```cpp
class ClassName {
public:
    return_type operator()(parameters) {
        // 函数体
    }
};
```
:::

## 基础示例

让我们从一个简单的例子开始，创建一个可以计算整数平方的函数对象：

```cpp
#include <iostream>

class Square {
public:
    int operator()(int x) {
        return x * x;
    }
};

int main() {
    Square square; // 创建函数对象
    
    // 使用函数对象
    std::cout << "5的平方是: " << square(5) << std::endl;
    std::cout << "7的平方是: " << square(7) << std::endl;
    
    return 0;
}
```

**输出：**
```
5的平方是: 25
7的平方是: 49
```

在这个例子中：
1. 我们定义了一个名为`Square`的类
2. 在类中重载了函数调用运算符`operator()(int x)`
3. 创建了类的对象`square`
4. 使用`square(5)`和`square(7)`像调用函数一样调用了这个对象

## 带有状态的函数对象

函数对象的一个重要优势是可以保存状态，这是普通函数所不具备的特性。下面是一个计数器的例子：

```cpp
#include <iostream>

class Counter {
private:
    int count;
    
public:
    Counter() : count(0) {}
    
    int operator()() {
        return ++count;  // 每次调用时增加计数
    }
    
    void reset() {
        count = 0;
    }
};

int main() {
    Counter counter;
    
    std::cout << "第一次调用: " << counter() << std::endl;
    std::cout << "第二次调用: " << counter() << std::endl;
    std::cout << "第三次调用: " << counter() << std::endl;
    
    counter.reset();
    std::cout << "重置后调用: " << counter() << std::endl;
    
    return 0;
}
```

**输出：**
```
第一次调用: 1
第二次调用: 2
第三次调用: 3
重置后调用: 1
```

这个例子展示了函数对象可以在调用之间保存状态（这里是`count`值），这使它们在某些情况下比普通函数更加灵活。

## 带参数的函数对象

函数对象可以接受任意数量的参数，就像普通函数一样：

```cpp
#include <iostream>
#include <string>

class Concatenator {
private:
    std::string separator;
    
public:
    Concatenator(const std::string& sep) : separator(sep) {}
    
    std::string operator()(const std::string& a, const std::string& b) const {
        return a + separator + b;
    }
};

int main() {
    Concatenator spaceCat(" ");
    Concatenator commaCat(", ");
    Concatenator hyphenCat("-");
    
    std::cout << spaceCat("Hello", "World") << std::endl;
    std::cout << commaCat("Hello", "World") << std::endl;
    std::cout << hyphenCat("Hello", "World") << std::endl;
    
    return 0;
}
```

**输出：**
```
Hello World
Hello, World
Hello-World
```

在这个例子中，我们创建了一个函数对象，它可以使用特定的分隔符连接两个字符串。不同的函数对象实例可以使用不同的分隔符。

## 函数对象的实际应用

### 1. 在STL算法中使用函数对象

函数对象在标准模板库(STL)中被广泛使用，特别是在算法如`sort`、`find_if`、`transform`等中作为谓词(predicate)：

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

// 自定义比较函数对象
class GreaterThan {
private:
    int value;
    
public:
    GreaterThan(int val) : value(val) {}
    
    bool operator()(int x) const {
        return x > value;
    }
};

int main() {
    std::vector<int> numbers = {1, 5, 7, 10, 2, 8, 3, 9};
    
    // 找到第一个大于5的数
    auto it = std::find_if(numbers.begin(), numbers.end(), GreaterThan(5));
    
    if (it != numbers.end()) {
        std::cout << "第一个大于5的数是: " << *it << std::endl;
    } else {
        std::cout << "没有找到大于5的数" << std::endl;
    }
    
    // 计算大于3的数的个数
    int count = std::count_if(numbers.begin(), numbers.end(), GreaterThan(3));
    std::cout << "大于3的数的个数: " << count << std::endl;
    
    return 0;
}
```

**输出：**
```
第一个大于5的数是: 7
大于3的数的个数: 5
```

### 2. 使用Lambda作为函数对象的简便替代

在现代C++中，lambda表达式可以看作是创建临时函数对象的一种简便方法：

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> numbers = {1, 5, 7, 10, 2, 8, 3, 9};
    
    // 使用lambda表达式查找大于5的元素
    auto it = std::find_if(numbers.begin(), numbers.end(), 
                          [](int x) { return x > 5; });
    
    if (it != numbers.end()) {
        std::cout << "第一个大于5的数是: " << *it << std::endl;
    }
    
    // 使用带捕获的lambda
    int threshold = 3;
    int count = std::count_if(numbers.begin(), numbers.end(), 
                            [threshold](int x) { return x > threshold; });
    
    std::cout << "大于" << threshold << "的数的个数: " << count << std::endl;
    
    return 0;
}
```

**输出：**
```
第一个大于5的数是: 7
大于3的数的个数: 5
```

:::tip 小知识
Lambda表达式实际上是编译器生成的匿名函数对象。当你使用Lambda表达式时，编译器会创建一个匿名类，其中包含一个重载的函数调用运算符，实现你在Lambda中定义的功能。
:::

## 多个函数调用运算符重载

一个类可以有多个不同版本的函数调用运算符重载，这些重载可以具有不同的参数类型和数量：

```cpp
#include <iostream>
#include <string>

class MultiFunction {
public:
    // 无参数版本
    void operator()() const {
        std::cout << "无参数调用" << std::endl;
    }
    
    // 一个整型参数版本
    int operator()(int x) const {
        return x * 2;
    }
    
    // 两个字符串参数版本
    std::string operator()(const std::string& a, const std::string& b) const {
        return a + b;
    }
};

int main() {
    MultiFunction func;
    
    func();  // 调用无参数版本
    std::cout << "整数参数: " << func(5) << std::endl;
    std::cout << "字符串参数: " << func("Hello, ", "C++!") << std::endl;
    
    return 0;
}
```

**输出：**
```
无参数调用
整数参数: 10
字符串参数: Hello, C++!
```

## 高级应用：实现简单的计算器

下面是一个更复杂的例子，使用函数对象实现一个简单的计算器：

```cpp
#include <iostream>
#include <functional>
#include <map>
#include <string>

// 基础计算器函数对象
class Calculator {
private:
    std::map<std::string, std::function<double(double, double)>> operations;
    
public:
    Calculator() {
        // 注册基本操作
        operations["+"] = [](double a, double b) { return a + b; };
        operations["-"] = [](double a, double b) { return a - b; };
        operations["*"] = [](double a, double b) { return a * b; };
        operations["/"] = [](double a, double b) { 
            if (b == 0) throw std::runtime_error("除数不能为零");
            return a / b; 
        };
    }
    
    // 函数调用运算符重载
    double operator()(double a, const std::string& op, double b) {
        auto it = operations.find(op);
        if (it == operations.end()) {
            throw std::invalid_argument("不支持的操作: " + op);
        }
        return it->second(a, b);
    }
    
    // 添加新操作
    void addOperation(const std::string& op, 
                     std::function<double(double, double)> func) {
        operations[op] = func;
    }
};

int main() {
    Calculator calc;
    
    try {
        std::cout << "2 + 3 = " << calc(2, "+", 3) << std::endl;
        std::cout << "5 - 2 = " << calc(5, "-", 2) << std::endl;
        std::cout << "4 * 6 = " << calc(4, "*", 6) << std::endl;
        std::cout << "8 / 2 = " << calc(8, "/", 2) << std::endl;
        
        // 添加新操作 - 幂运算
        calc.addOperation("^", [](double a, double b) {
            return std::pow(a, b);
        });
        
        std::cout << "2 ^ 3 = " << calc(2, "^", 3) << std::endl;
        
        // 测试错误处理
        std::cout << "8 / 0 = " << calc(8, "/", 0) << std::endl;
    }
    catch (const std::exception& e) {
        std::cout << "错误: " << e.what() << std::endl;
    }
    
    return 0;
}
```

**输出：**
```
2 + 3 = 5
5 - 2 = 3
4 * 6 = 24
8 / 2 = 4
2 ^ 3 = 8
错误: 除数不能为零
```

这个例子展示了函数对象的高级用法，结合了函数对象、标准库中的`std::function`和lambda表达式，创建了一个可扩展的计算器系统。

## 总结

函数调用运算符重载是C++中的强大特性，它允许我们创建可以像函数一样使用的对象。这些函数对象比普通函数更加灵活，因为它们可以:

1. 保持状态
2. 在编译时通过模板进行优化
3. 具有自己的特定类型
4. 存储额外数据成员
5. 通过继承和组合实现更复杂的行为

在现代C++中，函数对象与STL算法、函数式编程技术（如`std::function`和lambda表达式）结合使用，可以创建简洁、高效的代码。

## 练习

为了巩固所学知识，尝试完成以下练习：

1. 创建一个函数对象，计算给定数字的阶乘。
2. 实现一个输出格式化器函数对象，它可以在指定宽度内打印数字，并可以选择左对齐或右对齐。
3. 编写一个函数对象，可以检查字符串是否包含指定的子串，不区分大小写。
4. 创建一个函数对象，它可以保存一系列值并计算这些值的平均数。
5. 使用函数对象实现一个简单的文本过滤器，可以移除特定的单词或字符。

:::caution 注意事项
重载函数调用运算符时，要确保函数参数列表与返回类型设计合理，以便使用方便。另外，如果函数对象需要被传递给STL算法，还需要考虑它的复制和移动语义。
:::