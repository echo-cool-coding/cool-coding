---
title: C++ 引用包装器
description: 了解C++中的引用包装器std::ref和std::cref，学习如何在函数对象和STL算法中正确使用引用传递
---

# C++ 引用包装器

## 什么是引用包装器？

在C++中，引用包装器是一种特殊的工具，它允许我们创建一个对象，该对象的行为类似于对另一个对象的引用。C++标准库提供了两个主要的引用包装器：`std::ref` 和 `std::cref`，它们分别位于 `<functional>` 头文件中。

- `std::ref` 创建一个普通引用的包装器
- `std::cref` 创建一个const引用的包装器

这些包装器的主要用途是在那些通常按值复制参数的场景下，强制使用引用语义。

## 为什么需要引用包装器？

在C++中，许多模板函数和类默认通过值传递和存储参数。例如，`std::bind`、`std::thread` 构造函数或某些STL算法。当你想要这些函数使用引用而不是复制时，就需要用到引用包装器。

:::note
没有引用包装器，某些场景下无法直接传递引用，会导致值的复制，从而丢失修改原对象的能力。
:::

## 基本用法

### 头文件

使用引用包装器前，需要包含相应的头文件：

```cpp
#include <functional>  // 包含std::ref和std::cref
```

### 创建引用包装器

让我们来看一个简单的例子：

```cpp
#include <iostream>
#include <functional>

void increment(int& value) {
    value++;
}

int main() {
    int number = 10;
    
    // 使用引用包装器
    increment(std::ref(number));
    
    std::cout << "After increment: " << number << std::endl;
    
    return 0;
}
```

**输出：**
```
After increment: 11
```

在这个例子中，即使函数需要引用参数，我们仍然使用了 `std::ref` 来明确表示我们想要传递引用。

## std::ref 和 std::cref 的区别

- `std::ref` 创建可修改的引用包装器
- `std::cref` 创建const（常量）引用包装器，不允许通过它修改被引用的对象

```cpp
#include <iostream>
#include <functional>

void display(const int& value) {
    std::cout << "Value: " << value << std::endl;
}

void modify(int& value) {
    value *= 2;
}

int main() {
    int number = 10;
    
    // 使用const引用包装器
    display(std::cref(number));
    
    // 使用普通引用包装器
    modify(std::ref(number));
    
    std::cout << "After modification: " << number << std::endl;
    
    // 以下代码会导致编译错误，因为cref创建的是常量引用
    // modify(std::cref(number));
    
    return 0;
}
```

**输出：**
```
Value: 10
After modification: 20
```

## 引用包装器在STL算法中的应用

引用包装器在与STL算法一起使用时特别有用：

```cpp
#include <iostream>
#include <functional>
#include <algorithm>
#include <vector>

class Counter {
private:
    int count = 0;
public:
    void increment() { count++; }
    int getCount() const { return count; }
};

int main() {
    std::vector<int> numbers = {1, 2, 3, 4, 5};
    Counter counter;
    
    // 错误用法：counter会被复制，原counter不会改变
    // std::for_each(numbers.begin(), numbers.end(), 
    //     [counter](int) mutable { counter.increment(); });
    
    // 正确用法：使用引用包装器，确保使用原始counter对象
    std::for_each(numbers.begin(), numbers.end(), 
        [&counter](int) { counter.increment(); });
    
    std::cout << "Count without ref: " << counter.getCount() << std::endl;
    
    // 重置counter
    counter = Counter();
    
    // 也可以使用std::ref
    std::for_each(numbers.begin(), numbers.end(), 
        [counter = std::ref(counter)](int) { counter.get().increment(); });
    
    std::cout << "Count with ref: " << counter.getCount() << std::endl;
    
    return 0;
}
```

**输出：**
```
Count without ref: 5
Count with ref: 5
```

## 引用包装器与std::bind

`std::bind` 是引用包装器最常见的应用场景之一：

```cpp
#include <iostream>
#include <functional>

void process(int& x, int y) {
    x += y;
    std::cout << "x = " << x << ", y = " << y << std::endl;
}

int main() {
    int a = 10, b = 5;
    
    // 使用std::bind但不使用引用包装器 - a的副本会被绑定
    auto bound1 = std::bind(process, a, b);
    bound1();  // 这不会修改原始的a
    std::cout << "After bound1, a = " << a << std::endl;
    
    // 使用std::bind并使用引用包装器 - 引用原始的a
    auto bound2 = std::bind(process, std::ref(a), b);
    bound2();  // 这会修改原始的a
    std::cout << "After bound2, a = " << a << std::endl;
    
    return 0;
}
```

**输出：**
```
x = 15, y = 5
After bound1, a = 10
x = 15, y = 5
After bound2, a = 15
```

## 引用包装器与std::thread

在多线程编程中，`std::thread` 构造函数默认会复制传递给它的所有参数。如果你希望线程函数能够修改某个变量，就需要使用引用包装器：

```cpp
#include <iostream>
#include <functional>
#include <thread>

void worker(int& counter) {
    for (int i = 0; i < 1000; ++i) {
        counter++;
    }
}

int main() {
    int counter = 0;
    
    // 错误用法：会复制counter
    // std::thread t1(worker, counter);
    
    // 正确用法：使用引用包装器
    std::thread t1(worker, std::ref(counter));
    t1.join();
    
    std::cout << "Counter value: " << counter << std::endl;
    
    return 0;
}
```

**输出：**
```
Counter value: 1000
```

:::caution
使用引用包装器与线程时要特别小心，确保被引用的对象在线程执行期间保持有效！
:::

## 引用包装器的内部实现

引用包装器的基本原理是什么？实际上，`std::ref` 和 `std::cref` 返回一个 `std::reference_wrapper<T>` 类型的对象，该类型的主要特点有：

1. 它存储一个指向原始对象的指针
2. 它提供了隐式转换为引用类型的能力
3. 它是可复制的，但复制的是指针而非目标对象

下面是一个简化的 `reference_wrapper` 实现示意：

```cpp
template <class T>
class reference_wrapper {
private:
    T* ptr;  // 指向目标对象的指针
    
public:
    // 构造函数
    reference_wrapper(T& ref) noexcept : ptr(&ref) {}
    
    // 隐式转换为引用类型
    operator T&() const noexcept { return *ptr; }
    
    // 显式获取引用
    T& get() const noexcept { return *ptr; }
    
    // ... 其他成员函数
};

// 辅助函数
template <class T>
reference_wrapper<T> ref(T& t) noexcept {
    return reference_wrapper<T>(t);
}

template <class T>
reference_wrapper<const T> cref(const T& t) noexcept {
    return reference_wrapper<const T>(t);
}
```

## 实际应用案例

### 案例1：函数对象与状态共享

```cpp
#include <iostream>
#include <functional>
#include <vector>
#include <algorithm>

class DataProcessor {
private:
    int processedCount = 0;
    
public:
    void process(int& value) {
        value *= 2;
        processedCount++;
    }
    
    int getProcessedCount() const {
        return processedCount;
    }
};

int main() {
    std::vector<int> data = {1, 2, 3, 4, 5};
    DataProcessor processor;
    
    std::cout << "Original data: ";
    for (int val : data) std::cout << val << " ";
    std::cout << std::endl;
    
    // 使用std::ref确保我们使用的是同一个processor实例
    std::for_each(data.begin(), data.end(), 
                 [&processor](int& val) { processor.process(val); });
    
    std::cout << "Processed data: ";
    for (int val : data) std::cout << val << " ";
    std::cout << std::endl;
    
    std::cout << "Items processed: " << processor.getProcessedCount() << std::endl;
    
    return 0;
}
```

**输出：**
```
Original data: 1 2 3 4 5
Processed data: 2 4 6 8 10
Items processed: 5
```

### 案例2：回调函数与状态保持

```cpp
#include <iostream>
#include <functional>
#include <vector>

class EventManager {
private:
    std::vector<std::function<void()>> callbacks;
    
public:
    void registerCallback(std::function<void()> callback) {
        callbacks.push_back(callback);
    }
    
    void triggerEvents() {
        for (auto& callback : callbacks) {
            callback();
        }
    }
};

int main() {
    EventManager manager;
    int counter = 0;
    
    // 使用引用包装器确保lambda捕获引用而非拷贝
    manager.registerCallback([&counter]() { 
        counter++; 
        std::cout << "Event triggered, counter: " << counter << std::endl; 
    });
    
    // 另一种方法：明确使用std::ref
    int anotherCounter = 10;
    auto callback = [counter = std::ref(anotherCounter)]() {
        counter.get() += 5;
        std::cout << "Another event triggered, counter: " << counter.get() << std::endl;
    };
    
    manager.registerCallback(callback);
    
    // 触发事件
    manager.triggerEvents();
    manager.triggerEvents();
    
    std::cout << "Final counter values: " << counter << ", " << anotherCounter << std::endl;
    
    return 0;
}
```

**输出：**
```
Event triggered, counter: 1
Another event triggered, counter: 15
Event triggered, counter: 2
Another event triggered, counter: 20
Final counter values: 2, 20
```

## 引用包装器的局限性

虽然引用包装器非常有用，但也有一些局限性需要了解：

1. **生命周期管理**：引用包装器不会延长被引用对象的生命周期，必须确保被引用对象在使用引用时仍然有效

2. **线程安全性**：当在多线程环境中使用引用包装器时，需要注意并发访问的安全问题

3. **不适用于临时对象**：不能对临时对象使用引用包装器

```cpp
// 错误：对临时对象使用引用包装器
std::string getName() { return "temp"; }
auto ref = std::ref(getName());  // 危险！引用临时对象
```

## 总结

引用包装器是C++中解决特定问题的专用工具，它们主要用于：

- 将引用语义引入通常按值复制的场景
- 在STL算法、`std::bind`、`std::function` 和 `std::thread` 中使用引用
- 确保在函数对象中可以修改被引用的变量

使用引用包装器时，应记住以下关键点：

- 使用 `std::ref` 获取普通引用，使用 `std::cref` 获取常量引用
- 确保被引用对象的生命周期在引用包装器使用期间保持有效
- 注意线程安全性问题，尤其是在多线程环境中

## 练习

1. 编写一个程序，使用 `std::bind` 和引用包装器绑定一个成员函数，确保该函数可以修改类的内部状态。

2. 创建一个多线程程序，其中多个线程共享一个计数器，使用引用包装器确保所有线程使用同一个计数器对象。

3. 实现一个简单的观察者模式，使用引用包装器存储对观察者对象的引用，确保通知时修改的是原始观察者对象。

## 进一步学习资源

- C++标准库文档中关于 [`std::reference_wrapper`](https://en.cppreference.com/w/cpp/utility/functional/reference_wrapper) 的部分
- C++标准库文档中关于 [`std::ref` 和 `std::cref`](https://en.cppreference.com/w/cpp/utility/functional/ref) 的部分
- 《Effective Modern C++》by Scott Meyers，其中有关于引用包装器的更深入讨论

通过掌握引用包装器，你将能够更灵活地处理C++中的引用和值语义，尤其是在使用STL和现代C++特性时。