---
title: C++ 自定义操纵算子
description: 学习如何在C++中创建和使用自定义的流操纵算子，以增强文件和流的输入输出操作。
---

# C++ 自定义操纵算子

在C++的输入输出流操作中，操纵算子（manipulators）是改变流状态或格式化输出的有力工具。除了标准库提供的操纵算子（如`endl`、`setw`、`setprecision`等），我们还可以创建自定义的操纵算子来满足特定需求。

## 什么是操纵算子？

操纵算子是可以通过流插入（`<<`）或提取（`>>`）操作符作用于流对象的函数或函数对象。它们能够改变流的状态、格式化输出或执行其他特定操作。

:::note
标准库中常见的操纵算子包括：
- `endl`：插入换行符并刷新流
- `setw(n)`：设置下一个输出字段的宽度
- `fixed`：设置浮点数使用固定点表示法
:::

## 为什么需要自定义操纵算子？

自定义操纵算子可以帮助我们：

1. 增强代码可读性
2. 简化重复的格式化操作
3. 封装复杂的流操作逻辑
4. 创建特殊的输出格式

## 自定义操纵算子的类型

在C++中，自定义操纵算子主要分为两类：

1. **无参数操纵算子**：不接受任何参数的操纵算子
2. **带参数操纵算子**：接受一个或多个参数的操纵算子

接下来我们将详细介绍如何创建这两种类型的操纵算子。

## 无参数操纵算子

无参数操纵算子是最简单的形式，它是一个接受并返回流引用的函数。

### 语法格式

```cpp
std::ostream& manipulator(std::ostream& os) {
    // 改变流状态或执行某些操作
    return os;
}
```

### 示例：创建一个换行并添加制表符的操纵算子

```cpp
#include <iostream>

// 定义一个名为 endtab 的操纵算子
std::ostream& endtab(std::ostream& os) {
    return os << '\n' << '\t';
}

int main() {
    std::cout << "第一行" << endtab << "第二行（已缩进）";
    return 0;
}
```

**输出结果：**

```
第一行
	第二行（已缩进）
```

### 无参数操纵算子的使用场景

无参数操纵算子特别适用于：

- 简单的格式设置（如添加特定前缀或后缀）
- 修改流的特定标志
- 执行不需要外部参数的常规操作

## 带参数操纵算子

带参数操纵算子稍微复杂一些，因为C++流操作符不直接支持向操纵算子传递参数。实现带参数操纵算子需要借助函数对象或闭包。

### 实现方法1：使用函数返回函数对象

```cpp
#include <iostream>
#include <iomanip>

// 定义操纵算子函数类
class RepeatChar {
private:
    char ch;
    int count;
public:
    RepeatChar(char c, int n) : ch(c), count(n) {}
    
    friend std::ostream& operator<<(std::ostream& os, const RepeatChar& rc) {
        for (int i = 0; i < rc.count; ++i) {
            os << rc.ch;
        }
        return os;
    }
};

// 操纵算子生成函数
inline RepeatChar repeat(char c, int n) {
    return RepeatChar(c, n);
}

int main() {
    std::cout << "开始" << repeat('-', 20) << "结束" << std::endl;
    return 0;
}
```

**输出结果：**

```
开始--------------------结束
```

### 实现方法2：使用函数对象配合函数模板

```cpp
#include <iostream>
#include <iomanip>

// 定义一个带颜色的输出操纵算子
class ColorText {
private:
    const char* text;
    int color_code;
public:
    ColorText(const char* t, int c) : text(t), color_code(c) {}
    
    friend std::ostream& operator<<(std::ostream& os, const ColorText& ct) {
        os << "\033[" << ct.color_code << "m" << ct.text << "\033[0m";
        return os;
    }
};

// 操纵算子生成函数
inline ColorText color_text(const char* text, int color_code) {
    return ColorText(text, color_code);
}

int main() {
    // 红色文本(31), 绿色文本(32), 蓝色文本(34)
    std::cout << color_text("错误", 31) << " - " 
              << color_text("成功", 32) << " - " 
              << color_text("信息", 34) << std::endl;
    return 0;
}
```

:::caution
上面的彩色文本示例在支持ANSI转义序列的终端中才能正确显示颜色。
:::

## 高级应用：流状态操纵算子

我们可以创建更复杂的操纵算子来修改流的内部状态。

### 示例：创建一个临时设置精度的操纵算子

```cpp
#include <iostream>
#include <iomanip>

class TempPrecision {
private:
    int precision;
    std::ios_base::fmtflags flags;
public:
    TempPrecision(int p) : precision(p) {}
    
    friend std::ostream& operator<<(std::ostream& os, const TempPrecision& tp) {
        // 保存当前状态
        std::streamsize old_precision = os.precision();
        std::ios_base::fmtflags old_flags = os.flags();
        
        // 设置新状态
        os.precision(tp.precision);
        os.setf(std::ios::fixed, std::ios::floatfield);
        
        // 注册一个回调，在下一次输出后恢复状态
        os.copyfmt(std::ios(NULL));
        os.flags(old_flags);
        os.precision(old_precision);
        
        return os;
    }
};

// 操纵算子生成函数
inline TempPrecision temp_precision(int p) {
    return TempPrecision(p);
}

int main() {
    double value = 3.14159265358979;
    
    std::cout << "默认精度: " << value << std::endl;
    std::cout << "临时精度2: " << temp_precision(2) << value << std::endl;
    std::cout << "默认精度: " << value << std::endl;
    
    return 0;
}
```

**输出结果：**

```
默认精度: 3.14159
临时精度2: 3.14
默认精度: 3.14159
```

## 实际应用案例

### 案例1：格式化日志输出

创建一组操纵算子用于标准化日志输出格式：

```cpp
#include <iostream>
#include <iomanip>
#include <ctime>
#include <string>

// 日期时间操纵算子
std::ostream& timestamp(std::ostream& os) {
    time_t now = time(0);
    tm* ltm = localtime(&now);
    char buffer[80];
    strftime(buffer, 80, "%Y-%m-%d %H:%M:%S", ltm);
    return os << "[" << buffer << "] ";
}

// 日志级别操纵算子
class LogLevel {
private:
    std::string level;
public:
    LogLevel(const std::string& lvl) : level(lvl) {}
    
    friend std::ostream& operator<<(std::ostream& os, const LogLevel& ll) {
        return os << "[" << ll.level << "] ";
    }
};

inline LogLevel log_level(const std::string& level) {
    return LogLevel(level);
}

// 示例用法
int main() {
    std::cout << timestamp << log_level("INFO") << "应用程序已启动" << std::endl;
    std::cout << timestamp << log_level("WARNING") << "磁盘空间不足" << std::endl;
    std::cout << timestamp << log_level("ERROR") << "无法连接到数据库" << std::endl;
    
    return 0;
}
```

**输出结果：**

```
[2023-06-15 14:30:25] [INFO] 应用程序已启动
[2023-06-15 14:30:25] [WARNING] 磁盘空间不足
[2023-06-15 14:30:25] [ERROR] 无法连接到数据库
```

### 案例2：表格格式化输出

创建用于表格格式化的操纵算子：

```cpp
#include <iostream>
#include <iomanip>
#include <vector>
#include <string>

// 表格行开始操纵算子
std::ostream& row_start(std::ostream& os) {
    return os << "| ";
}

// 表格行结束操纵算子
std::ostream& row_end(std::ostream& os) {
    return os << " |" << std::endl;
}

// 表格单元格操纵算子
class Cell {
private:
    std::string text;
    int width;
public:
    Cell(const std::string& t, int w) : text(t), width(w) {}
    
    friend std::ostream& operator<<(std::ostream& os, const Cell& c) {
        os << std::setw(c.width) << std::left << c.text << " | ";
        return os;
    }
};

inline Cell cell(const std::string& text, int width) {
    return Cell(text, width);
}

// 水平分隔线操纵算子
class HLine {
private:
    std::vector<int> widths;
public:
    HLine(const std::vector<int>& w) : widths(w) {}
    
    friend std::ostream& operator<<(std::ostream& os, const HLine& hl) {
        os << "+";
        for (int width : hl.widths) {
            os << std::string(width + 2, '-') << "+";
        }
        os << std::endl;
        return os;
    }
};

inline HLine hline(const std::vector<int>& widths) {
    return HLine(widths);
}

int main() {
    std::vector<int> col_widths = {10, 15, 10};
    
    std::cout << hline(col_widths)
              << row_start << cell("姓名", 10) << cell("邮箱", 15) << cell("电话", 10) << row_end
              << hline(col_widths)
              << row_start << cell("张三", 10) << cell("zhang@example.com", 15) << cell("1234567890", 10) << row_end
              << row_start << cell("李四", 10) << cell("li@example.com", 15) << cell("0987654321", 10) << row_end
              << hline(col_widths);
    
    return 0;
}
```

**输出结果：**

```
+------------+----------------+------------+
| 姓名        | 邮箱           | 电话        |
+------------+----------------+------------+
| 张三        | zhang@example.com | 1234567890 |
| 李四        | li@example.com | 0987654321 |
+------------+----------------+------------+
```

## 总结

自定义操纵算子是C++流操作中的强大工具，它可以帮助我们：

1. **简化代码**：将复杂的格式化逻辑封装为简单的操纵算子
2. **提高可读性**：通过语义化的操纵算子名称增强代码可读性
3. **增强扩展性**：为流操作添加自定义的功能
4. **封装重用**：封装常用的流操作，使其可在不同项目中重用

创建和使用自定义操纵算子需要掌握：

- 无参数操纵算子的简单函数实现
- 带参数操纵算子的函数对象实现
- 流状态的保存和恢复技术

通过这些技巧，你可以根据项目需求创建出灵活、直观和功能强大的自定义操纵算子。

## 练习题

1. 创建一个名为 `box` 的操纵算子，用于在文本周围添加方框。
2. 实现一个 `center` 操纵算子，可以接受宽度参数并使文本在该宽度内居中显示。
3. 设计一组操纵算子，用于从文件读取 CSV 格式数据并以表格形式显示。
4. 创建一个 `progress_bar` 操纵算子，可以显示一个基于百分比的进度条。

## 进一步学习资源

- C++标准库中 `<iomanip>` 头文件的文档
- C++流类的各种标志和格式化选项
- 函数对象和闭包的高级用法
- 流状态管理和恢复技术

通过掌握自定义操纵算子，你将能够编写出更简洁、更具表现力的 C++ 代码，特别是在处理复杂的文件和流操作时。