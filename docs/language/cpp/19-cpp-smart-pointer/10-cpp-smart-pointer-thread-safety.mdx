---
title: C++ 智能指针线程安全
description: 本文详细介绍了C++智能指针在多线程环境下的线程安全性问题，包括shared_ptr、unique_ptr和weak_ptr的使用注意事项和最佳实践。
---

# C++ 智能指针线程安全

## 引言

在现代C++编程中，智能指针是内存管理的重要工具，可以有效避免内存泄漏和悬挂指针等问题。然而，当我们在多线程环境中使用智能指针时，需要特别注意线程安全性问题。本文将详细探讨C++智能指针（`std::shared_ptr`、`std::unique_ptr`和`std::weak_ptr`）在多线程环境下的行为和安全使用方法。

## 智能指针与线程安全基础

在讨论智能指针的线程安全性之前，我们先回顾一下C++标准中的三种主要智能指针：

1. **std::unique_ptr**：独占所有权的智能指针
2. **std::shared_ptr**：共享所有权的智能指针
3. **std::weak_ptr**：不影响对象生命周期的观察者指针

线程安全性主要关注以下几个方面：
- 引用计数的修改是否是原子操作
- 对指针自身的读写是否线程安全
- 指针所指向的对象访问是否线程安全

## std::shared_ptr的线程安全性

`std::shared_ptr`包含两个部分：
- 指向对象的指针
- 指向控制块的指针（包含引用计数）

### shared_ptr的线程安全保证

:::info
**C++标准保证**：对于同一个`shared_ptr`对象的多线程读取是安全的。对于不同`shared_ptr`对象的并发读写，如果它们是对同一个原始`shared_ptr`的拷贝，对引用计数的修改是线程安全的。
:::

也就是说，`std::shared_ptr`提供的线程安全保证仅限于其引用计数的操作：

```cpp
// 线程安全的操作
std::shared_ptr<int> sp1 = std::make_shared<int>(42);

// 线程A
std::shared_ptr<int> spA = sp1; // 引用计数+1，是线程安全的

// 线程B
std::shared_ptr<int> spB = sp1; // 引用计数+1，是线程安全的

// 线程C
sp1.reset(); // 引用计数-1，是线程安全的
```

### shared_ptr的线程不安全情况

然而，以下操作是不安全的：

```cpp
// 多线程对同一个shared_ptr对象的并发写入
std::shared_ptr<int> sp = std::make_shared<int>(42);

// 线程A
sp = std::make_shared<int>(100); // 不安全！

// 同时在线程B
sp.reset(); // 不安全！
```

:::warning
对于同一个`shared_ptr`对象的并发读写是不安全的，需要额外的同步机制来保护，如互斥锁或原子操作。
:::

### shared_ptr指向对象的线程安全性

需要特别注意，`shared_ptr`并不能保证其指向的对象的线程安全：

```cpp
std::shared_ptr<int> sp = std::make_shared<int>(0);

// 线程A
(*sp)++; // 修改指向的对象

// 同时在线程B
(*sp)++; // 数据竞争！
```

这种情况下，我们需要使用互斥锁来保护对象的访问：

```cpp
std::shared_ptr<int> sp = std::make_shared<int>(0);
std::mutex mutex;

// 线程A
{
    std::lock_guard<std::mutex> lock(mutex);
    (*sp)++;
}

// 线程B
{
    std::lock_guard<std::mutex> lock(mutex);
    (*sp)++;
}
```

## std::unique_ptr的线程安全性

`std::unique_ptr`的设计初衷是独占所有权，所以通常不应该在多线程间共享。

:::caution
C++标准不保证`unique_ptr`在多线程环境下的安全性。由于其独占特性，它不应该被多个线程同时访问。
:::

然而，我们可以安全地将`unique_ptr`从一个线程转移到另一个线程：

```cpp
std::unique_ptr<int> up = std::make_unique<int>(42);
std::mutex mutex;

// 在线程A中转移所有权
std::unique_ptr<int> transferOwnership() {
    std::lock_guard<std::mutex> lock(mutex);
    return std::move(up);  // 安全地转移所有权
}

// 在线程B中接收所有权
void receiveOwnership() {
    std::lock_guard<std::mutex> lock(mutex);
    std::unique_ptr<int> local_up = transferOwnership();
    // 现在local_up拥有对象的所有权
}
```

## std::weak_ptr的线程安全性

`std::weak_ptr`本身不拥有对象，但它可以观察`shared_ptr`所管理的对象。关于其线程安全性：

:::info
`weak_ptr`的引用计数操作是线程安全的，但与`shared_ptr`类似，对同一个`weak_ptr`对象的并发访问需要外部同步。
:::

典型的安全使用场景：

```cpp
std::shared_ptr<int> sp = std::make_shared<int>(42);
std::weak_ptr<int> wp = sp;

// 线程A
void threadA() {
    if (auto locked_sp = wp.lock()) {  // 尝试获取shared_ptr
        // 成功获取，对象仍然存在
        std::cout << *locked_sp << std::endl;
    } else {
        // 对象已经被销毁
        std::cout << "对象不存在" << std::endl;
    }
}

// 线程B
void threadB() {
    sp.reset();  // 可能导致对象被销毁
}
```

`wp.lock()`操作是线程安全的，它会原子地检查对象是否存在并返回一个新的`shared_ptr`。

## 线程安全的智能指针使用最佳实践

为了在多线程环境中安全地使用智能指针，请遵循以下最佳实践：

### 1. 使用make_shared而非直接构造

```cpp
// 推荐
auto sp = std::make_shared<int>(42);

// 不推荐
std::shared_ptr<int> sp(new int(42));
```

`make_shared`将对象创建和控制块分配合并为一次操作，更加高效且减少了潜在的内存问题。

### 2. 避免对同一个shared_ptr对象的并发写入

```cpp
std::shared_ptr<int> sp = std::make_shared<int>(42);
std::mutex sp_mutex;

// 修改shared_ptr时使用锁保护
{
    std::lock_guard<std::mutex> lock(sp_mutex);
    sp = std::make_shared<int>(100);
}
```

### 3. 保护对象的访问

```cpp
class ThreadSafeCounter {
private:
    std::mutex mutex;
    int value = 0;
public:
    void increment() {
        std::lock_guard<std::mutex> lock(mutex);
        ++value;
    }
    
    int get() const {
        std::lock_guard<std::mutex> lock(mutex);
        return value;
    }
};

// 使用
std::shared_ptr<ThreadSafeCounter> counter = std::make_shared<ThreadSafeCounter>();
// 多线程可以安全地调用counter->increment()和counter->get()
```

### 4. 使用atomic_shared_ptr（C++20）

虽然C++17中没有提供原子版本的智能指针，但在性能要求高的场景下，可以考虑使用C++20中的`std::atomic<std::shared_ptr>`：

```cpp
// C++20
std::atomic<std::shared_ptr<int>> atomic_sp = std::make_shared<int>(42);

// 线程A
auto old_sp = atomic_sp.load();
// 线程B
atomic_sp.store(std::make_shared<int>(100));
```

### 5. 注意循环引用

在多线程环境中，循环引用问题更难追踪，建议使用`weak_ptr`打破循环：

```cpp
struct Node {
    std::shared_ptr<Node> next;
    std::weak_ptr<Node> prev;  // 使用weak_ptr避免循环引用
};
```

## 实际案例：线程安全的观察者模式

下面是一个使用智能指针实现线程安全的观察者模式的例子：

```cpp
#include <iostream>
#include <vector>
#include <memory>
#include <mutex>
#include <algorithm>
#include <thread>

class Observer {
public:
    virtual void update(const std::string& message) = 0;
    virtual ~Observer() = default;
};

class Subject {
private:
    std::vector<std::weak_ptr<Observer>> observers;
    std::mutex observers_mutex;

public:
    void attach(const std::shared_ptr<Observer>& observer) {
        std::lock_guard<std::mutex> lock(observers_mutex);
        observers.push_back(observer);
    }

    void notify(const std::string& message) {
        std::lock_guard<std::mutex> lock(observers_mutex);
        
        // 移除失效的观察者并通知有效观察者
        auto it = observers.begin();
        while (it != observers.end()) {
            if (auto observer = it->lock()) {
                observer->update(message);
                ++it;
            } else {
                it = observers.erase(it);  // 移除已销毁的观察者
            }
        }
    }
};

class ConcreteObserver : public Observer {
private:
    std::string name;
    
public:
    ConcreteObserver(const std::string& n) : name(n) {}
    
    void update(const std::string& message) override {
        std::cout << "Observer " << name << " received: " << message << std::endl;
    }
};

// 使用例子
void example() {
    Subject subject;
    
    // 创建观察者
    auto observer1 = std::make_shared<ConcreteObserver>("1");
    auto observer2 = std::make_shared<ConcreteObserver>("2");
    
    // 添加观察者
    subject.attach(observer1);
    subject.attach(observer2);
    
    // 从多个线程发送通知
    std::thread t1([&subject]() {
        subject.notify("Message from thread 1");
    });
    
    std::thread t2([&subject]() {
        subject.notify("Message from thread 2");
    });
    
    // 观察者2提前退出
    observer2.reset();
    
    // 继续通知
    subject.notify("Final message");
    
    t1.join();
    t2.join();
}
```

这个例子展示了如何使用`weak_ptr`来管理观察者列表，避免悬挂指针问题，并在多线程环境中安全地添加和通知观察者。

## 总结

智能指针在多线程环境中的安全使用需要注意以下要点：

1. `shared_ptr`的引用计数操作是线程安全的，但对同一个`shared_ptr`对象的并发修改是不安全的
2. `unique_ptr`设计为独占所有权，通常不应在多线程间共享
3. `weak_ptr`的引用计数操作是安全的，适合解决循环引用和悬挂指针问题
4. 智能指针不能保证其指向对象的线程安全性，需要额外的同步机制
5. 在多线程环境中，尽量避免对同一智能指针对象的并发写入

掌握智能指针的线程安全特性，可以帮助我们开发出更加健壮和高效的多线程C++程序。

## 练习

1. 实现一个线程安全的缓存类，使用`shared_ptr`存储缓存项，并使用`weak_ptr`实现自动清理过期项。
2. 设计一个多线程工作队列，使用`unique_ptr`转移任务所有权。
3. 修改观察者模式示例，使其支持观察者的优先级排序。

## 额外资源

- [C++标准库参考 - shared_ptr](https://en.cppreference.com/w/cpp/memory/shared_ptr)
- [C++标准库参考 - unique_ptr](https://en.cppreference.com/w/cpp/memory/unique_ptr)
- [C++标准库参考 - weak_ptr](https://en.cppreference.com/w/cpp/memory/weak_ptr)
- Herb Sutter的《Effective Modern C++》中关于智能指针的章节
- Scott Meyers的《Effective Modern C++》中的"理解std::shared_ptr和内存"章节

:::tip
记住，线程安全性不仅仅是关于指针本身，更是关于通过指针访问的数据。确保在多线程环境中适当地保护共享资源！
:::