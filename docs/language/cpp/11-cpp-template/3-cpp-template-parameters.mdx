---
title: C++ 模板参数
description: 本文将详细介绍C++模板参数的概念、类型和使用方法，帮助初学者深入理解C++模板编程。
---

# C++ 模板参数

## 介绍

C++模板是C++编程语言中的一个强大特性，它允许程序员编写通用的代码，这些代码可以处理不同类型的数据。模板的核心是**模板参数**，它们允许我们为模板指定不同的类型或值，从而使模板能够适应各种情况。

在本文中，我们将探讨C++模板参数的基础知识、类型以及它们的应用方式，帮助你全面理解这一重要概念。

## 模板参数的基本概念

模板参数是在模板定义中声明的占位符，它们可以在使用模板时被实际的类型或值替换。C++支持两种主要类型的模板参数：

1. **类型参数（Type Parameters）**：用于表示任意数据类型
2. **非类型参数（Non-type Parameters）**：用于表示具体的值，如整数、指针等
3. **模板模板参数（Template Template Parameters）**：接受模板作为参数的模板参数

接下来，我们将详细讨论这些不同类型的模板参数。

## 类型参数

类型参数是最常见的模板参数形式，它允许模板接受任意数据类型。

### 语法

```cpp
template <typename T>  // 或者使用 template <class T>
class MyContainer {
private:
    T element;
public:
    void setElement(T value) {
        element = value;
    }
    
    T getElement() const {
        return element;
    }
};
```

在这个例子中，`T` 是一个类型参数，它可以被任何有效的C++类型所替代。

:::note
`typename` 和 `class` 关键字在模板声明中的作用是完全相同的，选择哪一个纯粹是风格问题。
:::

### 使用类型参数

```cpp
#include <iostream>

template <typename T>
T add(T a, T b) {
    return a + b;
}

int main() {
    // 整数类型
    int sum1 = add<int>(5, 3);
    std::cout << "5 + 3 = " << sum1 << std::endl;
    
    // 浮点类型
    double sum2 = add<double>(3.5, 2.7);
    std::cout << "3.5 + 2.7 = " << sum2 << std::endl;
    
    // 字符串类型
    std::string str1 = "Hello, ";
    std::string str2 = "World!";
    std::string sum3 = add<std::string>(str1, str2);
    std::cout << str1 << str2 << " = " << sum3 << std::endl;
    
    return 0;
}
```

输出：
```
5 + 3 = 8
3.5 + 2.7 = 6.2
Hello, World! = Hello, World!
```

在这个例子中，我们定义了一个模板函数 `add`，它可以接受任何支持加法运算的类型。当使用不同类型调用此函数时，编译器会为每种类型生成相应的函数代码。

### 多个类型参数

模板可以有多个类型参数：

```cpp
#include <iostream>

template <typename T, typename U>
auto multiply(T a, U b) -> decltype(a * b) {
    return a * b;
}

int main() {
    auto result = multiply(5, 3.5);
    std::cout << "5 * 3.5 = " << result << std::endl;
    
    return 0;
}
```

输出：
```
5 * 3.5 = 17.5
```

这个例子中，我们有两个不同的类型参数 `T` 和 `U`，使得函数可以接受两个不同类型的参数。这里使用了 C++11 的 `auto` 和 `decltype` 来推导返回类型。

## 非类型参数

非类型参数是有具体值的参数，例如整数、枚举、指针或引用。这些参数的值必须在编译时确定。

### 语法

```cpp
template <typename T, int Size>
class Array {
private:
    T elements[Size];
public:
    T& operator[](int index) {
        return elements[index];
    }
    
    int getSize() const {
        return Size;
    }
};
```

在这个例子中，`Size` 是一个非类型参数，它必须是一个整数常量。

### 使用非类型参数

```cpp
#include <iostream>

template <typename T, int Size>
class Array {
private:
    T elements[Size];
public:
    T& operator[](int index) {
        return elements[index];
    }
    
    int getSize() const {
        return Size;
    }
};

int main() {
    Array<int, 5> intArray;
    for (int i = 0; i < intArray.getSize(); ++i) {
        intArray[i] = i * 10;
    }
    
    for (int i = 0; i < intArray.getSize(); ++i) {
        std::cout << "intArray[" << i << "] = " << intArray[i] << std::endl;
    }
    
    return 0;
}
```

输出：
```
intArray[0] = 0
intArray[1] = 10
intArray[2] = 20
intArray[3] = 30
intArray[4] = 40
```

在这个例子中，我们创建了一个含有5个整型元素的数组。数组的大小由非类型参数 `Size` 指定，这个值在编译时就已经确定了。

:::caution
非类型参数有一些限制。例如，不能使用浮点数、class类型对象或字符串字面量作为非类型参数。C++20放宽了一些限制，允许使用特定条件下的class类型作为非类型参数。
:::

## 模板模板参数

模板模板参数是一种接受模板作为参数的模板参数。这是一个高级特性，通常在创建复杂的泛型库时使用。

### 语法

```cpp
template <template <typename> class Container>
class MyClass {
    // ...
};
```

在这个例子中，`Container` 是一个模板模板参数，它必须是一个接受一个类型参数的模板。

### 使用模板模板参数

```cpp
#include <iostream>
#include <vector>
#include <list>

template <template <typename, typename> class Container, typename T>
class DataStorage {
private:
    Container<T, std::allocator<T>> data;
public:
    void addItem(const T& item) {
        data.push_back(item);
    }
    
    void printItems() {
        for (const auto& item : data) {
            std::cout << item << " ";
        }
        std::cout << std::endl;
    }
};

int main() {
    // 使用vector作为容器
    DataStorage<std::vector, int> vecStorage;
    vecStorage.addItem(1);
    vecStorage.addItem(2);
    vecStorage.addItem(3);
    std::cout << "Vector storage: ";
    vecStorage.printItems();
    
    // 使用list作为容器
    DataStorage<std::list, double> listStorage;
    listStorage.addItem(1.1);
    listStorage.addItem(2.2);
    listStorage.addItem(3.3);
    std::cout << "List storage: ";
    listStorage.printItems();
    
    return 0;
}
```

输出：
```
Vector storage: 1 2 3 
List storage: 1.1 2.2 3.3 
```

在这个例子中，`Container` 是一个模板模板参数，它可以接受 `std::vector` 或 `std::list` 等标准容器。注意，由于标准容器通常有多个模板参数（类型和分配器），我们需要在模板模板参数中指定正确的参数个数和类型。

## 默认模板参数

从C++11开始，C++支持为模板参数提供默认值，这与函数参数的默认值类似。

### 语法

```cpp
template <typename T = int, int Size = 10>
class DefaultArray {
    // ...
};
```

在这个例子中，如果不指定 `T`，它默认为 `int`，如果不指定 `Size`，它默认为 `10`。

### 使用默认模板参数

```cpp
#include <iostream>

template <typename T = int, int Size = 5>
class DefaultArray {
private:
    T elements[Size];
public:
    DefaultArray() {
        for (int i = 0; i < Size; ++i) {
            elements[i] = T();
        }
    }
    
    void setElement(int index, T value) {
        if (index >= 0 && index < Size) {
            elements[index] = value;
        }
    }
    
    void printElements() {
        for (int i = 0; i < Size; ++i) {
            std::cout << elements[i] << " ";
        }
        std::cout << std::endl;
    }
};

int main() {
    // 使用默认参数
    DefaultArray<> array1;
    array1.setElement(0, 10);
    array1.setElement(1, 20);
    std::cout << "array1: ";
    array1.printElements();
    
    // 指定类型，使用默认大小
    DefaultArray<double> array2;
    array2.setElement(0, 1.1);
    array2.setElement(1, 2.2);
    std::cout << "array2: ";
    array2.printElements();
    
    // 同时指定类型和大小
    DefaultArray<char, 3> array3;
    array3.setElement(0, 'A');
    array3.setElement(1, 'B');
    array3.setElement(2, 'C');
    std::cout << "array3: ";
    array3.printElements();
    
    return 0;
}
```

输出：
```
array1: 10 20 0 0 0 
array2: 1.1 2.2 0 0 0 
array3: A B C 
```

在这个例子中，我们定义了一个带有默认模板参数的类 `DefaultArray`。默认的类型是 `int`，默认的大小是 `5`。通过不同的方式实例化，我们可以使用默认参数或提供自己的参数。

## 模板参数的实际应用场景

模板参数在实际编程中有广泛的应用，下面是几个常见的使用场景：

### 1. 容器类

标准模板库(STL)的容器大量使用了模板参数：

```cpp
#include <iostream>
#include <vector>
#include <map>

int main() {
    // vector使用类型参数
    std::vector<int> numbers = {1, 2, 3, 4, 5};
    
    // map使用两个类型参数
    std::map<std::string, int> nameAge;
    nameAge["Alice"] = 30;
    nameAge["Bob"] = 25;
    
    for (const auto& pair : nameAge) {
        std::cout << pair.first << " is " << pair.second << " years old." << std::endl;
    }
    
    return 0;
}
```

### 2. 智能指针

智能指针使用模板参数来指定它们管理的对象类型：

```cpp
#include <iostream>
#include <memory>

class Person {
public:
    Person(const std::string& n) : name(n) {
        std::cout << "Person " << name << " created." << std::endl;
    }
    
    ~Person() {
        std::cout << "Person " << name << " destroyed." << std::endl;
    }
    
    void greet() {
        std::cout << "Hello, my name is " << name << "." << std::endl;
    }
    
private:
    std::string name;
};

int main() {
    std::unique_ptr<Person> person1 = std::make_unique<Person>("Alice");
    person1->greet();
    
    std::shared_ptr<Person> person2 = std::make_shared<Person>("Bob");
    person2->greet();
    
    std::shared_ptr<Person> person3 = person2; // 共享所有权
    std::cout << "person2 use count: " << person2.use_count() << std::endl;
    
    return 0;
}
```

### 3. 特定大小的数组

使用非类型参数创建编译时固定大小的数组：

```cpp
#include <iostream>
#include <array>

template <typename T, size_t N>
void printArray(const std::array<T, N>& arr) {
    for (const auto& item : arr) {
        std::cout << item << " ";
    }
    std::cout << std::endl;
}

int main() {
    std::array<int, 5> intArray = {1, 2, 3, 4, 5};
    std::cout << "Integer array: ";
    printArray(intArray);
    
    std::array<double, 3> doubleArray = {1.1, 2.2, 3.3};
    std::cout << "Double array: ";
    printArray(doubleArray);
    
    return 0;
}
```

### 4. 数值计算

使用模板创建通用的数学函数：

```cpp
#include <iostream>
#include <cmath>

template <typename T>
T square(T value) {
    return value * value;
}

template <typename T>
T power(T base, int exponent) {
    if (exponent == 0) return 1;
    
    T result = 1;
    for (int i = 0; i < exponent; ++i) {
        result *= base;
    }
    return result;
}

int main() {
    std::cout << "Square of 5: " << square(5) << std::endl;
    std::cout << "Square of 3.7: " << square(3.7) << std::endl;
    
    std::cout << "2^5: " << power(2, 5) << std::endl;
    std::cout << "1.5^3: " << power(1.5, 3) << std::endl;
    
    return 0;
}
```

## 模板参数的最佳实践

在使用模板参数时，有一些最佳实践可以帮助你编写更清晰、更易维护的代码：

1. **使用有意义的名称**：与变量命名一样，为模板参数选择描述性名称可以提高代码可读性。
   ```cpp
   // 好的命名
   template <typename ElementType, int ArraySize>
   class Array { /* ... */ };

   // 不太好的命名
   template <typename T, int N>
   class Array { /* ... */ };
   ```

2. **提供有用的默认参数**：如果某个参数通常使用同一个值，考虑提供默认值。
   ```cpp
   template <typename T = int, int Size = 10>
   class Buffer { /* ... */ };
   ```

3. **约束模板参数**：在C++20中，可以使用概念(concepts)来约束模板参数的类型。
   ```cpp
   template <typename T>
   requires std::is_arithmetic_v<T>
   T add(T a, T b) {
       return a + b;
   }
   ```

4. **避免过度模板化**：只有在真正需要泛型代码时才使用模板。过度使用模板会使代码难以理解和维护。

## 总结

模板参数是C++模板编程的核心概念，它们使C++能够支持真正的泛型编程。通过本文，我们了解了：

1. **类型参数**：用于表示任意数据类型
2. **非类型参数**：用于表示编译时已知的常量值
3. **模板模板参数**：允许模板作为参数传递给其他模板
4. **默认模板参数**：为模板参数提供默认值

掌握模板参数可以帮助你编写更灵活、更可重用的代码，是迈向C++高级编程的重要一步。

## 练习题

为了巩固所学知识，尝试完成以下练习：

1. 创建一个通用的 `Max` 函数模板，可以返回任意类型的两个值中的较大值。

2. 实现一个 `CircularBuffer` 类模板，它有两个模板参数：元素类型和缓冲区大小。

3. 创建一个 `Pair` 类模板，可以存储两个不同类型的值。

4. 设计一个 `Matrix` 类模板，使用非类型参数指定行和列的数量。

5. 实现一个接受容器类型作为模板模板参数的 `SortedContainer` 类模板。

## 附加资源

如果你想进一步学习C++模板编程，可以参考以下资源：

- [C++ Templates: The Complete Guide (2nd Edition) by David Vandevoorde, Nicolai M. Josuttis, and Douglas Gregor](https://www.amazon.com/C-Templates-Complete-Guide-2nd/dp/0321714121)
- [Modern C++ Design: Generic Programming and Design Patterns Applied by Andrei Alexandrescu](https://www.amazon.com/Modern-Design-Generic-Programming-Patterns/dp/0201704315)
- [C++ Standard Library: A Tutorial and Reference (2nd Edition) by Nicolai M. Josuttis](https://www.amazon.com/Standard-Library-Tutorial-Reference-2nd/dp/0321623215)

祝你在C++模板编程的道路上取得成功！