---
title: C++ 函数模板
description: 详细介绍C++函数模板的概念、语法和应用，帮助初学者理解和使用这一强大的C++特性。
---

# C++ 函数模板

## 什么是函数模板？

函数模板是C++中的一项强大特性，它允许我们编写一个通用函数，可以处理不同数据类型的参数，而无需为每种数据类型重新编写函数。函数模板通过泛型编程的方式，大大提高了代码的复用性和可维护性。

:::note
函数模板不是实际的函数，而是生成函数的"蓝图"。当我们调用函数模板时，编译器会根据我们提供的参数类型，实例化出具体的函数。
:::

## 函数模板的基本语法

函数模板的基本语法如下：

```cpp
template <typename T>
返回类型 函数名(参数列表) {
    // 函数体
}
```

这里的`T`是一个类型参数，代表一个未知的数据类型。`typename`关键字表示`T`是一个类型。在较早的C++标准中，也可以使用`class`关键字代替`typename`。

## 一个简单的函数模板示例

让我们从一个最基础的例子开始，创建一个可以交换任意类型两个变量值的函数模板：

```cpp
#include <iostream>

// 定义一个函数模板
template <typename T>
void swap_values(T& a, T& b) {
    T temp = a;
    a = b;
    b = temp;
}

int main() {
    // 交换整数
    int a = 5, b = 10;
    std::cout << "整数交换前: a = " << a << ", b = " << b << std::endl;
    swap_values(a, b);
    std::cout << "整数交换后: a = " << a << ", b = " << b << std::endl;
    
    // 交换浮点数
    double c = 3.14, d = 2.71;
    std::cout << "浮点数交换前: c = " << c << ", d = " << d << std::endl;
    swap_values(c, d);
    std::cout << "浮点数交换后: c = " << c << ", d = " << d << std::endl;
    
    // 交换字符
    char e = 'A', f = 'B';
    std::cout << "字符交换前: e = " << e << ", f = " << f << std::endl;
    swap_values(e, f);
    std::cout << "字符交换后: e = " << e << ", f = " << f << std::endl;
    
    return 0;
}
```

**输出：**
```
整数交换前: a = 5, b = 10
整数交换后: a = 10, b = 5
浮点数交换前: c = 3.14, d = 2.71
浮点数交换后: c = 2.71, d = 3.14
字符交换前: e = A, f = B
字符交换后: e = B, f = A
```

在上面的例子中，我们定义了一个名为`swap_values`的函数模板。通过使用模板参数`T`，这个函数可以交换任何类型的两个变量值，只要该类型支持赋值操作。

## 模板参数推导

当我们调用函数模板时，编译器会根据传入的参数类型自动推导模板参数的实际类型。这一过程称为**模板参数推导**。

例如，在调用`swap_values(a, b)`时，由于`a`和`b`的类型是`int`，编译器会推导出`T`为`int`，然后实例化一个`swap_values<int>`函数。

:::tip
在大多数情况下，我们不需要显式指定模板参数的类型，让编译器自动推导即可。但有时候为了避免歧义或者需要特定类型转换时，我们也可以显式指定模板参数类型，例如：`swap_values<double>(a, b)`。
:::

## 多个模板参数

函数模板可以拥有多个模板参数，这使得它可以处理更复杂的情况：

```cpp
#include <iostream>

// 多个模板参数的函数模板
template <typename T1, typename T2>
void print_pair(const T1& a, const T2& b) {
    std::cout << "(" << a << ", " << b << ")" << std::endl;
}

int main() {
    print_pair(10, 3.14);        // T1=int, T2=double
    print_pair("Hello", 'W');    // T1=const char*, T2=char
    print_pair(true, 42);        // T1=bool, T2=int
    
    return 0;
}
```

**输出：**
```
(10, 3.14)
(Hello, W)
(1, 42)
```

## 非类型模板参数

除了类型参数外，函数模板还可以有非类型参数，如整数、指针等：

```cpp
#include <iostream>
#include <array>

// 带有非类型模板参数的函数模板
template <typename T, size_t N>
void print_array(const std::array<T, N>& arr) {
    std::cout << "数组元素: ";
    for (size_t i = 0; i < N; ++i) {
        std::cout << arr[i];
        if (i < N - 1) std::cout << ", ";
    }
    std::cout << std::endl;
}

int main() {
    std::array<int, 5> numbers = {1, 2, 3, 4, 5};
    std::array<char, 3> letters = {'A', 'B', 'C'};
    
    print_array(numbers);  // T=int, N=5
    print_array(letters);  // T=char, N=3
    
    return 0;
}
```

**输出：**
```
数组元素: 1, 2, 3, 4, 5
数组元素: A, B, C
```

## 函数模板特化

有时候，我们希望对特定类型提供特殊处理，这时可以使用函数模板特化：

```cpp
#include <iostream>
#include <string>

// 主模板
template <typename T>
T max_value(T a, T b) {
    std::cout << "通用模板" << std::endl;
    return (a > b) ? a : b;
}

// 特化版本：针对const char*类型
template <>
const char* max_value<const char*>(const char* a, const char* b) {
    std::cout << "const char*特化版本" << std::endl;
    return (strcmp(a, b) > 0) ? a : b;
}

int main() {
    std::cout << "整数比较: " << max_value(10, 20) << std::endl;
    std::cout << "浮点数比较: " << max_value(3.14, 2.71) << std::endl;
    std::cout << "字符串比较: " << max_value("apple", "banana") << std::endl;
    
    return 0;
}
```

**输出：**
```
通用模板
整数比较: 20
通用模板
浮点数比较: 3.14
const char*特化版本
字符串比较: banana
```

在上面的例子中，我们为`const char*`类型提供了一个特化版本，它使用`strcmp`函数进行字符串比较，而不是直接比较指针地址。

## 实际应用案例：排序算法

函数模板在实际开发中有着广泛的应用。以下是一个使用函数模板实现冒泡排序的例子：

```cpp
#include <iostream>
#include <vector>
#include <string>

// 冒泡排序函数模板
template <typename T>
void bubble_sort(std::vector<T>& arr) {
    int n = arr.size();
    for (int i = 0; i < n - 1; ++i) {
        for (int j = 0; j < n - i - 1; ++j) {
            if (arr[j] > arr[j + 1]) {
                // 交换元素
                T temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
            }
        }
    }
}

// 打印向量的函数模板
template <typename T>
void print_vector(const std::vector<T>& vec) {
    for (const auto& item : vec) {
        std::cout << item << " ";
    }
    std::cout << std::endl;
}

int main() {
    // 整数排序
    std::vector<int> numbers = {5, 2, 9, 1, 7, 6};
    std::cout << "整数排序前: ";
    print_vector(numbers);
    bubble_sort(numbers);
    std::cout << "整数排序后: ";
    print_vector(numbers);
    
    // 浮点数排序
    std::vector<double> decimals = {3.14, 1.41, 2.71, 1.73};
    std::cout << "浮点数排序前: ";
    print_vector(decimals);
    bubble_sort(decimals);
    std::cout << "浮点数排序后: ";
    print_vector(decimals);
    
    // 字符串排序
    std::vector<std::string> words = {"banana", "apple", "cherry", "date"};
    std::cout << "字符串排序前: ";
    print_vector(words);
    bubble_sort(words);
    std::cout << "字符串排序后: ";
    print_vector(words);
    
    return 0;
}
```

**输出：**
```
整数排序前: 5 2 9 1 7 6 
整数排序后: 1 2 5 6 7 9 
浮点数排序前: 3.14 1.41 2.71 1.73 
浮点数排序后: 1.41 1.73 2.71 3.14 
字符串排序前: banana apple cherry date 
字符串排序后: apple banana cherry date 
```

在这个例子中，我们使用函数模板实现了一个通用的冒泡排序算法，可以对各种类型的数据进行排序，只要该类型支持比较运算符`>`。

## 函数模板与函数重载的区别

函数模板和函数重载都可以创建具有相同名称的多个函数，但它们有本质上的区别：

1. **函数重载**：根据参数的类型和数量来区分多个函数。每个重载函数都是单独编写的，有自己的实现。
2. **函数模板**：只编写一次，然后编译器会根据调用时的参数类型自动生成相应的函数代码。

```cpp
#include <iostream>

// 函数重载示例
int add(int a, int b) {
    std::cout << "调用int版本" << std::endl;
    return a + b;
}

double add(double a, double b) {
    std::cout << "调用double版本" << std::endl;
    return a + b;
}

// 函数模板示例
template <typename T>
T multiply(T a, T b) {
    std::cout << "调用模板版本" << std::endl;
    return a * b;
}

int main() {
    // 函数重载
    std::cout << add(3, 4) << std::endl;        // 调用int版本
    std::cout << add(2.5, 3.5) << std::endl;    // 调用double版本
    
    // 函数模板
    std::cout << multiply(3, 4) << std::endl;       // 实例化为multiply<int>
    std::cout << multiply(2.5, 3.5) << std::endl;   // 实例化为multiply<double>
    
    return 0;
}
```

**输出：**
```
调用int版本
7
调用double版本
6
调用模板版本
12
调用模板版本
8.75
```

## 函数模板的局限性

尽管函数模板非常强大，但它也有一些局限性：

1. **类型约束**：函数模板假设所有类型都支持它所使用的操作（如比较、赋值等）。如果传入的类型不支持这些操作，编译会失败。

2. **调试困难**：模板代码的错误消息往往很复杂，难以理解，特别是当模板嵌套或涉及复杂类型推导时。

3. **代码膨胀**：每个不同类型的模板实例化都会生成一份新代码，可能导致可执行文件大小增加。

## C++ 17中的模板参数推导指南

在C++17中，新增了模板参数推导指南功能，可以更灵活地控制模板参数的推导：

```cpp
#include <iostream>

// 定义一个持有数据的简单容器模板
template <typename T>
struct Container {
    T value;
    
    Container(T val) : value(val) {}
};

// C++17之前，需要显式指定模板参数
// Container<int> c1(42); 

int main() {
    // C++17中，可以自动推导
    Container c1(42);      // 推导为Container<int>
    Container c2(3.14);    // 推导为Container<double>
    
    std::cout << "c1.value = " << c1.value << std::endl;
    std::cout << "c2.value = " << c2.value << std::endl;
    
    return 0;
}
```

**输出：**
```
c1.value = 42
c2.value = 3.14
```

## 总结

函数模板是C++中实现泛型编程的核心机制之一，它允许我们编写一次代码，处理多种类型的数据。通过函数模板，我们可以：

- 创建类型无关的通用算法
- 减少代码重复
- 提高代码的可维护性和复用性
- 实现类型安全的泛型编程

掌握函数模板是成为高级C++程序员的重要一步，也是理解STL（标准模板库）的基础。

## 练习

1. 编写一个函数模板，计算任意类型数组的平均值。
2. 创建一个函数模板，可以找出任何类型数组中的最大值和最小值。
3. 实现一个函数模板，可以将任意类型的向量进行逆序排列。
4. 编写一个函数模板，检查一个容器中是否包含特定元素。
5. 实现一个函数模板，合并两个相同类型的有序数组或向量，保持结果有序。

## 进一步学习资源

- 探索C++标准库中的算法，了解函数模板在实际库中的应用
- 学习C++类模板，它是函数模板的扩展，可以创建通用的类
- 深入研究模板元编程技术，探索模板在编译期计算的能力
- 了解C++20中的概念(Concepts)特性，它为模板参数提供了约束机制