---
title: C++ 数组传递给函数
description: 本文详细介绍C++中数组作为函数参数的传递方式、注意事项以及最佳实践，帮助初学者掌握数组与函数交互的核心概念。
---

# C++ 数组传递给函数

在C++编程中，我们经常需要将数组传递给函数进行处理。理解数组作为函数参数的传递机制，对于编写高效、正确的代码至关重要。本文将详细介绍C++中数组传递给函数的各种方式、注意事项以及实际应用。

## 数组作为函数参数的基本概念

在C++中，当数组作为函数参数传递时，实际上传递的是**数组的首地址**，而不是整个数组的副本。这意味着：

1. 函数内部对数组元素的修改会影响到原始数组
2. 传递大型数组时不会产生额外的内存开销
3. 函数无法通过参数获知数组的大小

### 数组参数的基本语法

```cpp
// 方式1：使用方括号表示数组参数
void processArray(int arr[]);

// 方式2：使用指针表示数组参数（等效于方式1）
void processArray(int* arr);

// 方式3：指定数组大小（仅作为文档参考，编译器会忽略括号中的大小）
void processArray(int arr[10]);
```

:::note
以上三种声明方式在函数内部的行为完全相同，因为编译器会将数组参数视为指针。
:::

## 一维数组的传递

让我们通过一个简单的例子来理解一维数组的传递：

```cpp
#include <iostream>
using namespace std;

// 打印数组元素的函数
void printArray(int arr[], int size) {
    for (int i = 0; i < size; i++) {
        cout << arr[i] << " ";
    }
    cout << endl;
}

// 修改数组元素的函数
void modifyArray(int arr[], int size) {
    for (int i = 0; i < size; i++) {
        arr[i] = arr[i] * 2;  // 将每个元素值翻倍
    }
}

int main() {
    int numbers[] = {1, 2, 3, 4, 5};
    int size = sizeof(numbers) / sizeof(numbers[0]);
    
    cout << "原始数组: ";
    printArray(numbers, size);
    
    modifyArray(numbers, size);
    
    cout << "修改后数组: ";
    printArray(numbers, size);
    
    return 0;
}
```

**输出结果：**
```
原始数组: 1 2 3 4 5
修改后数组: 2 4 6 8 10
```

在这个例子中，我们可以看到：

1. 数组`numbers`被传递给`printArray`和`modifyArray`函数
2. 我们必须**额外传递数组的大小**，因为函数无法自动获取
3. `modifyArray`函数修改了数组的元素，这些修改在`main`函数中可见

:::caution
在C++中，函数无法通过数组参数自行确定数组大小。必须显式传递数组大小或使用其他方法（如下文的标准库容器）。
:::

## 多维数组的传递

多维数组的传递比一维数组稍微复杂一些。对于二维数组，我们需要至少指定第二维的大小：

```cpp
#include <iostream>
using namespace std;

// 传递二维数组的函数
void process2DArray(int arr[][3], int rows) {
    for (int i = 0; i < rows; i++) {
        for (int j = 0; j < 3; j++) {
            cout << arr[i][j] << " ";
        }
        cout << endl;
    }
}

int main() {
    int matrix[2][3] = {
        {1, 2, 3},
        {4, 5, 6}
    };
    
    process2DArray(matrix, 2);
    
    return 0;
}
```

**输出结果：**
```
1 2 3 
4 5 6 
```

:::warning
对于多维数组，除了第一维以外，其他维度的大小在函数参数中必须明确指定。
:::

## 使用模板和引用传递数组

为了更灵活地处理不同大小的数组，我们可以使用模板和引用：

```cpp
#include <iostream>
using namespace std;

// 使用模板函数处理固定大小的数组
template <size_t N>
void printArray(int (&arr)[N]) {
    cout << "数组大小: " << N << endl;
    for (int i = 0; i < N; i++) {
        cout << arr[i] << " ";
    }
    cout << endl;
}

int main() {
    int smallArray[] = {1, 2, 3};
    int largeArray[] = {5, 4, 3, 2, 1, 0};
    
    printArray(smallArray);  // 自动推导大小为3
    printArray(largeArray);  // 自动推导大小为6
    
    return 0;
}
```

**输出结果：**
```
数组大小: 3
1 2 3 
数组大小: 6
5 4 3 2 1 0 
```

这种方法的优点是：

1. 函数能够自动推导数组大小
2. 可以防止数组退化为指针
3. 代码更加类型安全

## 常量数组的传递

为了防止函数修改原始数组，我们可以使用`const`关键字：

```cpp
#include <iostream>
using namespace std;

// 安全的打印函数，不会修改原数组
void safePrint(const int arr[], int size) {
    for (int i = 0; i < size; i++) {
        cout << arr[i] << " ";
        // arr[i] = 0;  // 这行代码会导致编译错误
    }
    cout << endl;
}

int main() {
    int numbers[] = {10, 20, 30, 40, 50};
    int size = sizeof(numbers) / sizeof(numbers[0]);
    
    safePrint(numbers, size);
    
    return 0;
}
```

**输出结果：**
```
10 20 30 40 50 
```

使用`const`关键字可以让编译器帮助我们确保函数不会修改传入的数组，增加代码的健壮性。

## 传递字符数组（字符串）

C++中处理字符串时，通常使用字符数组：

```cpp
#include <iostream>
#include <cstring>
using namespace std;

// 计算字符串长度的函数
int stringLength(const char str[]) {
    int length = 0;
    while (str[length] != '\0') {
        length++;
    }
    return length;
}

// 连接两个字符串
void concatenateStrings(char result[], const char str1[], const char str2[]) {
    int i = 0, j = 0;
    
    // 复制第一个字符串
    while (str1[i] != '\0') {
        result[j++] = str1[i++];
    }
    
    // 复制第二个字符串
    i = 0;
    while (str2[i] != '\0') {
        result[j++] = str2[i++];
    }
    
    // 添加字符串结束符
    result[j] = '\0';
}

int main() {
    const char greeting[] = "Hello";
    const char name[] = "World";
    char result[20];  // 确保足够大小存储连接结果
    
    cout << "第一个字符串长度: " << stringLength(greeting) << endl;
    cout << "第二个字符串长度: " << stringLength(name) << endl;
    
    concatenateStrings(result, greeting, name);
    cout << "连接结果: " << result << endl;
    
    return 0;
}
```

**输出结果：**
```
第一个字符串长度: 5
第二个字符串长度: 5
连接结果: HelloWorld
```

:::tip
处理字符串时，注意确保目标数组有足够的空间，并且始终添加字符串结束符`'\0'`。
:::

## 使用现代C++传递数组

现代C++提供了更安全、更灵活的方式来处理数组：

### 使用std::array

```cpp
#include <iostream>
#include <array>
using namespace std;

// 使用std::array传递固定大小的数组
void processArray(const array<int, 5>& arr) {
    cout << "数组元素: ";
    for (int val : arr) {
        cout << val << " ";
    }
    cout << endl;
}

int main() {
    array<int, 5> numbers = {1, 2, 3, 4, 5};
    processArray(numbers);
    return 0;
}
```

**输出结果：**
```
数组元素: 1 2 3 4 5 
```

### 使用std::vector

```cpp
#include <iostream>
#include <vector>
using namespace std;

// 使用std::vector传递动态大小的数组
void processVector(const vector<int>& vec) {
    cout << "向量大小: " << vec.size() << endl;
    cout << "向量元素: ";
    for (int val : vec) {
        cout << val << " ";
    }
    cout << endl;
}

int main() {
    vector<int> numbers = {5, 4, 3, 2, 1};
    processVector(numbers);
    
    // 添加更多元素
    numbers.push_back(0);
    numbers.push_back(-1);
    processVector(numbers);
    
    return 0;
}
```

**输出结果：**
```
向量大小: 5
向量元素: 5 4 3 2 1 
向量大小: 7
向量元素: 5 4 3 2 1 0 -1 
```

:::tip
在现代C++中，除非有特殊需求，否则应优先考虑使用`std::array`和`std::vector`而非原始数组。
:::

## 实际应用案例

### 图像处理示例

假设我们正在开发一个简单的图像处理程序，需要对图像进行灰度转换：

```cpp
#include <iostream>
using namespace std;

// 将彩色图像转换为灰度图像
// 每个像素由RGB三个值表示，转换为单个灰度值
void convertToGrayscale(const int colorImage[][3], int grayscaleImage[], int pixels) {
    for (int i = 0; i < pixels; i++) {
        // 使用加权平均法计算灰度值 (0.3*R + 0.59*G + 0.11*B)
        grayscaleImage[i] = static_cast<int>(
            0.3 * colorImage[i][0] +    // 红色分量
            0.59 * colorImage[i][1] +   // 绿色分量
            0.11 * colorImage[i][2]     // 蓝色分量
        );
    }
}

int main() {
    // 简单的3x3彩色图像，每个像素有RGB三个值
    int colorImage[9][3] = {
        {255, 0, 0},    // 红色像素
        {0, 255, 0},    // 绿色像素
        {0, 0, 255},    // 蓝色像素
        {255, 255, 0},  // 黄色像素
        {255, 0, 255},  // 洋红色像素
        {0, 255, 255},  // 青色像素
        {255, 255, 255},// 白色像素
        {128, 128, 128},// 灰色像素
        {0, 0, 0}       // 黑色像素
    };
    
    int grayscaleImage[9];
    convertToGrayscale(colorImage, grayscaleImage, 9);
    
    cout << "原始彩色图像和转换后的灰度值：" << endl;
    for (int i = 0; i < 9; i++) {
        cout << "RGB(" << colorImage[i][0] << ", " 
             << colorImage[i][1] << ", " 
             << colorImage[i][2] << ") -> 灰度值: " 
             << grayscaleImage[i] << endl;
    }
    
    return 0;
}
```

**输出结果：**
```
原始彩色图像和转换后的灰度值：
RGB(255, 0, 0) -> 灰度值: 76
RGB(0, 255, 0) -> 灰度值: 150
RGB(0, 0, 255) -> 灰度值: 28
RGB(255, 255, 0) -> 灰度值: 226
RGB(255, 0, 255) -> 灰度值: 104
RGB(0, 255, 255) -> 灰度值: 178
RGB(255, 255, 255) -> 灰度值: 255
RGB(128, 128, 128) -> 灰度值: 128
RGB(0, 0, 0) -> 灰度值: 0
```

### 学生成绩统计系统

以下是一个使用数组处理学生成绩的示例：

```cpp
#include <iostream>
#include <string>
using namespace std;

// 计算平均分
double calculateAverage(const int scores[], int count) {
    int sum = 0;
    for (int i = 0; i < count; i++) {
        sum += scores[i];
    }
    return static_cast<double>(sum) / count;
}

// 查找最高分
int findHighestScore(const int scores[], int count) {
    int highest = scores[0];
    for (int i = 1; i < count; i++) {
        if (scores[i] > highest) {
            highest = scores[i];
        }
    }
    return highest;
}

// 查找最低分
int findLowestScore(const int scores[], int count) {
    int lowest = scores[0];
    for (int i = 1; i < count; i++) {
        if (scores[i] < lowest) {
            lowest = scores[i];
        }
    }
    return lowest;
}

// 显示成绩分析
void analyzeScores(const string names[], const int scores[], int count) {
    cout << "=== 学生成绩分析 ===" << endl;
    
    // 列出所有学生成绩
    cout << "学生成绩列表：" << endl;
    for (int i = 0; i < count; i++) {
        cout << names[i] << ": " << scores[i] << endl;
    }
    
    // 计算并显示统计信息
    double average = calculateAverage(scores, count);
    int highest = findHighestScore(scores, count);
    int lowest = findLowestScore(scores, count);
    
    cout << "\n统计信息：" << endl;
    cout << "平均分: " << average << endl;
    cout << "最高分: " << highest << endl;
    cout << "最低分: " << lowest << endl;
    
    // 找出成绩最高和最低的学生
    cout << "\n成绩最高的学生：" << endl;
    for (int i = 0; i < count; i++) {
        if (scores[i] == highest) {
            cout << names[i] << " (" << scores[i] << ")" << endl;
        }
    }
    
    cout << "\n成绩最低的学生：" << endl;
    for (int i = 0; i < count; i++) {
        if (scores[i] == lowest) {
            cout << names[i] << " (" << scores[i] << ")" << endl;
        }
    }
}

int main() {
    const int studentCount = 5;
    string names[studentCount] = {"张三", "李四", "王五", "赵六", "钱七"};
    int scores[studentCount] = {85, 92, 78, 96, 88};
    
    analyzeScores(names, scores, studentCount);
    
    return 0;
}
```

**输出结果：**
```
=== 学生成绩分析 ===
学生成绩列表：
张三: 85
李四: 92
王五: 78
赵六: 96
钱七: 88

统计信息：
平均分: 87.8
最高分: 96
最低分: 78

成绩最高的学生：
赵六 (96)

成绩最低的学生：
王五 (78)
```

## 总结

通过本文，我们了解了在C++中将数组传递给函数的多种方式，包括：

1. 基本的一维数组传递（实际是传递指针）
2. 多维数组的传递（需要指定除第一维外的其他维度大小）
3. 使用模板和引用传递数组（保留数组大小信息）
4. 常量数组的传递（防止函数修改原数组）
5. 字符数组（字符串）的传递
6. 现代C++中使用`std::array`和`std::vector`

关键要点：

- 在C++中，数组作为参数传递时会退化为指针，丢失大小信息
- 传递数组时通常需要同时传递大小信息
- 使用`const`可以防止函数修改原始数组
- 现代C++中，`std::array`和`std::vector`通常是更好的选择

## 练习题

1. 编写一个函数，接受一个整数数组并返回数组中所有元素的和。
2. 创建一个函数，接受两个数组并合并它们到第三个数组中。
3. 实现一个函数，将一个整数数组按照升序排列。
4. 编写一个程序，使用二维数组表示矩阵，并实现矩阵加法和乘法函数。
5. 创建一个使用`std::array`的例子，展示它相比传统数组的优势。

## 延伸阅读

- C++标准库中的STL容器详解
- 指针与数组的深入理解
- 函数传参的不同方式比较：值传递、引用传递和指针传递
- 内存管理与数组性能优化

掌握数组传递给函数的正确方式，是成为一名优秀C++程序员的基本功之一，希望本文能够帮助你更好地理解这一核心概念！