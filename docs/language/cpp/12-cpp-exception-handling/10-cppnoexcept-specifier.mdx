---
title: C++ noexcept说明符
description: 学习C++中的noexcept说明符，了解如何声明不抛出异常的函数以优化性能并提高代码稳定性
---

# C++ noexcept说明符

在C++异常处理的世界中，`noexcept`说明符是一个非常实用的工具，它允许我们向编译器声明哪些函数不会抛出异常。这一特性在C++11中引入，是现代C++异常处理机制的重要组成部分。理解和正确使用`noexcept`可以帮助你编写更加高效、可靠的代码。

## 什么是noexcept说明符？

`noexcept`是一个函数说明符，用于指定一个函数是否会抛出异常。当我们将函数声明为`noexcept`时，我们向编译器和其他程序员承诺：这个函数不会抛出异常，或者说，任何可能抛出的异常都将在函数内部被捕获和处理。

基本语法如下：

```cpp
返回类型 函数名(参数列表) noexcept;
```

## noexcept的工作原理

### 基本用法

最简单的`noexcept`用法是在函数声明时添加它：

```cpp
void myFunction() noexcept {
    // 函数实现...
}
```

这表明`myFunction`不会抛出任何异常，或者任何潜在的异常都会在函数内部被处理。

### noexcept表达式

`noexcept`可以接受一个布尔表达式作为参数，根据表达式的结果决定函数是否不抛出异常：

```cpp
void myFunction() noexcept(true) {  // 等同于 noexcept
    // 函数实现...
}

void anotherFunction() noexcept(false) {  // 可能抛出异常
    // 函数实现...
}
```

`noexcept(true)`表示函数不会抛出异常，等同于直接使用`noexcept`。
`noexcept(false)`表示函数可能会抛出异常。

### noexcept运算符

C++11还引入了`noexcept`运算符，它用于在编译时检查表达式是否声明为不抛出异常：

```cpp
void funcA() noexcept {}
void funcB() {}

bool testA = noexcept(funcA());  // true
bool testB = noexcept(funcB());  // false
```

这里，`noexcept(funcA())`返回`true`，因为`funcA`被声明为`noexcept`；而`noexcept(funcB())`返回`false`，因为`funcB`没有`noexcept`说明。

## 为什么使用noexcept？

### 性能优化

当函数被声明为`noexcept`时，编译器可以进行一些优化，例如：

1. 避免生成异常处理代码
2. 对某些操作（如移动构造函数）进行更高效的实现

### 代码契约

`noexcept`是一种代码契约，它明确告诉函数的调用者：这个函数不会抛出异常。这使得代码更加可预测，有助于调用者决定是否需要进行异常处理。

### 标准库优化

C++标准库会根据函数是否声明为`noexcept`来选择不同的算法实现。例如，当类的移动构造函数声明为`noexcept`时，`vector`在重新分配内存时会优先使用移动而非复制操作。

## 实际示例

### 示例1：简单的noexcept函数

```cpp
#include <iostream>

void safeFunction() noexcept {
    std::cout << "This function is guaranteed not to throw" << std::endl;
    // 正常操作，不抛出异常
}

void riskyFunction() {
    std::cout << "This function might throw exceptions" << std::endl;
    throw std::runtime_error("An error occurred");
}

int main() {
    // 调用安全函数
    safeFunction();
    
    try {
        // 调用可能抛出异常的函数
        riskyFunction();
    } catch (const std::exception& e) {
        std::cout << "Caught exception: " << e.what() << std::endl;
    }
    
    return 0;
}
```

输出：
```
This function is guaranteed not to throw
This function might throw exceptions
Caught exception: An error occurred
```

### 示例2：违反noexcept承诺

如果一个声明为`noexcept`的函数实际上抛出了异常，程序会调用`std::terminate()`终止执行：

```cpp
#include <iostream>

void brokenPromise() noexcept {
    std::cout << "This function promised not to throw..." << std::endl;
    throw std::runtime_error("...but it did anyway!");  // 违反承诺
}

int main() {
    try {
        brokenPromise();
    } catch (const std::exception& e) {
        // 这个catch块永远不会执行
        std::cout << "Caught exception: " << e.what() << std::endl;
    }
    
    return 0;
}
```

当运行这段代码时，程序会在`throw`语句执行后立即终止，而不会执行catch块。

:::caution 警告
当noexcept函数抛出异常时，程序会直接调用std::terminate()终止，不会进行正常的异常处理流程。所以确保你的noexcept函数真的不会抛出异常！
:::

### 示例3：条件性noexcept

`noexcept`可以根据条件决定是否声明函数不抛出异常：

```cpp
#include <iostream>
#include <vector>

// 模板函数，根据类型T的移动构造函数是否noexcept决定自身是否noexcept
template<typename T>
void moveElements(std::vector<T>& source, std::vector<T>& target) noexcept(noexcept(T(std::move(T())))) {
    for (auto& element : source) {
        target.push_back(std::move(element));
    }
    source.clear();
}

class SafeToMove {
public:
    SafeToMove() = default;
    SafeToMove(SafeToMove&&) noexcept = default;  // 移动构造函数不抛出异常
};

class UnsafeToMove {
public:
    UnsafeToMove() = default;
    UnsafeToMove(UnsafeToMove&&) { /* 可能抛出异常 */ }
};

int main() {
    // 使用SafeToMove类测试
    std::vector<SafeToMove> sourceA, targetA;
    sourceA.push_back(SafeToMove());
    
    std::cout << "moveElements with SafeToMove is noexcept: " 
              << std::boolalpha 
              << noexcept(moveElements(sourceA, targetA)) 
              << std::endl;
              
    // 使用UnsafeToMove类测试
    std::vector<UnsafeToMove> sourceB, targetB;
    sourceB.push_back(UnsafeToMove());
    
    std::cout << "moveElements with UnsafeToMove is noexcept: " 
              << std::boolalpha 
              << noexcept(moveElements(sourceB, targetB)) 
              << std::endl;
    
    return 0;
}
```

输出：
```
moveElements with SafeToMove is noexcept: true
moveElements with UnsafeToMove is noexcept: false
```

这个示例展示了如何根据模板参数类型的属性来条件性地声明函数是否为`noexcept`。

## noexcept的最佳实践

### 何时使用noexcept

1. **对于不抛出异常的函数**：如果你确定函数不会抛出异常，将其标记为`noexcept`可以帮助编译器优化。

2. **移动操作**：尽可能将移动构造函数和移动赋值运算符声明为`noexcept`，以便标准容器可以使用更高效的移动语义。

3. **析构函数**：C++11以后的析构函数默认是`noexcept(true)`，通常不需要显式声明。

4. **swap函数**：交换操作通常应该是`noexcept`的。

### 何时避免使用noexcept

1. **可能抛出异常的函数**：如果函数内部调用其他可能抛出异常的函数，且你不打算捕获所有异常，就不应该使用`noexcept`。

2. **依赖外部资源的函数**：如果函数依赖文件I/O、网络通信等可能失败的外部资源，通常应该允许异常传播而不是使用`noexcept`。

## noexcept与异常规范(exception specification)的区别

C++98引入的异常规范（使用`throw()`语法）在C++11中被废弃，并在C++17中被完全移除。`noexcept`被设计为替代这一机制，并提供了更好的性能和更清晰的语义。

```cpp
// C++98风格（已废弃）
void oldFunction() throw(std::runtime_error);  // 只能抛出std::runtime_error
void safeOldFunction() throw();  // 不抛出任何异常

// C++11及以后的风格
void newFunction() noexcept(false);  // 可能抛出异常
void safeNewFunction() noexcept;  // 不抛出异常
```

:::warning
避免使用已废弃的`throw()`异常规范语法，应该改用`noexcept`。
:::

## 总结

`noexcept`说明符是C++11引入的一个重要特性，它允许程序员向编译器声明函数是否会抛出异常。正确使用`noexcept`可以：

1. 提高代码性能，因为编译器可以优化无需异常处理的代码
2. 为函数调用者提供明确的保证
3. 使标准库能够使用更高效的算法实现

记住，`noexcept`是一个承诺，如果被标记为`noexcept`的函数实际抛出了异常，程序会调用`std::terminate()`直接终止。因此，只有在完全确定函数不会抛出异常，或者所有可能的异常都在函数内部被处理的情况下，才应该使用`noexcept`。

## 练习

1. 编写一个简单的函数，并将其声明为`noexcept`。
2. 创建一个类，其移动构造函数和移动赋值运算符都声明为`noexcept`。
3. 使用`noexcept`运算符检查标准库函数（如`std::vector::push_back`）是否声明为不抛出异常。
4. 实现一个模板函数，该函数根据其模板参数的某些属性有条件地声明为`noexcept`。

## 更多资源

- [C++ Reference: noexcept specifier](https://en.cppreference.com/w/cpp/language/noexcept_spec)
- [C++ Reference: noexcept operator](https://en.cppreference.com/w/cpp/language/noexcept)
- C++标准：ISO/IEC 14882:2011，第15.4节
- Effective Modern C++，Item 14：声明noexcept的函数如果不抛出异常

通过掌握`noexcept`说明符，你将能够编写更高效、更可靠的C++代码，这是成为高级C++程序员的重要一步。