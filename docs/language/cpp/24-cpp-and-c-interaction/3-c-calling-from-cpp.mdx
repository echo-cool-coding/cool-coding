---
title: C 从C++调用
description: 学习如何在C++项目中调用C代码，理解extern "C"的使用，以及跨语言交互的最佳实践
---

# C从C++调用

## 引言

在编程世界中，C语言和C++语言是两种密切相关的语言。C++是C语言的超集，在保留C语言大部分特性的同时，增加了面向对象编程、泛型编程等现代编程范式。在实际开发中，有时我们需要在C++项目中调用C代码，这种情况很常见，因为：

- 许多底层库和系统API是用C语言编写的
- 某些性能关键代码可能使用C语言实现以获得更好的性能
- 在维护或扩展旧系统时，可能需要将C++代码与已有的C代码集成

本文将详细介绍如何在C++项目中调用C代码，以及在这个过程中需要注意的问题。

## C++ 与C的主要区别

在深入了解C++调用C代码之前，我们需要先了解C++和C之间的一些关键区别：

1. **名称修饰(Name Mangling)**：C++支持函数重载，编译器通过修改函数名(加入参数类型信息)来区分同名但参数不同的函数，而C不支持这种机制。

2. **类和对象**：C++支持面向对象编程，而C是面向过程的。

3. **异常处理**：C++有内置的异常处理机制，而C通常使用返回值或全局变量来表示错误。

4. **标准库**：C++标准库远比C标准库丰富。

其中，名称修饰是我们在C++调用C代码时需要特别关注的问题。

## extern "C" 的作用

当C++代码调用C函数时，需要告诉C++编译器"这是一个C风格的函数，请不要对其名称进行修饰"。这就是`extern "C"`指令的作用。

### 基本用法

```cpp
// 单个函数声明
extern "C" void c_function();

// 多个函数声明
extern "C" {
    void c_function1();
    void c_function2();
    int c_function3(int a, int b);
}
```

### 工作原理

当编译器遇到`extern "C"`时，它会按照C语言的规则来处理函数的链接，不会进行名称修饰。这样，C++代码就能够成功地链接到C代码中定义的函数。

## 实际使用案例

### 案例1：在C++中调用单个C函数

假设我们有一个C语言编写的数学库，包含一个计算两数之和的函数：

**math_lib.h：**
```c
#ifndef MATH_LIB_H
#define MATH_LIB_H

/* 为了兼容C++，添加条件编译指令 */
#ifdef __cplusplus
extern "C" {
#endif

int add(int a, int b);

#ifdef __cplusplus
}
#endif

#endif /* MATH_LIB_H */
```

**math_lib.c：**
```c
#include "math_lib.h"

int add(int a, int b) {
    return a + b;
}
```

**main.cpp（C++主程序）：**
```cpp
#include <iostream>
#include "math_lib.h"

int main() {
    int result = add(5, 3);
    std::cout << "5 + 3 = " << result << std::endl;
    return 0;
}
```

输出：
```
5 + 3 = 8
```

:::note
注意到在头文件中使用了条件编译指令`#ifdef __cplusplus`，这是因为当该头文件被C++代码包含时，宏`__cplusplus`会被定义，这样就可以根据需要添加`extern "C"`声明。
:::

### 案例2：调用包含多个函数的C库

假设我们有一个更复杂的C库，提供了几个数学运算函数：

**complex_math.h：**
```c
#ifndef COMPLEX_MATH_H
#define COMPLEX_MATH_H

#ifdef __cplusplus
extern "C" {
#endif

int add(int a, int b);
int subtract(int a, int b);
int multiply(int a, int b);
float divide(int a, int b);

#ifdef __cplusplus
}
#endif

#endif /* COMPLEX_MATH_H */
```

**complex_math.c：**
```c
#include "complex_math.h"

int add(int a, int b) {
    return a + b;
}

int subtract(int a, int b) {
    return a - b;
}

int multiply(int a, int b) {
    return a * b;
}

float divide(int a, int b) {
    return (float)a / b;
}
```

**calculator.cpp（C++主程序）：**
```cpp
#include <iostream>
#include "complex_math.h"

int main() {
    int a = 10, b = 5;
    
    std::cout << a << " + " << b << " = " << add(a, b) << std::endl;
    std::cout << a << " - " << b << " = " << subtract(a, b) << std::endl;
    std::cout << a << " * " << b << " = " << multiply(a, b) << std::endl;
    std::cout << a << " / " << b << " = " << divide(a, b) << std::endl;
    
    return 0;
}
```

输出：
```
10 + 5 = 15
10 - 5 = 5
10 * 5 = 50
10 / 5 = 2
```

## 常见问题和解决方案

### 结构体和类型的兼容性

当C++调用C代码时，可能会涉及到结构体的传递。C和C++对结构体的处理有一些不同，因此需要注意：

```c
// C header: person.h
#ifndef PERSON_H
#define PERSON_H

#ifdef __cplusplus
extern "C" {
#endif

typedef struct {
    char name[50];
    int age;
} Person;

void print_person(Person* p);

#ifdef __cplusplus
}
#endif

#endif /* PERSON_H */
```

```c
// C implementation: person.c
#include "person.h"
#include <stdio.h>

void print_person(Person* p) {
    printf("Name: %s, Age: %d\n", p->name, p->age);
}
```

```cpp
// C++ program: main.cpp
#include <iostream>
#include <cstring>
#include "person.h"

int main() {
    Person p;
    strcpy(p.name, "John Doe");
    p.age = 30;
    
    print_person(&p);
    
    return 0;
}
```

输出：
```
Name: John Doe, Age: 30
```

### 函数指针的传递

当需要将C++函数作为回调传递给C函数时，也需要使用`extern "C"`：

```cpp
// C++ program with callback
#include <iostream>

extern "C" void c_function_with_callback(void (*callback)(int));

// C++ callback function that will be passed to C
extern "C" void cpp_callback(int value) {
    std::cout << "Callback received value: " << value << std::endl;
}

int main() {
    c_function_with_callback(cpp_callback);
    return 0;
}
```

## 编译和链接

在实际项目中，C和C++代码通常分开编译，然后在链接阶段合并：

1. 编译C代码：
   ```bash
   gcc -c math_lib.c -o math_lib.o
   ```

2. 编译C++代码：
   ```bash
   g++ -c main.cpp -o main.o
   ```

3. 链接所有目标文件：
   ```bash
   g++ main.o math_lib.o -o program
   ```

:::tip
如果使用CMake，你可以更容易地管理混合C和C++的项目。CMake会自动处理不同语言的编译选项。
:::

## 实际应用场景

在实际工作中，C从C++调用的情况非常常见，以下是几个典型的应用场景：

1. **与操作系统API交互**：很多操作系统API（如POSIX、Windows API）是用C语言编写的。

2. **使用C库**：许多经典和高效的库是用C语言编写的，如SQLite、libpng、zlib等。

3. **嵌入式系统开发**：在资源有限的嵌入式系统中，有时会选择C而非C++来编写部分代码。

4. **跨平台开发**：C语言具有更好的跨平台兼容性，某些平台特定的代码可能用C语言实现。

### 实际案例：使用C语言编写的SQLite库

```cpp
// C++ program using SQLite (a C library)
#include <iostream>
#include <sqlite3.h>

int main() {
    sqlite3* db;
    char* errMsg = nullptr;
    
    // Open database
    int rc = sqlite3_open("test.db", &db);
    
    if (rc) {
        std::cerr << "Error opening SQLite database: " << sqlite3_errmsg(db) << std::endl;
        return 1;
    }
    
    // Execute SQL
    rc = sqlite3_exec(db, "CREATE TABLE IF NOT EXISTS users (id INT, name TEXT)", 
                     nullptr, nullptr, &errMsg);
    
    if (rc != SQLITE_OK) {
        std::cerr << "SQL error: " << errMsg << std::endl;
        sqlite3_free(errMsg);
    } else {
        std::cout << "Table created successfully" << std::endl;
    }
    
    // Close database
    sqlite3_close(db);
    
    return 0;
}
```

编译命令：
```bash
g++ -o sqlite_example sqlite_example.cpp -lsqlite3
```

## 总结

在C++程序中调用C代码是一种常见且有用的做法。通过`extern "C"`指令，我们可以解决C++和C之间名称修饰的差异问题，实现跨语言调用。

关键要点：

1. 使用`extern "C"`来防止C++编译器对C函数进行名称修饰
2. 在头文件中使用条件编译指令`#ifdef __cplusplus`来适配不同语言
3. 注意结构体、函数指针等在C和C++之间的兼容性问题
4. 分别编译C和C++代码，然后在链接阶段合并

通过掌握这些技术，你可以充分利用C语言库的稳定性和效率，同时享受C++语言的灵活性和抽象能力，实现最佳的代码重用和性能优化。

## 练习

1. 编写一个C语言函数，计算一个整数数组的平均值，然后在C++程序中调用这个函数。

2. 创建一个C语言库，实现简单的字符串处理函数（如字符串连接、查找子字符串等），然后在C++程序中使用这些函数。

3. 修改一个现有的C++程序，将其中的一些性能关键部分改写为C函数，并比较改写前后的性能差异。

## 推荐资源

- [C++ Core Guidelines: C.161-C.168](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#c161-use-extern-c-for-c-code)
- [C/C++ 互操作性指南](https://docs.microsoft.com/en-us/cpp/cpp/mixed-language-programming)
- 《C++ Primer》第5版，第19章：特殊工具与技术

掌握C从C++的调用技术，将帮助你在现实世界的混合语言项目中更加得心应手，也为你理解更复杂的跨语言交互打下坚实基础。