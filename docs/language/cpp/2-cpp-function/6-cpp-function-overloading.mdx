---
title: C++ 函数重载
description: 全面介绍C++函数重载的概念、规则、实际应用及注意事项，帮助初学者深入理解这一核心特性。
---

# C++ 函数重载

## 什么是函数重载

函数重载(Function Overloading)是C++的一个重要特性，它允许我们在同一作用域内定义多个**同名函数**，只要这些函数的**参数列表不同**即可。函数重载是C++支持多态性的一种方式，属于编译时多态（静态多态）。

函数重载的核心思想是：**相同的函数名可以对应不同的处理逻辑**，具体执行哪个逻辑由传入的参数类型和数量决定。

:::note 名词解释
**多态性**是面向对象编程的重要概念，意味着同一操作可以应用于不同类型的对象，产生不同的效果。
:::

## 函数重载的条件

要实现函数重载，必须满足以下条件之一：

1. 参数数量不同
2. 参数类型不同
3. 参数顺序不同

需要注意的是，**仅返回值类型不同**是不足以构成函数重载的。

```cpp
// 合法的函数重载示例
void print(int num);           // 参数类型为整数
void print(double num);        // 参数类型为浮点数
void print(char* str);         // 参数类型为字符串
void print(int a, double b);   // 参数数量不同
void print(double a, int b);   // 参数顺序不同

// 非法的函数重载 - 编译错误
int print(int num);            // 仅返回值类型不同，与第一个函数冲突
```

## 函数重载的工作原理

当我们调用一个重载函数时，编译器会根据调用时提供的参数类型和数量来选择最匹配的函数版本。这个过程称为函数重载解析（function overload resolution）。

```cpp
#include <iostream>
using namespace std;

// 定义三个重载的print函数
void print(int i) {
    cout << "打印整数: " << i << endl;
}

void print(double f) {
    cout << "打印浮点数: " << f << endl;
}

void print(const char* s) {
    cout << "打印字符串: " << s << endl;
}

int main() {
    print(10);           // 调用 print(int)
    print(10.5);         // 调用 print(double)
    print("Hello");      // 调用 print(const char*)
    return 0;
}
```

输出结果：
```
打印整数: 10
打印浮点数: 10.5
打印字符串: Hello
```

## 函数重载的匹配规则

当调用重载函数时，编译器按照以下步骤来确定使用哪个函数：

1. **精确匹配**：寻找参数类型完全匹配的函数
2. **类型提升**：例如 `char` 可提升为 `int`
3. **标准转换**：例如 `int` 可转换为 `double`
4. **用户自定义转换**：通过转换构造函数或转换运算符进行的转换
5. **可变参数函数**：匹配接受可变数量参数的函数

如果在某一步骤中找到多个匹配函数，则编译器会报告"二义性调用"错误。

```cpp
#include <iostream>
using namespace std;

void display(int i) {
    cout << "整数: " << i << endl;
}

void display(double d) {
    cout << "浮点数: " << d << endl;
}

int main() {
    short s = 42;
    display(s);  // short 提升为 int，调用 display(int)
    
    float f = 3.14f;
    display(f);  // float 标准转换为 double，调用 display(double)
    
    return 0;
}
```

输出结果：
```
整数: 42
浮点数: 3.14
```

## 函数重载的实用案例

### 案例1: 数学计算函数

函数重载可以让我们为不同数据类型提供相同名称的操作：

```cpp
#include <iostream>
using namespace std;

// 计算两个整数的最大值
int findMax(int a, int b) {
    return (a > b) ? a : b;
}

// 计算两个浮点数的最大值
double findMax(double a, double b) {
    return (a > b) ? a : b;
}

// 计算三个整数的最大值
int findMax(int a, int b, int c) {
    return findMax(findMax(a, b), c);  // 复用上面的函数
}

int main() {
    cout << "Max(10, 20): " << findMax(10, 20) << endl;
    cout << "Max(3.5, 7.8): " << findMax(3.5, 7.8) << endl;
    cout << "Max(5, 9, 3): " << findMax(5, 9, 3) << endl;
    return 0;
}
```

输出结果：
```
Max(10, 20): 20
Max(3.5, 7.8): 7.8
Max(5, 9, 3): 9
```

### 案例2: 构造函数重载

构造函数重载是C++中使用重载最常见的场景之一，它允许我们以不同的方式初始化对象：

```cpp
#include <iostream>
#include <string>
using namespace std;

class Student {
private:
    int id;
    string name;
    double score;

public:
    // 默认构造函数
    Student() {
        id = 0;
        name = "未知";
        score = 0.0;
    }
    
    // 带一个参数的构造函数
    Student(int studentId) {
        id = studentId;
        name = "未知";
        score = 0.0;
    }
    
    // 带两个参数的构造函数
    Student(int studentId, string studentName) {
        id = studentId;
        name = studentName;
        score = 0.0;
    }
    
    // 带三个参数的构造函数
    Student(int studentId, string studentName, double studentScore) {
        id = studentId;
        name = studentName;
        score = studentScore;
    }
    
    // 显示学生信息
    void display() {
        cout << "学号: " << id << ", 姓名: " << name
             << ", 成绩: " << score << endl;
    }
};

int main() {
    Student s1;                         // 使用默认构造函数
    Student s2(1001);                   // 只指定学号
    Student s3(1002, "张三");           // 指定学号和姓名
    Student s4(1003, "李四", 92.5);     // 指定所有信息
    
    cout << "学生1信息: ";
    s1.display();
    
    cout << "学生2信息: ";
    s2.display();
    
    cout << "学生3信息: ";
    s3.display();
    
    cout << "学生4信息: ";
    s4.display();
    
    return 0;
}
```

输出结果：
```
学生1信息: 学号: 0, 姓名: 未知, 成绩: 0
学生2信息: 学号: 1001, 姓名: 未知, 成绩: 0
学生3信息: 学号: 1002, 姓名: 张三, 成绩: 0
学生4信息: 学号: 1003, 姓名: 李四, 成绩: 92.5
```

## 函数重载的常见问题和注意事项

### 1. 默认参数与函数重载

默认参数可能会导致函数调用的二义性：

```cpp
#include <iostream>
using namespace std;

void show(int a, int b = 20) {
    cout << "a = " << a << ", b = " << b << endl;
}

void show(int a) {
    cout << "a = " << a << endl;
}

int main() {
    show(10);  // 调用哪个函数？这会导致编译错误！
    return 0;
}
```

上面的代码会导致编译错误，因为编译器无法确定应该调用哪个`show`函数。

### 2. 类型限定符与函数重载

`const`和引用也会影响函数重载：

```cpp
#include <iostream>
using namespace std;

void process(int& n) {
    cout << "处理非常量引用: " << n << endl;
    n++;  // 可以修改
}

void process(const int& n) {
    cout << "处理常量引用: " << n << endl;
    // n++; // 错误！不能修改常量
}

int main() {
    int x = 10;
    const int y = 20;
    
    process(x);  // 调用 process(int&)
    process(y);  // 调用 process(const int&)
    
    cout << "x变为: " << x << endl;
    
    return 0;
}
```

输出结果：
```
处理非常量引用: 10
处理常量引用: 20
x变为: 11
```

### 3. 函数重载与类型转换

编译器在选择重载函数时可能会应用类型转换，这有时会导致意外结果：

```cpp
#include <iostream>
using namespace std;

void func(int i) {
    cout << "整数版本: " << i << endl;
}

void func(char* str) {
    cout << "字符串版本: " << str << endl;
}

int main() {
    func(10);        // 调用 func(int)
    func("Hello");   // 调用 func(char*)
    
    // 但这种情况要小心
    func(NULL);      // 在一些编译器中，可能调用 func(int)
    
    // C++11以后推荐使用nullptr避免此问题
    func(nullptr);   // 调用 func(char*)
    
    return 0;
}
```

:::warning 注意
在C++11之前，`NULL`通常被定义为`0`，这会导致调用`func(int)`而非`func(char*)`。C++11引入了`nullptr`关键字来解决这个问题。
:::

## 函数重载与函数模板的对比

函数重载解决了为不同参数类型创建类似函数的问题，但为每种类型写一个函数版本可能会导致代码重复。C++的函数模板提供了一个更通用的解决方案：

```cpp
#include <iostream>
using namespace std;

// 使用函数重载
int max(int a, int b) {
    return (a > b) ? a : b;
}

double max(double a, double b) {
    return (a > b) ? a : b;
}

// 使用函数模板
template<typename T>
T templateMax(T a, T b) {
    return (a > b) ? a : b;
}

int main() {
    cout << "使用函数重载:" << endl;
    cout << "max(5, 9) = " << max(5, 9) << endl;
    cout << "max(3.7, 2.5) = " << max(3.7, 2.5) << endl;
    
    cout << "\n使用函数模板:" << endl;
    cout << "templateMax(5, 9) = " << templateMax(5, 9) << endl;
    cout << "templateMax(3.7, 2.5) = " << templateMax(3.7, 2.5) << endl;
    
    return 0;
}
```

输出结果：
```
使用函数重载:
max(5, 9) = 9
max(3.7, 2.5) = 3.7

使用函数模板:
templateMax(5, 9) = 9
templateMax(3.7, 2.5) = 3.7
```

:::tip 提示
函数模板可以减少代码重复，但函数重载在需要针对不同类型实现不同逻辑时仍然非常有用。
:::

## 总结

函数重载是C++中一个强大的特性，通过它我们可以：

1. 使用同一个函数名来处理不同类型或数量的参数
2. 提高代码的可读性和一致性
3. 实现编译时多态

正确使用函数重载需要记住以下关键点：
- 重载函数必须有不同的参数列表（类型、数量或顺序不同）
- 仅返回类型不同不构成重载
- 默认参数可能导致调用二义性
- 注意类型转换可能影响重载函数的选择

## 练习题

1. 编写一个名为`area`的函数组，分别计算正方形（一个参数：边长）、长方形（两个参数：长和宽）和圆形（一个参数：半径）的面积。

2. 为一个简单的`Calculator`类设计构造函数和多个重载的`calculate`方法，使其能够执行加、减、乘、除等不同运算。

3. 思考并实现一个字符串处理函数`format`，它可以接受不同类型和数量的参数，并返回格式化后的字符串。

## 扩展阅读

- C++标准库中大量使用了函数重载，例如`std::max`、`std::min`等
- 运算符重载是函数重载的一种特殊形式
- 虚函数可以与重载结合使用，但要注意它们的区别：重载是静态多态，而虚函数是动态多态