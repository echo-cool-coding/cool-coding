---
title: C 语言线程局部存储
description: 了解C语言中的线程局部存储（Thread Local Storage, TLS），掌握如何在不同线程中创建和使用独立的变量副本。
---

## 介绍

在多线程编程中，线程局部存储（Thread Local Storage, TLS）是一种允许每个线程拥有独立变量副本的机制。这意味着每个线程可以访问自己的变量副本，而不会与其他线程的副本发生冲突。TLS 在多线程环境中非常有用，尤其是在需要为每个线程维护独立状态时。

在C语言中，TLS 是通过关键字 `_Thread_local` 或 `thread_local`（C11标准引入）来实现的。使用 TLS 可以避免全局变量在多线程环境中的竞争条件问题。

## 基本语法

在C语言中，声明一个线程局部变量非常简单。你只需要在变量声明前加上 `_Thread_local` 关键字即可：

```c
#include <stdio.h>
#include <threads.h>

_Thread_local int thread_local_var = 0;

void print_thread_local_var() {
    printf("Thread ID: %ld, thread_local_var: %d\n", thrd_current(), thread_local_var);
}

int thread_func(void *arg) {
    thread_local_var = *(int *)arg;
    print_thread_local_var();
    return 0;
}

int main() {
    thrd_t thread1, thread2;
    int arg1 = 10, arg2 = 20;

    thrd_create(&thread1, thread_func, &arg1);
    thrd_create(&thread2, thread_func, &arg2);

    thrd_join(thread1, NULL);
    thrd_join(thread2, NULL);

    return 0;
}
```

### 代码解释

1. `_Thread_local int thread_local_var = 0;`：声明了一个线程局部变量 `thread_local_var`，每个线程都会有自己的副本。
2. `print_thread_local_var()`：打印当前线程的ID和 `thread_local_var` 的值。
3. `thread_func()`：每个线程执行的函数，将传入的参数赋值给 `thread_local_var`，然后打印该变量的值。
4. `main()`：创建两个线程，分别传入不同的参数，并等待线程执行完毕。

### 输出示例

```
Thread ID: 1, thread_local_var: 10
Thread ID: 2, thread_local_var: 20
```

从输出中可以看到，每个线程都有自己的 `thread_local_var` 副本，并且它们的值互不影响。

## 实际应用场景

### 场景1：线程特定的日志记录

在多线程应用程序中，每个线程可能需要记录自己的日志信息。使用线程局部存储可以为每个线程分配一个独立的日志缓冲区，避免线程之间的日志信息混淆。

```c
#include <stdio.h>
#include <threads.h>

_Thread_local char log_buffer[256];

void log_message(const char *message) {
    snprintf(log_buffer, sizeof(log_buffer), "Thread %ld: %s", thrd_current(), message);
    printf("%s\n", log_buffer);
}

int thread_func(void *arg) {
    log_message("This is a log message.");
    return 0;
}

int main() {
    thrd_t thread1, thread2;

    thrd_create(&thread1, thread_func, NULL);
    thrd_create(&thread2, thread_func, NULL);

    thrd_join(thread1, NULL);
    thrd_join(thread2, NULL);

    return 0;
}
```

### 输出示例

```
Thread 1: This is a log message.
Thread 2: This is a log message.
```

### 场景2：线程特定的计数器

在某些情况下，每个线程可能需要维护一个独立的计数器。使用线程局部存储可以轻松实现这一点。

```c
#include <stdio.h>
#include <threads.h>

_Thread_local int counter = 0;

void increment_counter() {
    counter++;
    printf("Thread %ld: counter = %d\n", thrd_current(), counter);
}

int thread_func(void *arg) {
    for (int i = 0; i < 5; i++) {
        increment_counter();
    }
    return 0;
}

int main() {
    thrd_t thread1, thread2;

    thrd_create(&thread1, thread_func, NULL);
    thrd_create(&thread2, thread_func, NULL);

    thrd_join(thread1, NULL);
    thrd_join(thread2, NULL);

    return 0;
}
```

### 输出示例

```
Thread 1: counter = 1
Thread 1: counter = 2
Thread 1: counter = 3
Thread 1: counter = 4
Thread 1: counter = 5
Thread 2: counter = 1
Thread 2: counter = 2
Thread 2: counter = 3
Thread 2: counter = 4
Thread 2: counter = 5
```

## 总结

线程局部存储（TLS）是C语言中处理多线程编程时非常有用的工具。它允许每个线程拥有自己的变量副本，从而避免了全局变量在多线程环境中的竞争条件问题。通过 `_Thread_local` 关键字，你可以轻松声明线程局部变量，并在实际应用中实现线程特定的状态管理。

## 附加资源

- [C11标准文档](https://www.open-std.org/jtc1/sc22/wg14/www/docs/n1570.pdf)：了解C11标准中关于线程局部存储的详细说明。
- [多线程编程指南](https://en.cppreference.com/w/c/thread)：进一步学习C语言中的多线程编程。

## 练习

1. 修改上面的计数器示例，使得每个线程的计数器从不同的初始值开始。
2. 尝试在一个线程中修改另一个线程的线程局部变量，观察会发生什么。
3. 实现一个线程安全的日志系统，使用线程局部存储来避免日志信息的混淆。

:::tip
在实际开发中，合理使用线程局部存储可以显著提高多线程程序的稳定性和可维护性。确保在需要时为每个线程分配独立的资源。
:::