---
title: C 语言进程创建
description: 本教程将详细介绍如何在C语言中创建进程，包括fork()函数的使用、父子进程的关系以及实际应用场景。
---

# C 语言进程创建

在操作系统中，进程是程序执行的基本单位。C语言提供了强大的系统编程能力，允许我们通过系统调用创建和管理进程。本文将详细介绍如何在C语言中创建进程，并通过代码示例和实际案例帮助你理解这一概念。

## 什么是进程？

进程是正在运行的程序的实例。每个进程都有自己的内存空间、文件描述符和环境变量。操作系统通过进程调度器管理多个进程的执行，确保它们能够高效地共享CPU资源。

在C语言中，我们可以使用系统调用 `fork()` 来创建一个新的进程。`fork()` 会创建一个与当前进程几乎完全相同的子进程。子进程从 `fork()` 调用处开始执行，并且拥有与父进程相同的内存内容。

## fork() 函数

`fork()` 是C语言中用于创建进程的系统调用。它的原型如下：

```c
#include <unistd.h>

pid_t fork(void);
```

`fork()` 函数没有参数，返回一个 `pid_t` 类型的值。返回值有以下几种情况：

- **返回值 > 0**：在父进程中，`fork()` 返回子进程的进程ID（PID）。
- **返回值 == 0**：在子进程中，`fork()` 返回0。
- **返回值 == -1**：如果创建进程失败，`fork()` 返回-1，并设置 `errno` 以指示错误原因。

### 代码示例

以下是一个简单的 `fork()` 示例：

```c
#include <stdio.h>
#include <unistd.h>

int main() {
    pid_t pid = fork();

    if (pid == 0) {
        // 子进程
        printf("这是子进程，PID: %d\n", getpid());
    } else if (pid > 0) {
        // 父进程
        printf("这是父进程，PID: %d, 子进程PID: %d\n", getpid(), pid);
    } else {
        // fork失败
        perror("fork失败");
        return 1;
    }

    return 0;
}
```

### 输出示例

运行上述代码，你可能会看到类似以下的输出：

```
这是父进程，PID: 1234, 子进程PID: 1235
这是子进程，PID: 1235
```

:::note
注意：父进程和子进程的执行顺序是不确定的，取决于操作系统的调度策略。
:::

## 父子进程的关系

当 `fork()` 成功创建子进程后，父子进程之间的关系如下：

- **共享代码段**：父子进程共享相同的代码段。
- **独立的数据段**：虽然父子进程在 `fork()` 时拥有相同的内存内容，但它们的内存空间是独立的。修改一个进程的内存不会影响另一个进程。
- **独立的执行流**：父子进程从 `fork()` 调用处开始独立执行，各自拥有自己的程序计数器（PC）和栈。

### 内存共享与写时复制（Copy-On-Write）

在 `fork()` 之后，父子进程共享相同的内存内容。为了提高效率，操作系统通常使用**写时复制**（Copy-On-Write, COW）技术。这意味着只有在某个进程尝试修改内存时，操作系统才会为该进程复制一份新的内存副本。

## 实际应用场景

### 1. 并行任务处理

通过创建多个子进程，可以实现并行处理任务。例如，一个Web服务器可以创建多个子进程来处理不同的客户端请求。

```c
#include <stdio.h>
#include <unistd.h>

void handle_client(int client_id) {
    printf("处理客户端 %d 的请求\n", client_id);
    sleep(2); // 模拟处理时间
    printf("客户端 %d 的请求处理完成\n", client_id);
}

int main() {
    for (int i = 0; i < 5; i++) {
        pid_t pid = fork();
        if (pid == 0) {
            // 子进程处理客户端请求
            handle_client(i);
            return 0; // 子进程完成任务后退出
        } else if (pid < 0) {
            perror("fork失败");
            return 1;
        }
    }

    // 父进程等待所有子进程完成
    for (int i = 0; i < 5; i++) {
        wait(NULL);
    }

    printf("所有客户端请求处理完成\n");
    return 0;
}
```

### 2. 守护进程

守护进程是在后台运行的进程，通常用于执行系统任务。通过 `fork()` 和 `setsid()` 系统调用，可以创建一个守护进程。

```c
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/stat.h>

void create_daemon() {
    pid_t pid = fork();

    if (pid < 0) {
        perror("fork失败");
        exit(1);
    }

    if (pid > 0) {
        // 父进程退出
        exit(0);
    }

    // 子进程成为守护进程
    setsid();
    chdir("/");
    umask(0);

    // 守护进程的任务
    while (1) {
        // 执行守护进程的任务
        sleep(1);
    }
}

int main() {
    create_daemon();
    return 0;
}
```

## 总结

通过 `fork()` 系统调用，我们可以在C语言中创建新的进程。父子进程共享代码段，但拥有独立的数据段和执行流。`fork()` 在并行任务处理、守护进程创建等场景中有着广泛的应用。

:::tip
提示：在使用 `fork()` 时，务必注意父子进程的资源管理和同步问题，避免出现资源泄漏或竞争条件。
:::

## 附加资源与练习

- **练习1**：修改第一个代码示例，使父进程等待子进程完成后再退出。
- **练习2**：编写一个程序，创建多个子进程，每个子进程计算一个数的阶乘，并将结果返回给父进程。

通过实践这些练习，你将更深入地理解C语言中的进程创建与管理。