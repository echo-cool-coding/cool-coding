---
title: C 语言errno变量
description: 了解C语言中的errno变量，掌握如何使用它进行错误处理，并通过实际案例加深理解。
---

# C 语言errno变量

在C语言编程中，错误处理是一个非常重要的部分。`errno` 是一个全局变量，用于存储最近一次函数调用产生的错误代码。通过检查 `errno`，程序员可以确定函数调用是否成功，并在出现错误时采取相应的措施。

## 什么是errno？

`errno` 是一个定义在 `<errno.h>` 头文件中的全局变量，用于存储最近一次函数调用产生的错误代码。当某个库函数调用失败时，它会设置 `errno` 为一个特定的值，以指示错误的类型。通过检查 `errno`，程序员可以了解发生了什么错误，并采取适当的措施。

:::note
`errno` 是一个线程安全的变量，每个线程都有自己的 `errno` 实例。
:::

## 如何使用errno？

要使用 `errno`，首先需要包含 `<errno.h>` 头文件。然后，在调用可能失败的函数后，检查 `errno` 的值。如果 `errno` 不为零，则表示发生了错误。

### 示例代码

以下是一个简单的示例，展示了如何使用 `errno` 来检测文件打开错误：

```c
#include <stdio.h>
#include <errno.h>

int main() {
    FILE *file = fopen("nonexistent_file.txt", "r");
    if (file == NULL) {
        perror("Error opening file");
        printf("errno: %d\n", errno);
    } else {
        fclose(file);
    }
    return 0;
}
```

### 输入与输出

假设文件 `nonexistent_file.txt` 不存在，程序将输出：

```
Error opening file: No such file or directory
errno: 2
```

在这个例子中，`fopen` 函数尝试打开一个不存在的文件，因此返回 `NULL` 并设置 `errno` 为 `ENOENT`（错误代码 2），表示“没有这样的文件或目录”。

## errno的常见错误代码

`errno` 可以设置为许多不同的错误代码，每个代码对应一种特定的错误类型。以下是一些常见的 `errno` 错误代码：

- `EACCES` (13): 权限被拒绝
- `EAGAIN` (11): 资源暂时不可用
- `EBADF` (9): 错误的文件描述符
- `EDOM` (33): 数学参数超出函数定义域
- `EINVAL` (22): 无效的参数
- `ENOENT` (2): 没有这样的文件或目录
- `ENOMEM` (12): 内存不足
- `ERANGE` (34): 结果超出范围

:::tip
可以使用 `strerror` 函数将 `errno` 的错误代码转换为可读的错误消息。
:::

### 使用strerror的示例

```c
#include <stdio.h>
#include <errno.h>
#include <string.h>

int main() {
    FILE *file = fopen("nonexistent_file.txt", "r");
    if (file == NULL) {
        printf("Error: %s\n", strerror(errno));
    } else {
        fclose(file);
    }
    return 0;
}
```

输出：

```
Error: No such file or directory
```

## 实际应用场景

在实际编程中，`errno` 常用于处理文件操作、内存分配、数学计算等可能失败的函数调用。以下是一个实际应用场景的示例：

### 文件复制程序

```c
#include <stdio.h>
#include <errno.h>
#include <string.h>

int main() {
    FILE *src = fopen("source.txt", "r");
    if (src == NULL) {
        printf("Error opening source file: %s\n", strerror(errno));
        return 1;
    }

    FILE *dest = fopen("destination.txt", "w");
    if (dest == NULL) {
        printf("Error opening destination file: %s\n", strerror(errno));
        fclose(src);
        return 1;
    }

    char buffer[1024];
    while (fgets(buffer, sizeof(buffer), src) != NULL) {
        if (fputs(buffer, dest) == EOF) {
            printf("Error writing to destination file: %s\n", strerror(errno));
            fclose(src);
            fclose(dest);
            return 1;
        }
    }

    fclose(src);
    fclose(dest);
    printf("File copied successfully.\n");
    return 0;
}
```

在这个例子中，程序尝试打开源文件和目标文件。如果任何一个文件打开失败，程序会输出错误消息并退出。如果文件成功打开，程序会逐行读取源文件的内容并写入目标文件。如果在写入过程中发生错误，程序会输出错误消息并退出。

## 总结

`errno` 是C语言中用于错误处理的重要工具。通过检查 `errno`，程序员可以确定函数调用是否成功，并在出现错误时采取适当的措施。在实际编程中，`errno` 常用于处理文件操作、内存分配、数学计算等可能失败的函数调用。

:::caution
在使用 `errno` 时，务必在函数调用后立即检查其值，因为某些库函数可能会在成功时重置 `errno`。
:::

## 附加资源与练习

- **练习1**: 编写一个程序，尝试打开一个文件并读取其内容。如果文件打开失败，输出错误消息并退出。
- **练习2**: 修改上述文件复制程序，使其在复制过程中检查 `errno` 并处理可能的错误。
- **参考资源**: 
  - [C标准库文档](https://en.cppreference.com/w/c)
  - [GNU C Library文档](https://www.gnu.org/software/libc/manual/)

通过学习和实践，你将能够更好地理解和使用 `errno` 来处理C语言中的错误。