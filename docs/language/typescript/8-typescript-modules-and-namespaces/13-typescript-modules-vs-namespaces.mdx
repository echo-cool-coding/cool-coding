---
title: TypeScript 模块与命名空间对比
description: 了解 TypeScript 中模块与命名空间的区别、使用场景以及如何在实际项目中应用它们。
---

## 介绍

在 TypeScript 中，**模块**和**命名空间**是两种用于组织代码的机制。它们的主要目的是避免全局作用域中的命名冲突，并帮助开发者更好地管理代码结构。虽然它们的目标相似，但它们的实现方式和适用场景有所不同。本文将详细对比这两种机制，并通过示例展示它们的实际应用。

---

## 模块（Modules）

### 什么是模块？

模块是 TypeScript 中组织代码的主要方式。每个模块都是一个独立的文件，模块中的代码默认是私有的，除非显式导出（`export`）。通过导入（`import`）其他模块，可以在当前模块中使用它们的功能。

模块系统是 TypeScript 推荐的方式，尤其是在现代 JavaScript 项目中，模块化是标准实践。

### 模块的基本用法

以下是一个简单的模块示例：

```typescript
// math.ts
export function add(a: number, b: number): number {
  return a + b;
}

export function subtract(a: number, b: number): number {
  return a - b;
}
```

在另一个文件中导入并使用该模块：

```typescript
// app.ts
import { add, subtract } from './math';

console.log(add(5, 3)); // 输出: 8
console.log(subtract(5, 3)); // 输出: 2
```

:::note
模块的路径可以是相对路径（如 `./math`）或绝对路径（如 `src/math`），具体取决于项目的配置。
:::

### 模块的优势

1. **封装性**：模块中的代码默认是私有的，只有显式导出的部分才能被外部访问。
2. **可复用性**：模块可以被多个文件导入，便于代码复用。
3. **依赖管理**：模块系统支持明确的依赖关系，便于构建工具（如 Webpack、Rollup）进行打包和优化。

---

## 命名空间（Namespaces）

### 什么是命名空间？

命名空间是 TypeScript 早期引入的一种代码组织方式，用于在全局作用域中避免命名冲突。命名空间通过将代码包裹在一个命名空间内，来限制其作用域。

### 命名空间的基本用法

以下是一个简单的命名空间示例：

```typescript
// math.ts
namespace MathUtils {
  export function add(a: number, b: number): number {
    return a + b;
  }

  export function subtract(a: number, b: number): number {
    return a - b;
  }
}
```

在另一个文件中使用该命名空间：

```typescript
// app.ts
/// <reference path="math.ts" />

console.log(MathUtils.add(5, 3)); // 输出: 8
console.log(MathUtils.subtract(5, 3)); // 输出: 2
```

:::caution
命名空间的使用需要显式引用文件（如 `/// <reference path="math.ts" />`），这种方式在现代项目中已不常见。
:::

### 命名空间的局限性

1. **全局污染**：命名空间仍然存在于全局作用域中，容易导致命名冲突。
2. **依赖管理困难**：命名空间不支持现代模块系统的依赖管理机制。
3. **不推荐使用**：在现代 TypeScript 项目中，命名空间已被模块系统取代。

---

## 模块与命名空间的对比

| 特性               | 模块（Modules）                     | 命名空间（Namespaces）             |
|--------------------|-------------------------------------|------------------------------------|
| **作用域**         | 文件级别，默认私有                 | 全局作用域，需显式导出             |
| **依赖管理**       | 支持明确的依赖关系                 | 依赖管理困难                       |
| **适用场景**       | 现代 JavaScript/TypeScript 项目    | 旧版 TypeScript 项目或遗留代码     |
| **推荐程度**       | 推荐使用                           | 不推荐使用                         |

---

## 实际应用场景

### 模块的应用

在现代前端框架（如 React、Vue）中，模块是组织代码的主要方式。例如：

```typescript
// components/Button.tsx
import React from 'react';

export function Button({ label }: { label: string }) {
  return <button>{label}</button>;
}
```

```typescript
// App.tsx
import { Button } from './components/Button';

function App() {
  return <Button label="Click Me" />;
}
```

### 命名空间的应用

命名空间通常用于旧版 TypeScript 项目或需要与全局脚本兼容的场景。例如：

```typescript
// legacy/math.ts
namespace LegacyMath {
  export function add(a: number, b: number): number {
    return a + b;
  }
}
```

```typescript
// legacy/app.ts
/// <reference path="math.ts" />

console.log(LegacyMath.add(5, 3)); // 输出: 8
```

---

## 总结

- **模块**是现代 TypeScript 项目中组织代码的首选方式，具有封装性、可复用性和明确的依赖管理。
- **命名空间**适用于旧版项目或需要与全局脚本兼容的场景，但在现代项目中已不推荐使用。

:::tip
如果你正在开发一个新项目，建议始终使用模块系统来组织代码。
:::

---

## 附加资源与练习

### 资源
- [TypeScript 官方文档 - 模块](https://www.typescriptlang.org/docs/handbook/modules.html)
- [TypeScript 官方文档 - 命名空间](https://www.typescriptlang.org/docs/handbook/namespaces.html)

### 练习
1. 创建一个模块 `utils.ts`，导出一些实用函数（如 `capitalize`、`reverseString`），并在另一个文件中导入并使用它们。
2. 尝试将上述模块转换为命名空间，并比较两种方式的优缺点。

通过实践，你将更好地理解模块与命名空间的区别及其适用场景。