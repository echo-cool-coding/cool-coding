---
title: TypeScript 工厂模式
description: 了解 TypeScript 中的工厂模式，掌握如何通过工厂模式创建对象，提升代码的可维护性和灵活性。
---

# TypeScript 工厂模式

工厂模式是一种创建型设计模式，它提供了一种创建对象的方式，而无需指定具体的类。通过使用工厂模式，我们可以将对象的创建逻辑与使用逻辑分离，从而使代码更加灵活和可维护。

## 什么是工厂模式？

工厂模式的核心思想是将对象的创建过程封装在一个工厂类中。客户端代码只需要与工厂类交互，而不需要直接实例化具体的类。这样做的优点是：

1. **解耦**：客户端代码与具体类解耦，减少了代码的依赖性。
2. **可扩展性**：添加新的产品类时，只需修改工厂类，而不需要修改客户端代码。
3. **代码复用**：将创建逻辑集中在一个地方，便于复用。

## 工厂模式的类型

工厂模式通常分为三种类型：

1. **简单工厂模式**：一个工厂类负责创建所有产品。
2. **工厂方法模式**：每个产品都有一个对应的工厂类。
3. **抽象工厂模式**：提供一个接口，用于创建一系列相关或依赖的对象。

在本文中，我们将重点介绍**简单工厂模式**和**工厂方法模式**。

## 简单工厂模式

简单工厂模式是最基础的工厂模式，它通过一个工厂类来创建所有产品。让我们通过一个例子来理解这个概念。

### 示例：创建不同类型的按钮

假设我们有一个应用程序，需要创建不同类型的按钮，例如 `PrimaryButton` 和 `SecondaryButton`。我们可以使用简单工厂模式来实现这一点。

```typescript
// 定义按钮接口
interface Button {
  render(): void;
}

// 具体按钮类
class PrimaryButton implements Button {
  render() {
    console.log("Rendering Primary Button");
  }
}

class SecondaryButton implements Button {
  render() {
    console.log("Rendering Secondary Button");
  }
}

// 简单工厂类
class ButtonFactory {
  static createButton(type: string): Button {
    switch (type) {
      case "primary":
        return new PrimaryButton();
      case "secondary":
        return new SecondaryButton();
      default:
        throw new Error("Invalid button type");
    }
  }
}

// 客户端代码
const primaryButton = ButtonFactory.createButton("primary");
primaryButton.render(); // 输出: Rendering Primary Button

const secondaryButton = ButtonFactory.createButton("secondary");
secondaryButton.render(); // 输出: Rendering Secondary Button
```

在这个例子中，`ButtonFactory` 是一个简单工厂类，它根据传入的类型创建不同的按钮对象。客户端代码只需要调用 `ButtonFactory.createButton` 方法，而不需要关心具体的按钮类。

:::note
简单工厂模式的缺点是，当需要添加新的产品类时，必须修改工厂类的代码，这违反了开闭原则。
:::

## 工厂方法模式

工厂方法模式通过定义一个创建对象的接口，但让子类决定实例化哪个类。这样，工厂方法模式将对象的创建延迟到子类。

### 示例：创建不同类型的对话框

假设我们有一个应用程序，需要创建不同类型的对话框，例如 `WindowsDialog` 和 `WebDialog`。我们可以使用工厂方法模式来实现这一点。

```typescript
// 定义对话框接口
interface Dialog {
  render(): void;
}

// 具体对话框类
class WindowsDialog implements Dialog {
  render() {
    console.log("Rendering Windows Dialog");
  }
}

class WebDialog implements Dialog {
  render() {
    console.log("Rendering Web Dialog");
  }
}

// 抽象工厂类
abstract class DialogFactory {
  abstract createDialog(): Dialog;

  renderDialog() {
    const dialog = this.createDialog();
    dialog.render();
  }
}

// 具体工厂类
class WindowsDialogFactory extends DialogFactory {
  createDialog(): Dialog {
    return new WindowsDialog();
  }
}

class WebDialogFactory extends DialogFactory {
  createDialog(): Dialog {
    return new WebDialog();
  }
}

// 客户端代码
const windowsDialogFactory = new WindowsDialogFactory();
windowsDialogFactory.renderDialog(); // 输出: Rendering Windows Dialog

const webDialogFactory = new WebDialogFactory();
webDialogFactory.renderDialog(); // 输出: Rendering Web Dialog
```

在这个例子中，`DialogFactory` 是一个抽象工厂类，它定义了一个 `createDialog` 方法，具体的工厂类（如 `WindowsDialogFactory` 和 `WebDialogFactory`）负责实现这个方法并创建具体的对话框对象。

:::tip
工厂方法模式的优点是，它遵循了开闭原则。当需要添加新的产品类时，只需添加新的工厂类，而不需要修改现有的代码。
:::

## 实际应用场景

工厂模式在实际开发中有广泛的应用，以下是一些常见的场景：

1. **UI 组件库**：在 UI 组件库中，工厂模式可以用于创建不同类型的按钮、对话框、表单等组件。
2. **数据库连接**：在数据库连接池中，工厂模式可以用于创建不同类型的数据库连接对象。
3. **日志系统**：在日志系统中，工厂模式可以用于创建不同类型的日志记录器（如文件日志、控制台日志等）。

## 总结

工厂模式是一种强大的设计模式，它可以帮助我们更好地管理对象的创建过程。通过使用工厂模式，我们可以将对象的创建逻辑与使用逻辑分离，从而使代码更加灵活和可维护。

- **简单工厂模式**：适用于产品类较少且不经常变化的场景。
- **工厂方法模式**：适用于产品类较多且需要频繁扩展的场景。

## 附加资源与练习

- **练习**：尝试实现一个工厂模式，用于创建不同类型的通知（如 `EmailNotification` 和 `SMSNotification`）。
- **资源**：阅读《设计模式：可复用面向对象软件的基础》一书，了解更多关于工厂模式和其他设计模式的内容。

希望这篇文章能帮助你理解 TypeScript 中的工厂模式，并在实际项目中应用它！