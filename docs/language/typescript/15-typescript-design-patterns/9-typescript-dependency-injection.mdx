---
title: TypeScript 依赖注入
description: 了解如何在TypeScript中使用依赖注入模式，提升代码的可维护性和可测试性。
---

# TypeScript 依赖注入

依赖注入（Dependency Injection，简称DI）是一种设计模式，它允许我们将对象的依赖关系从对象内部移到外部。通过这种方式，我们可以更容易地管理依赖关系，提升代码的可维护性和可测试性。在TypeScript中，依赖注入通常用于构建松耦合的应用程序。

## 什么是依赖注入？

依赖注入的核心思想是将对象的创建和依赖关系的管理交给外部容器或框架来处理，而不是在对象内部直接创建依赖。这样做的好处是：

1. **松耦合**：对象不再直接依赖于具体的实现，而是依赖于抽象接口。
2. **可测试性**：通过注入模拟对象，可以更容易地进行单元测试。
3. **可维护性**：依赖关系的管理集中化，便于修改和扩展。

## 依赖注入的基本概念

在依赖注入中，通常有三个主要角色：

1. **服务（Service）**：提供具体功能的类或对象。
2. **客户端（Client）**：使用服务的类或对象。
3. **注入器（Injector）**：负责创建服务并将其注入到客户端中。

### 示例：简单的依赖注入

让我们通过一个简单的例子来理解依赖注入的工作原理。

```typescript
// 定义一个服务接口
interface Logger {
  log(message: string): void;
}

// 实现一个具体的服务
class ConsoleLogger implements Logger {
  log(message: string): void {
    console.log(message);
  }
}

// 客户端类，依赖于Logger接口
class App {
  private logger: Logger;

  // 通过构造函数注入依赖
  constructor(logger: Logger) {
    this.logger = logger;
  }

  run(): void {
    this.logger.log("App is running...");
  }
}

// 创建服务实例
const logger = new ConsoleLogger();

// 将服务注入到客户端
const app = new App(logger);

// 运行客户端
app.run();
```

在这个例子中，`App`类依赖于`Logger`接口，而不是具体的`ConsoleLogger`实现。通过构造函数注入，我们可以轻松地将不同的`Logger`实现注入到`App`中。

## 依赖注入的实际应用

依赖注入在大型应用程序中非常有用，尤其是在需要管理大量依赖关系的情况下。以下是一个更复杂的例子，展示了如何在真实场景中使用依赖注入。

### 示例：用户服务与数据库连接

假设我们有一个用户服务，它依赖于数据库连接来获取用户数据。我们可以通过依赖注入来管理这些依赖关系。

```typescript
// 定义数据库连接接口
interface DatabaseConnection {
  query(sql: string): Promise<any>;
}

// 实现一个具体的数据库连接
class MySQLConnection implements DatabaseConnection {
  async query(sql: string): Promise<any> {
    // 模拟数据库查询
    return new Promise((resolve) => {
      setTimeout(() => {
        resolve([{ id: 1, name: "John Doe" }]);
      }, 1000);
    });
  }
}

// 用户服务类，依赖于DatabaseConnection接口
class UserService {
  private db: DatabaseConnection;

  // 通过构造函数注入依赖
  constructor(db: DatabaseConnection) {
    this.db = db;
  }

  async getUser(id: number): Promise<any> {
    const sql = `SELECT * FROM users WHERE id = ${id}`;
    return this.db.query(sql);
  }
}

// 创建数据库连接实例
const dbConnection = new MySQLConnection();

// 将数据库连接注入到用户服务
const userService = new UserService(dbConnection);

// 使用用户服务获取用户数据
userService.getUser(1).then((user) => {
  console.log(user);
});
```

在这个例子中，`UserService`类依赖于`DatabaseConnection`接口，而不是具体的`MySQLConnection`实现。这使得我们可以轻松地替换数据库连接实现，例如使用`PostgreSQLConnection`或`MockDatabaseConnection`进行测试。

## 依赖注入容器

在实际项目中，手动管理依赖关系可能会变得复杂。为了简化这一过程，我们可以使用依赖注入容器（DI Container）。依赖注入容器是一个工具，它可以自动管理对象的创建和依赖注入。

### 示例：使用InversifyJS

[InversifyJS](https://inversify.io/) 是一个流行的TypeScript依赖注入容器。以下是如何使用InversifyJS来实现依赖注入的示例。

```typescript
import { injectable, inject, Container } from "inversify";

// 定义服务接口
interface Logger {
  log(message: string): void;
}

// 实现具体的服务
@injectable()
class ConsoleLogger implements Logger {
  log(message: string): void {
    console.log(message);
  }
}

// 客户端类，依赖于Logger接口
@injectable()
class App {
  private logger: Logger;

  // 通过构造函数注入依赖
  constructor(@inject("Logger") logger: Logger) {
    this.logger = logger;
  }

  run(): void {
    this.logger.log("App is running...");
  }
}

// 创建依赖注入容器
const container = new Container();

// 绑定服务接口到具体实现
container.bind<Logger>("Logger").to(ConsoleLogger);

// 绑定客户端类
container.bind<App>(App).toSelf();

// 从容器中获取客户端实例
const app = container.get<App>(App);

// 运行客户端
app.run();
```

在这个例子中，我们使用InversifyJS来管理依赖关系。通过`@injectable`和`@inject`装饰器，我们可以轻松地将依赖注入到类中。

## 总结

依赖注入是一种强大的设计模式，它可以帮助我们构建松耦合、可测试和可维护的应用程序。通过将依赖关系的管理交给外部容器或框架，我们可以更专注于业务逻辑的实现。

在TypeScript中，依赖注入可以通过手动注入或使用依赖注入容器（如InversifyJS）来实现。无论选择哪种方式，依赖注入都能显著提升代码的质量和可维护性。

## 附加资源与练习

- **练习**：尝试在现有的TypeScript项目中引入依赖注入模式，看看它如何改善你的代码结构。
- **资源**：
  - [InversifyJS官方文档](https://inversify.io/)
  - [TypeScript官方文档](https://www.typescriptlang.org/docs/)
  - [依赖注入模式详解](https://martinfowler.com/articles/injection.html)

通过学习和实践依赖注入，你将能够编写出更加灵活和可维护的TypeScript代码。