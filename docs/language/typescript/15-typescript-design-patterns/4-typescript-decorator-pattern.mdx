---
title: TypeScript 装饰器模式
description: 了解TypeScript中的装饰器模式，掌握如何通过装饰器增强类的功能，并探索其实际应用场景。
---

# TypeScript 装饰器模式

装饰器模式是一种结构型设计模式，它允许你通过将对象放入包含行为的特殊封装对象中来为原对象增加新的行为。在TypeScript中，装饰器是一种特殊的声明，可以附加到类声明、方法、访问器、属性或参数上，以修改它们的行为。

## 什么是装饰器模式？

装饰器模式的核心思想是**动态地给对象添加额外的职责**，而不会影响其他对象。这种模式提供了一种灵活的替代方案，比继承更加灵活，因为它允许你在运行时添加或删除功能。

在TypeScript中，装饰器是通过`@`符号来使用的。它们可以用于类、方法、属性等，并且可以组合使用以实现复杂的功能。

## 装饰器的基本语法

在TypeScript中，装饰器是一个函数，它可以接收不同的参数，具体取决于它所装饰的目标。以下是一个简单的装饰器示例：

```typescript
function simpleDecorator(target: any) {
    console.log("装饰器已应用");
}

@simpleDecorator
class MyClass {
    // 类的实现
}
```

在这个例子中，`simpleDecorator`是一个装饰器函数，它会在`MyClass`类被定义时自动调用。

## 装饰器的类型

TypeScript支持以下几种类型的装饰器：

1. **类装饰器**：应用于类构造函数，用于观察、修改或替换类定义。
2. **方法装饰器**：应用于类的方法，用于修改或替换方法定义。
3. **属性装饰器**：应用于类的属性，用于观察、修改或替换属性定义。
4. **参数装饰器**：应用于方法的参数，用于观察或修改参数定义。

### 类装饰器

类装饰器是最常见的装饰器类型。它接收类的构造函数作为参数，并可以返回一个新的构造函数来替换原来的构造函数。

```typescript
function classDecorator<T extends { new(...args: any[]): {} }>(constructor: T) {
    return class extends constructor {
        newProperty = "new property";
        hello = "override";
    };
}

@classDecorator
class MyClass {
    property = "property";
    hello: string;
    constructor(m: string) {
        this.hello = m;
    }
}

console.log(new MyClass("world"));
```

输出：
```
{ property: 'property', hello: 'override', newProperty: 'new property' }
```

在这个例子中，`classDecorator`装饰器修改了`MyClass`类的行为，添加了一个新的属性`newProperty`，并覆盖了`hello`属性的值。

### 方法装饰器

方法装饰器用于修改或替换类的方法。它接收三个参数：类的原型、方法名称和方法的属性描述符。

```typescript
function methodDecorator(target: any, propertyKey: string, descriptor: PropertyDescriptor) {
    const originalMethod = descriptor.value;
    descriptor.value = function (...args: any[]) {
        console.log(`调用方法: ${propertyKey}`);
        return originalMethod.apply(this, args);
    };
}

class MyClass {
    @methodDecorator
    greet() {
        console.log("Hello, world!");
    }
}

const instance = new MyClass();
instance.greet();
```

输出：
```
调用方法: greet
Hello, world!
```

在这个例子中，`methodDecorator`装饰器在调用`greet`方法时添加了日志功能。

### 属性装饰器

属性装饰器用于观察或修改类的属性。它接收两个参数：类的原型和属性名称。

```typescript
function propertyDecorator(target: any, propertyKey: string) {
    console.log(`属性装饰器应用于: ${propertyKey}`);
}

class MyClass {
    @propertyDecorator
    myProperty: string;
}
```

输出：
```
属性装饰器应用于: myProperty
```

在这个例子中，`propertyDecorator`装饰器在`myProperty`属性被定义时打印了一条消息。

### 参数装饰器

参数装饰器用于观察或修改方法的参数。它接收三个参数：类的原型、方法名称和参数索引。

```typescript
function parameterDecorator(target: any, methodName: string, parameterIndex: number) {
    console.log(`参数装饰器应用于: ${methodName} 的参数索引 ${parameterIndex}`);
}

class MyClass {
    greet(@parameterDecorator name: string) {
        console.log(`Hello, ${name}!`);
    }
}
```

输出：
```
参数装饰器应用于: greet 的参数索引 0
```

在这个例子中，`parameterDecorator`装饰器在`greet`方法的`name`参数被定义时打印了一条消息。

## 实际应用场景

装饰器模式在实际开发中有许多应用场景，以下是一些常见的例子：

### 日志记录

你可以使用装饰器来自动记录方法的调用日志，而不需要修改方法的实现。

```typescript
function logMethod(target: any, propertyKey: string, descriptor: PropertyDescriptor) {
    const originalMethod = descriptor.value;
    descriptor.value = function (...args: any[]) {
        console.log(`调用方法: ${propertyKey}，参数: ${JSON.stringify(args)}`);
        return originalMethod.apply(this, args);
    };
}

class Calculator {
    @logMethod
    add(a: number, b: number) {
        return a + b;
    }
}

const calculator = new Calculator();
calculator.add(2, 3);
```

输出：
```
调用方法: add，参数: [2,3]
5
```

### 权限控制

你可以使用装饰器来控制方法的访问权限，例如只有管理员才能调用某些方法。

```typescript
function adminOnly(target: any, propertyKey: string, descriptor: PropertyDescriptor) {
    const originalMethod = descriptor.value;
    descriptor.value = function (...args: any[]) {
        if (this.role === "admin") {
            return originalMethod.apply(this, args);
        } else {
            throw new Error("只有管理员可以调用此方法");
        }
    };
}

class User {
    role: string;

    constructor(role: string) {
        this.role = role;
    }

    @adminOnly
    deleteUser(id: number) {
        console.log(`用户 ${id} 已被删除`);
    }
}

const admin = new User("admin");
admin.deleteUser(1); // 正常执行

const user = new User("user");
user.deleteUser(2); // 抛出错误
```

### 缓存

你可以使用装饰器来实现方法的缓存功能，避免重复计算。

```typescript
function cache(target: any, propertyKey: string, descriptor: PropertyDescriptor) {
    const originalMethod = descriptor.value;
    const cacheMap = new Map();

    descriptor.value = function (...args: any[]) {
        const key = JSON.stringify(args);
        if (cacheMap.has(key)) {
            console.log("从缓存中获取结果");
            return cacheMap.get(key);
        }
        const result = originalMethod.apply(this, args);
        cacheMap.set(key, result);
        return result;
    };
}

class MathOperations {
    @cache
    factorial(n: number): number {
        if (n === 0 || n === 1) return 1;
        return n * this.factorial(n - 1);
    }
}

const math = new MathOperations();
console.log(math.factorial(5)); // 计算并缓存
console.log(math.factorial(5)); // 从缓存中获取
```

输出：
```
120
从缓存中获取结果
120
```

## 总结

装饰器模式是一种强大的设计模式，它允许你动态地扩展对象的功能，而不会影响其他对象。在TypeScript中，装饰器提供了一种简洁的方式来增强类、方法、属性和参数的行为。通过合理地使用装饰器，你可以提高代码的可重用性和可维护性。

## 附加资源与练习

- **TypeScript官方文档**：了解更多关于装饰器的详细信息。
- **练习**：尝试为你的项目中的某些类或方法添加装饰器，例如日志记录、权限控制或缓存功能。
- **进一步学习**：探索其他设计模式，如观察者模式、工厂模式等，以丰富你的编程知识。

:::tip
装饰器模式在TypeScript中非常有用，尤其是在需要动态扩展功能时。通过实践，你将更好地理解其工作原理和应用场景。
:::