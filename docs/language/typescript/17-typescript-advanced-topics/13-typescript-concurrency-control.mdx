---
title: TypeScript 并发控制
description: 了解如何在TypeScript中实现并发控制，确保多任务执行时的数据一致性和性能优化。
---

# TypeScript 并发控制

在现代应用程序中，并发控制是一个至关重要的概念，尤其是在处理多任务、异步操作或共享资源时。TypeScript作为JavaScript的超集，提供了强大的类型系统和工具来帮助开发者更好地管理并发操作。本文将介绍TypeScript中的并发控制，并通过实际案例展示如何在实际项目中应用这些概念。

## 什么是并发控制？

并发控制是指在多任务或多线程环境中，确保多个操作能够正确、高效地执行，而不会导致数据不一致或资源冲突。在JavaScript和TypeScript中，虽然语言本身是单线程的，但通过异步编程（如`Promise`、`async/await`）和事件驱动模型，我们可以模拟并发操作。

### 为什么需要并发控制？

- **数据一致性**：当多个操作同时访问或修改共享数据时，可能会导致数据不一致。
- **性能优化**：合理的并发控制可以避免资源竞争，提高应用程序的性能。
- **避免死锁**：在多任务环境中，不合理的并发控制可能导致死锁，使程序无法继续执行。

## TypeScript 中的并发控制机制

TypeScript本身并不提供专门的并发控制机制，但它可以与JavaScript的异步编程模型结合使用，来实现并发控制。以下是几种常见的并发控制方法：

### 1. 使用`Promise`和`async/await`

`Promise`和`async/await`是JavaScript中处理异步操作的主要方式。通过合理地使用这些工具，我们可以控制并发任务的执行顺序。

```typescript
async function fetchData(url: string): Promise<string> {
  const response = await fetch(url);
  return response.text();
}

async function main() {
  const data1 = await fetchData('https://api.example.com/data1');
  const data2 = await fetchData('https://api.example.com/data2');
  console.log(data1, data2);
}

main();
```

在这个例子中，`fetchData`函数会依次执行，确保`data1`和`data2`按顺序获取。

### 2. 使用`Promise.all`进行并行执行

如果你希望多个异步任务并行执行，可以使用`Promise.all`。

```typescript
async function main() {
  const [data1, data2] = await Promise.all([
    fetchData('https://api.example.com/data1'),
    fetchData('https://api.example.com/data2'),
  ]);
  console.log(data1, data2);
}

main();
```

`Promise.all`会同时启动所有`Promise`，并在所有任务完成后返回结果。这样可以显著提高执行效率。

### 3. 使用`Mutex`实现互斥锁

在某些情况下，我们需要确保同一时间只有一个任务可以访问共享资源。这时可以使用互斥锁（Mutex）来实现。

```typescript
class Mutex {
  private locked = false;
  private queue: (() => void)[] = [];

  async lock(): Promise<void> {
    if (this.locked) {
      await new Promise<void>((resolve) => this.queue.push(resolve));
    }
    this.locked = true;
  }

  unlock(): void {
    this.locked = false;
    const next = this.queue.shift();
    if (next) next();
  }
}

const mutex = new Mutex();

async function criticalSection() {
  await mutex.lock();
  try {
    // 访问共享资源
  } finally {
    mutex.unlock();
  }
}
```

在这个例子中，`Mutex`类确保同一时间只有一个任务可以进入临界区（`criticalSection`），从而避免资源冲突。

## 实际案例：并发请求控制

假设我们有一个需求：从多个API端点获取数据，但需要限制同时发起的请求数量，以避免服务器过载。我们可以使用`Semaphore`（信号量）来实现这一需求。

```typescript
class Semaphore {
  private count: number;
  private queue: (() => void)[] = [];

  constructor(count: number) {
    this.count = count;
  }

  async acquire(): Promise<void> {
    if (this.count > 0) {
      this.count--;
    } else {
      await new Promise<void>((resolve) => this.queue.push(resolve));
    }
  }

  release(): void {
    this.count++;
    const next = this.queue.shift();
    if (next) next();
  }
}

const semaphore = new Semaphore(3); // 限制同时3个请求

async function fetchWithLimit(url: string): Promise<string> {
  await semaphore.acquire();
  try {
    const response = await fetch(url);
    return response.text();
  } finally {
    semaphore.release();
  }
}

async function main() {
  const urls = [
    'https://api.example.com/data1',
    'https://api.example.com/data2',
    'https://api.example.com/data3',
    'https://api.example.com/data4',
    'https://api.example.com/data5',
  ];

  const results = await Promise.all(urls.map(fetchWithLimit));
  console.log(results);
}

main();
```

在这个案例中，`Semaphore`类限制了同时发起的请求数量，确保不会超过设定的并发限制。

## 总结

并发控制是TypeScript和JavaScript开发中的一个重要主题。通过合理地使用`Promise`、`async/await`、`Mutex`和`Semaphore`等工具，我们可以有效地管理并发任务，确保数据一致性和性能优化。

### 附加资源

- [MDN Web Docs: Using Promises](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Using_promises)
- [TypeScript Handbook: Async/Await](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-1.html#async--await)
- [Concurrency in JavaScript](https://javascript.info/async)

### 练习

1. 修改上面的`Semaphore`示例，使其能够动态调整并发限制。
2. 尝试实现一个`ReadWriteLock`，允许多个读操作同时进行，但写操作必须独占资源。

通过本文的学习，你应该对TypeScript中的并发控制有了更深入的理解。继续实践和探索，你将能够更好地应用这些概念到实际项目中。