---
title: TypeScript 实例应用
description: 了解如何在TypeScript中使用装饰器，并通过实际案例展示其应用场景。本文适合初学者，逐步讲解装饰器的概念及其在项目中的实际应用。
---

## 介绍

TypeScript装饰器是一种特殊类型的声明，它可以被附加到类声明、方法、访问器、属性或参数上，以修改类的行为或添加额外的功能。装饰器使用 `@expression` 的形式，其中 `expression` 是一个函数，它会在运行时被调用，并接收目标对象的相关信息。

装饰器在TypeScript中广泛用于元编程、依赖注入、日志记录、权限控制等场景。本文将逐步讲解装饰器的基本概念，并通过实际案例展示其应用。

## 装饰器的基本语法

装饰器本质上是一个函数，它接收三个参数：

1. **target**: 目标对象（类、方法、属性等）。
2. **key**: 目标对象的名称（方法名、属性名等）。
3. **descriptor**: 目标对象的属性描述符（仅适用于方法和访问器）。

以下是一个简单的装饰器示例：

```typescript
function log(target: any, key: string, descriptor: PropertyDescriptor) {
  const originalMethod = descriptor.value;

  descriptor.value = function (...args: any[]) {
    console.log(`Calling ${key} with arguments: ${JSON.stringify(args)}`);
    const result = originalMethod.apply(this, args);
    console.log(`Method ${key} returned: ${result}`);
    return result;
  };

  return descriptor;
}

class Calculator {
  @log
  add(a: number, b: number): number {
    return a + b;
  }
}

const calc = new Calculator();
calc.add(2, 3); // 输出: Calling add with arguments: [2,3] 和 Method add returned: 5
```

在这个例子中，`log` 装饰器被应用到 `Calculator` 类的 `add` 方法上。每当 `add` 方法被调用时，装饰器会记录方法的调用参数和返回值。

## 装饰器的类型

TypeScript支持以下几种类型的装饰器：

1. **类装饰器**: 应用于类构造函数，用于修改或扩展类的行为。
2. **方法装饰器**: 应用于类的方法，用于修改或扩展方法的行为。
3. **属性装饰器**: 应用于类的属性，用于修改或扩展属性的行为。
4. **参数装饰器**: 应用于方法的参数，用于修改或扩展参数的行为。

### 类装饰器

类装饰器接收一个参数，即类的构造函数。以下是一个类装饰器的示例：

```typescript
function sealed(constructor: Function) {
  Object.seal(constructor);
  Object.seal(constructor.prototype);
}

@sealed
class Greeter {
  greeting: string;
  constructor(message: string) {
    this.greeting = message;
  }
  greet() {
    return "Hello, " + this.greeting;
  }
}
```

在这个例子中，`sealed` 装饰器被应用到 `Greeter` 类上，使得该类及其原型不可扩展。

### 方法装饰器

方法装饰器接收三个参数：目标对象、方法名和属性描述符。以下是一个方法装饰器的示例：

```typescript
function readonly(target: any, key: string, descriptor: PropertyDescriptor) {
  descriptor.writable = false;
}

class Person {
  @readonly
  name: string;

  constructor(name: string) {
    this.name = name;
  }
}

const person = new Person("Alice");
person.name = "Bob"; // 报错: Cannot assign to read only property 'name' of object
```

在这个例子中，`readonly` 装饰器被应用到 `Person` 类的 `name` 属性上，使得该属性不可写。

### 属性装饰器

属性装饰器接收两个参数：目标对象和属性名。以下是一个属性装饰器的示例：

```typescript
function format(formatString: string) {
  return function (target: any, key: string) {
    let value = target[key];

    const getter = function () {
      return value;
    };

    const setter = function (newVal: string) {
      value = newVal.padStart(10, formatString);
    };

    Object.defineProperty(target, key, {
      get: getter,
      set: setter,
      enumerable: true,
      configurable: true,
    });
  };
}

class User {
  @format("*")
  username: string;
}

const user = new User();
user.username = "Alice";
console.log(user.username); // 输出: ******Alice
```

在这个例子中，`format` 装饰器被应用到 `User` 类的 `username` 属性上，使得该属性的值在设置时会被格式化为指定格式。

### 参数装饰器

参数装饰器接收三个参数：目标对象、方法名和参数索引。以下是一个参数装饰器的示例：

```typescript
function validate(target: any, key: string, index: number) {
  const originalMethod = target[key];

  target[key] = function (...args: any[]) {
    if (typeof args[index] !== "number") {
      throw new Error(`Argument at position ${index} must be a number`);
    }
    return originalMethod.apply(this, args);
  };
}

class MathOperations {
  add(@validate a: number, b: number): number {
    return a + b;
  }
}

const math = new MathOperations();
math.add(2, 3); // 正常执行
math.add("2", 3); // 报错: Argument at position 0 must be a number
```

在这个例子中，`validate` 装饰器被应用到 `MathOperations` 类的 `add` 方法的第一个参数上，确保该参数必须为数字类型。

## 实际应用场景

### 日志记录

装饰器可以用于记录方法的调用日志，这在调试和监控应用程序时非常有用。以下是一个日志记录装饰器的示例：

```typescript
function logMethod(target: any, key: string, descriptor: PropertyDescriptor) {
  const originalMethod = descriptor.value;

  descriptor.value = function (...args: any[]) {
    console.log(`Method ${key} called with arguments: ${JSON.stringify(args)}`);
    const result = originalMethod.apply(this, args);
    console.log(`Method ${key} returned: ${result}`);
    return result;
  };

  return descriptor;
}

class Service {
  @logMethod
  processData(data: any) {
    // 处理数据的逻辑
    return data;
  }
}

const service = new Service();
service.processData({ key: "value" });
```

### 权限控制

装饰器可以用于实现权限控制，确保只有具有特定权限的用户才能访问某些方法。以下是一个权限控制装饰器的示例：

```typescript
function requirePermission(permission: string) {
  return function (target: any, key: string, descriptor: PropertyDescriptor) {
    const originalMethod = descriptor.value;

    descriptor.value = function (...args: any[]) {
      const userPermissions = ["read", "write"]; // 假设用户具有这些权限
      if (!userPermissions.includes(permission)) {
        throw new Error(`Permission denied: ${permission} required`);
      }
      return originalMethod.apply(this, args);
    };

    return descriptor;
  };
}

class Document {
  @requirePermission("write")
  edit() {
    console.log("Editing document...");
  }
}

const doc = new Document();
doc.edit(); // 如果用户没有 "write" 权限，将抛出错误
```

## 总结

TypeScript装饰器是一种强大的工具，可以用于修改或扩展类、方法、属性和参数的行为。通过装饰器，开发者可以实现日志记录、权限控制、数据验证等功能，从而提高代码的可维护性和可扩展性。

在实际项目中，装饰器可以与其他TypeScript特性（如接口、泛型等）结合使用，以构建更加灵活和强大的应用程序。

## 附加资源与练习

- **TypeScript官方文档**: [装饰器](https://www.typescriptlang.org/docs/handbook/decorators.html)
- **练习**: 尝试创建一个装饰器，用于缓存方法的返回值，避免重复计算。
- **练习**: 实现一个装饰器，用于限制方法的调用频率（例如每秒最多调用一次）。

通过本文的学习，你应该对TypeScript装饰器有了初步的了解，并能够在实际项目中应用它们。继续探索和实践，你将能够更深入地掌握这一强大的特性。