---
title: TypeScript 方法装饰器
description: 了解 TypeScript 方法装饰器的基本概念、用法以及实际应用场景，帮助初学者掌握这一强大的功能。
---

## 介绍

TypeScript 装饰器（Decorators）是一种特殊类型的声明，它可以被附加到类声明、方法、访问器、属性或参数上，以修改类的行为。方法装饰器是其中一种类型，它允许我们在不修改方法本身的情况下，对方法的行为进行扩展或修改。

方法装饰器通常用于日志记录、权限验证、性能监控等场景。通过装饰器，我们可以将这些横切关注点（Cross-Cutting Concerns）从业务逻辑中分离出来，使代码更加清晰和可维护。

## 方法装饰器的基本语法

方法装饰器是一个函数，它接受三个参数：

1. `target`：对于静态方法，`target` 是类的构造函数；对于实例方法，`target` 是类的原型。
2. `propertyKey`：方法的名称。
3. `descriptor`：方法的属性描述符（PropertyDescriptor）。

方法装饰器的基本语法如下：

```typescript
function methodDecorator(target: any, propertyKey: string, descriptor: PropertyDescriptor) {
    // 在这里对方法进行修改或扩展
}
```

## 示例：日志记录装饰器

让我们通过一个简单的例子来理解方法装饰器的用法。假设我们有一个类 `Calculator`，其中包含一个 `add` 方法。我们希望在不修改 `add` 方法的情况下，记录每次调用 `add` 方法的日志。

```typescript
function log(target: any, propertyKey: string, descriptor: PropertyDescriptor) {
    const originalMethod = descriptor.value;

    descriptor.value = function (...args: any[]) {
        console.log(`Calling method: ${propertyKey} with arguments: ${JSON.stringify(args)}`);
        const result = originalMethod.apply(this, args);
        console.log(`Method ${propertyKey} returned: ${result}`);
        return result;
    };

    return descriptor;
}

class Calculator {
    @log
    add(a: number, b: number): number {
        return a + b;
    }
}

const calculator = new Calculator();
calculator.add(2, 3); // 输出日志并返回 5
```

在这个例子中，`log` 装饰器会在每次调用 `add` 方法时，打印出方法的名称、参数以及返回值。通过这种方式，我们可以在不修改 `add` 方法的情况下，轻松地添加日志记录功能。

## 实际应用场景

### 1. 权限验证

方法装饰器可以用于实现权限验证。例如，我们可以创建一个 `@requiresRole` 装饰器，用于检查用户是否具有执行某个方法的权限。

```typescript
function requiresRole(role: string) {
    return function (target: any, propertyKey: string, descriptor: PropertyDescriptor) {
        const originalMethod = descriptor.value;

        descriptor.value = function (...args: any[]) {
            const userRole = getUserRole(); // 假设这是一个获取用户角色的函数
            if (userRole !== role) {
                throw new Error(`User does not have the required role: ${role}`);
            }
            return originalMethod.apply(this, args);
        };

        return descriptor;
    };
}

class AdminPanel {
    @requiresRole('admin')
    deleteUser(userId: number) {
        console.log(`User ${userId} deleted.`);
    }
}

const adminPanel = new AdminPanel();
adminPanel.deleteUser(1); // 如果用户角色不是 'admin'，将抛出错误
```

### 2. 性能监控

方法装饰器还可以用于性能监控。例如，我们可以创建一个 `@measureTime` 装饰器，用于测量方法的执行时间。

```typescript
function measureTime(target: any, propertyKey: string, descriptor: PropertyDescriptor) {
    const originalMethod = descriptor.value;

    descriptor.value = function (...args: any[]) {
        const start = performance.now();
        const result = originalMethod.apply(this, args);
        const end = performance.now();
        console.log(`Method ${propertyKey} took ${end - start} milliseconds.`);
        return result;
    };

    return descriptor;
}

class Database {
    @measureTime
    query(sql: string) {
        // 模拟数据库查询
        return new Promise((resolve) => setTimeout(() => resolve("Query result"), 1000));
    }
}

const db = new Database();
db.query("SELECT * FROM users"); // 输出方法执行时间
```

## 总结

TypeScript 方法装饰器是一种强大的工具，它允许我们在不修改方法本身的情况下，对方法的行为进行扩展或修改。通过方法装饰器，我们可以轻松地实现日志记录、权限验证、性能监控等功能，从而使代码更加清晰和可维护。

## 附加资源与练习

- **练习 1**：创建一个 `@retry` 装饰器，当方法抛出错误时，自动重试指定的次数。
- **练习 2**：创建一个 `@cache` 装饰器，用于缓存方法的返回值，避免重复计算。

:::tip
如果你对 TypeScript 装饰器感兴趣，可以进一步学习类装饰器、属性装饰器和参数装饰器，它们同样具有强大的功能。
:::