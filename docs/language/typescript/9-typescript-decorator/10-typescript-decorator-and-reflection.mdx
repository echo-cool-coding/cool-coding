---
title: TypeScript 装饰器与反射
description: 了解TypeScript装饰器与反射的概念、用法及其在实际开发中的应用场景。本文适合初学者，包含代码示例和实际案例。
---

# TypeScript 装饰器与反射

TypeScript装饰器（Decorators）和反射（Reflection）是TypeScript中两个强大的特性，它们可以帮助开发者以声明式的方式增强类、方法、属性或参数的行为。本文将详细介绍装饰器和反射的概念、用法以及实际应用场景。

## 什么是装饰器？

装饰器是一种特殊的声明，可以附加到类声明、方法、访问器、属性或参数上。它们以`@expression`的形式使用，其中`expression`是一个函数，会在运行时被调用，并接收目标对象的元数据作为参数。

装饰器的主要作用是为代码添加额外的功能或修改其行为，而无需直接修改原始代码。这使得代码更加模块化和可维护。

## 装饰器的基本语法

装饰器的语法非常简单。以下是一个基本的装饰器示例：

```typescript
function log(target: any, propertyKey: string, descriptor: PropertyDescriptor) {
    const originalMethod = descriptor.value;

    descriptor.value = function (...args: any[]) {
        console.log(`Calling ${propertyKey} with arguments: ${JSON.stringify(args)}`);
        const result = originalMethod.apply(this, args);
        console.log(`Method ${propertyKey} returned: ${JSON.stringify(result)}`);
        return result;
    };

    return descriptor;
}

class Calculator {
    @log
    add(a: number, b: number): number {
        return a + b;
    }
}

const calc = new Calculator();
calc.add(2, 3); // 输出: Calling add with arguments: [2,3] 和 Method add returned: 5
```

在这个例子中，`@log`装饰器被应用到`Calculator`类的`add`方法上。每当调用`add`方法时，装饰器会记录方法的调用参数和返回值。

## 装饰器的类型

TypeScript支持以下几种类型的装饰器：

1. **类装饰器**：应用于类构造函数，用于观察、修改或替换类定义。
2. **方法装饰器**：应用于类的方法，用于观察、修改或替换方法定义。
3. **访问器装饰器**：应用于类的访问器（getter/setter），用于观察、修改或替换访问器定义。
4. **属性装饰器**：应用于类的属性，用于观察、修改或替换属性定义。
5. **参数装饰器**：应用于类方法的参数，用于观察或修改参数定义。

### 类装饰器示例

```typescript
function sealed(constructor: Function) {
    Object.seal(constructor);
    Object.seal(constructor.prototype);
}

@sealed
class Greeter {
    greeting: string;
    constructor(message: string) {
        this.greeting = message;
    }
    greet() {
        return "Hello, " + this.greeting;
    }
}
```

在这个例子中，`@sealed`装饰器被应用到`Greeter`类上，使得该类及其原型不可扩展。

## 什么是反射？

反射（Reflection）是指在运行时检查或修改类、方法、属性等的能力。TypeScript通过`Reflect`对象提供了一些反射API，允许开发者在运行时获取和操作元数据。

### 反射的实际应用

反射通常与装饰器一起使用，以在运行时获取或修改类的元数据。以下是一个结合装饰器和反射的示例：

```typescript
import "reflect-metadata";

function logParameter(target: any, propertyKey: string, parameterIndex: number) {
    const existingParameters: number[] = Reflect.getOwnMetadata("logParameters", target, propertyKey) || [];
    existingParameters.push(parameterIndex);
    Reflect.defineMetadata("logParameters", existingParameters, target, propertyKey);
}

class Greeter {
    greet(@logParameter name: string): string {
        return `Hello, ${name}`;
    }
}

const greeter = new Greeter();
console.log(Reflect.getMetadata("logParameters", greeter, "greet")); // 输出: [0]
```

在这个例子中，`@logParameter`装饰器被应用到`greet`方法的参数上，并使用反射API将参数索引存储在元数据中。

## 实际应用场景

装饰器和反射在实际开发中有许多应用场景，以下是一些常见的例子：

1. **日志记录**：通过装饰器自动记录方法的调用和返回值。
2. **验证**：使用装饰器和反射来验证方法的参数。
3. **依赖注入**：在框架中使用装饰器和反射来实现依赖注入。
4. **性能监控**：通过装饰器监控方法的执行时间。

### 依赖注入示例

```typescript
import "reflect-metadata";

const TYPES = {
    Service: Symbol.for("Service")
};

interface IService {
    doSomething(): void;
}

class Service implements IService {
    doSomething() {
        console.log("Doing something...");
    }
}

class Client {
    private _service: IService;

    constructor(@inject(TYPES.Service) service: IService) {
        this._service = service;
    }

    execute() {
        this._service.doSomething();
    }
}

const container = new Container();
container.bind<IService>(TYPES.Service).to(Service);

const client = container.get(Client);
client.execute(); // 输出: Doing something...
```

在这个例子中，`@inject`装饰器用于将`Service`实例注入到`Client`类的构造函数中。

## 总结

TypeScript装饰器和反射为开发者提供了强大的工具，可以在不修改原始代码的情况下增强或修改类的行为。通过装饰器，我们可以轻松地实现日志记录、验证、依赖注入等功能。反射则允许我们在运行时获取和操作元数据，进一步增强了TypeScript的灵活性。

## 附加资源与练习

- **官方文档**：[TypeScript Decorators](https://www.typescriptlang.org/docs/handbook/decorators.html)
- **练习**：尝试为你的类添加一个装饰器，记录每个方法的执行时间。
- **进一步学习**：探索`reflect-metadata`库，了解如何在TypeScript中使用反射API。

:::tip
装饰器和反射是TypeScript中非常强大的特性，但它们的使用需要谨慎。过度使用装饰器可能会导致代码难以理解和维护，因此建议在必要时才使用它们。
:::