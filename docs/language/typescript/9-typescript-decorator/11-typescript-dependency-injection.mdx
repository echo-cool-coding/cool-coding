---
title: TypeScript 依赖注入
description: 了解 TypeScript 中的依赖注入（Dependency Injection, DI）概念，掌握如何通过装饰器实现依赖注入，并应用于实际开发场景。
---

# TypeScript 依赖注入

依赖注入（Dependency Injection, DI）是一种设计模式，用于实现控制反转（Inversion of Control, IoC）。它允许我们将对象的依赖关系从代码中解耦，从而提高代码的可维护性和可测试性。在 TypeScript 中，依赖注入通常与装饰器（Decorators）结合使用，以实现更灵活的依赖管理。

## 什么是依赖注入？

依赖注入的核心思想是将对象的依赖关系从对象内部转移到外部容器中。通过这种方式，对象不再需要自己创建或管理其依赖项，而是由外部容器负责提供这些依赖项。这种模式使得代码更加模块化，易于测试和维护。

### 依赖注入的优势
- **解耦**：将依赖关系从代码中分离出来，减少耦合度。
- **可测试性**：通过注入模拟依赖项，可以轻松进行单元测试。
- **可维护性**：依赖关系的集中管理使得代码更易于维护和扩展。

## TypeScript 中的依赖注入实现

在 TypeScript 中，我们可以通过装饰器来实现依赖注入。装饰器是一种特殊类型的声明，它可以附加到类声明、方法、访问器、属性或参数上，以修改类的行为。

### 基本概念

1. **容器（Container）**：用于存储和管理依赖项的容器。
2. **注入（Injection）**：将依赖项注入到目标对象中。
3. **装饰器（Decorator）**：用于标记需要注入的依赖项。

### 实现步骤

1. **创建容器**：首先，我们需要创建一个容器来存储依赖项。
2. **注册依赖项**：将依赖项注册到容器中。
3. **注入依赖项**：通过装饰器将依赖项注入到目标对象中。

### 代码示例

以下是一个简单的 TypeScript 依赖注入示例：

```typescript
// 1. 创建容器
const container = new Map();

// 2. 注册依赖项
class Logger {
  log(message: string) {
    console.log(message);
  }
}

container.set('Logger', new Logger());

// 3. 使用装饰器注入依赖项
function Inject(key: string) {
  return function (target: any, propertyKey: string) {
    Object.defineProperty(target, propertyKey, {
      get: () => container.get(key),
    });
  };
}

class App {
  @Inject('Logger') private logger!: Logger;

  run() {
    this.logger.log('Hello, Dependency Injection!');
  }
}

// 4. 使用注入的依赖项
const app = new App();
app.run(); // 输出: Hello, Dependency Injection!
```

### 解释

1. **容器**：我们使用 `Map` 来存储依赖项。
2. **注册依赖项**：将 `Logger` 类实例注册到容器中。
3. **装饰器**：`Inject` 装饰器用于将依赖项注入到 `App` 类的 `logger` 属性中。
4. **使用依赖项**：在 `App` 类的 `run` 方法中，我们使用注入的 `logger` 实例来记录日志。

## 实际应用场景

依赖注入在实际开发中有广泛的应用，特别是在大型应用程序中。以下是一个实际应用场景：

### 场景：Web 应用程序中的服务注入

假设我们正在开发一个 Web 应用程序，其中包含多个服务（如用户服务、日志服务等）。我们可以使用依赖注入来管理这些服务。

```typescript
// 1. 创建容器
const container = new Map();

// 2. 注册服务
class UserService {
  getUsers() {
    return ['Alice', 'Bob', 'Charlie'];
  }
}

class LoggerService {
  log(message: string) {
    console.log(`[LOG] ${message}`);
  }
}

container.set('UserService', new UserService());
container.set('LoggerService', new LoggerService());

// 3. 使用装饰器注入服务
function Inject(key: string) {
  return function (target: any, propertyKey: string) {
    Object.defineProperty(target, propertyKey, {
      get: () => container.get(key),
    });
  };
}

class UserController {
  @Inject('UserService') private userService!: UserService;
  @Inject('LoggerService') private loggerService!: LoggerService;

  getUsers() {
    const users = this.userService.getUsers();
    this.loggerService.log('Fetched users: ' + users.join(', '));
    return users;
  }
}

// 4. 使用注入的服务
const userController = new UserController();
console.log(userController.getUsers()); // 输出: ['Alice', 'Bob', 'Charlie']
```

### 解释

1. **容器**：我们使用 `Map` 来存储服务实例。
2. **注册服务**：将 `UserService` 和 `LoggerService` 注册到容器中。
3. **装饰器**：`Inject` 装饰器用于将服务注入到 `UserController` 类的属性中。
4. **使用服务**：在 `UserController` 类的 `getUsers` 方法中，我们使用注入的服务来获取用户列表并记录日志。

## 总结

依赖注入是一种强大的设计模式，它可以帮助我们更好地管理代码中的依赖关系。通过 TypeScript 的装饰器，我们可以轻松实现依赖注入，从而提高代码的可维护性和可测试性。

在实际开发中，依赖注入特别适用于大型应用程序，其中包含多个服务和模块。通过将依赖关系从代码中解耦，我们可以更灵活地管理和扩展应用程序。

## 附加资源

- [TypeScript 装饰器文档](https://www.typescriptlang.org/docs/handbook/decorators.html)
- [依赖注入模式](https://en.wikipedia.org/wiki/Dependency_injection)
- [InversifyJS - 一个强大的 TypeScript 依赖注入容器](https://inversify.io/)

## 练习

1. 尝试在现有的 TypeScript 项目中实现依赖注入。
2. 创建一个包含多个服务的应用程序，并使用依赖注入来管理这些服务。
3. 探索其他依赖注入库，如 InversifyJS，并比较它们与手动实现的区别。
