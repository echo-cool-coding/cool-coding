---
title: TypeScript 多重装饰器
description: 了解 TypeScript 中多重装饰器的概念、用法以及实际应用场景。本文将通过代码示例和逐步讲解，帮助你掌握如何在一个目标上应用多个装饰器。
---

# TypeScript 多重装饰器

在 TypeScript 中，装饰器（Decorator）是一种特殊类型的声明，它可以被附加到类声明、方法、访问器、属性或参数上，以修改它们的行为。多重装饰器（Multiple Decorators）则是指在一个目标上应用多个装饰器。本文将详细介绍多重装饰器的概念、语法以及实际应用。

## 什么是多重装饰器？

多重装饰器是指在一个目标（如类、方法、属性等）上同时应用多个装饰器。这些装饰器会按照一定的顺序执行，从而对目标进行多层修饰。多重装饰器的执行顺序是从上到下，从外到内。

### 基本语法

在 TypeScript 中，多重装饰器的语法非常简单。你只需要在目标前依次列出多个装饰器即可。例如：

```typescript
@decorator1
@decorator2
class MyClass {
  // 类的内容
}
```

在这个例子中，`decorator1` 和 `decorator2` 都会被应用到 `MyClass` 上。它们的执行顺序是：先执行 `decorator1`，再执行 `decorator2`。

## 多重装饰器的执行顺序

多重装饰器的执行顺序是从上到下，从外到内。也就是说，装饰器会按照它们在代码中出现的顺序依次执行。为了更好地理解这一点，我们来看一个具体的例子。

```typescript
function first() {
  console.log("first(): factory evaluated");
  return function (target: any, propertyKey: string, descriptor: PropertyDescriptor) {
    console.log("first(): called");
  };
}

function second() {
  console.log("second(): factory evaluated");
  return function (target: any, propertyKey: string, descriptor: PropertyDescriptor) {
    console.log("second(): called");
  };
}

class ExampleClass {
  @first()
  @second()
  method() {
    console.log("method called");
  }
}

const example = new ExampleClass();
example.method();
```

在这个例子中，`first` 和 `second` 是两个装饰器工厂函数。它们分别返回一个装饰器函数。当我们运行这段代码时，控制台会输出以下内容：

```
first(): factory evaluated
second(): factory evaluated
second(): called
first(): called
method called
```

从输出结果可以看出，装饰器工厂函数 `first` 和 `second` 首先被调用，然后装饰器函数 `second` 和 `first` 依次被调用。最后，`method` 方法被调用。

:::note
装饰器工厂函数是在装饰器被应用时立即执行的，而装饰器函数则是在目标被调用时执行的。
:::

## 多重装饰器的实际应用

多重装饰器在实际开发中有很多应用场景。例如，你可以使用多个装饰器来为一个方法添加日志记录、权限验证、缓存等功能。下面是一个实际应用的例子。

### 日志记录与权限验证

假设我们有一个需要记录日志和验证权限的方法。我们可以使用两个装饰器来实现这些功能。

```typescript
function log(target: any, propertyKey: string, descriptor: PropertyDescriptor) {
  const originalMethod = descriptor.value;
  descriptor.value = function (...args: any[]) {
    console.log(`Calling ${propertyKey} with arguments: ${JSON.stringify(args)}`);
    const result = originalMethod.apply(this, args);
    console.log(`Called ${propertyKey} and returned: ${JSON.stringify(result)}`);
    return result;
  };
  return descriptor;
}

function requireAdmin(target: any, propertyKey: string, descriptor: PropertyDescriptor) {
  const originalMethod = descriptor.value;
  descriptor.value = function (...args: any[]) {
    const user = { role: "admin" }; // 假设我们从上下文中获取用户信息
    if (user.role !== "admin") {
      throw new Error("Unauthorized: Only admin can access this method");
    }
    return originalMethod.apply(this, args);
  };
  return descriptor;
}

class UserService {
  @log
  @requireAdmin
  deleteUser(userId: number) {
    console.log(`Deleting user with id: ${userId}`);
    return { success: true };
  }
}

const userService = new UserService();
userService.deleteUser(1);
```

在这个例子中，`log` 装饰器用于记录方法的调用和返回结果，而 `requireAdmin` 装饰器用于验证用户权限。当我们调用 `deleteUser` 方法时，控制台会输出以下内容：

```
Calling deleteUser with arguments: [1]
Deleting user with id: 1
Called deleteUser and returned: {"success":true}
```

如果用户角色不是 `admin`，则会抛出错误：

```
Error: Unauthorized: Only admin can access this method
```

:::tip
多重装饰器可以让你将不同的功能模块化，从而提高代码的可维护性和可重用性。
:::

## 总结

多重装饰器是 TypeScript 中一个强大的功能，它允许你在一个目标上应用多个装饰器，从而实现复杂的功能组合。通过本文的学习，你应该已经掌握了多重装饰器的基本概念、执行顺序以及实际应用场景。

### 附加资源

- [TypeScript 官方文档 - 装饰器](https://www.typescriptlang.org/docs/handbook/decorators.html)
- [深入理解 TypeScript 装饰器](https://zhuanlan.zhihu.com/p/42220487)

### 练习

1. 尝试为一个类的方法添加多个装饰器，观察它们的执行顺序。
2. 编写一个装饰器，用于缓存方法的返回值，并在下次调用时直接返回缓存结果。
3. 结合日志记录和权限验证装饰器，为一个 REST API 控制器的方法添加多重装饰器。

通过练习，你将更加熟练地掌握 TypeScript 多重装饰器的使用。