---
title: TypeScript 访问器装饰器
description: 了解 TypeScript 中的访问器装饰器，掌握如何使用它们来增强类的 getter 和 setter 方法的功能。
---

# TypeScript 访问器装饰器

TypeScript 装饰器是一种强大的工具，允许我们在不修改类本身的情况下，动态地扩展类的行为。访问器装饰器是装饰器的一种，专门用于修饰类的 getter 和 setter 方法。通过访问器装饰器，我们可以在访问或修改属性时添加额外的逻辑，例如验证、日志记录或缓存。

## 什么是访问器装饰器？

访问器装饰器是一个函数，它可以被应用到类的 getter 或 setter 方法上。当装饰器被应用时，它会接收三个参数：

1. **target**: 装饰器所应用的类的原型（如果是静态成员，则是类的构造函数）。
2. **propertyKey**: 被装饰的 getter 或 setter 方法的名称。
3. **descriptor**: 属性描述符对象，它描述了属性的特性（如 `configurable`、`enumerable`、`writable` 等）。

访问器装饰器的主要作用是通过修改 `descriptor` 对象来改变 getter 或 setter 的行为。

## 访问器装饰器的基本用法

让我们从一个简单的例子开始，展示如何使用访问器装饰器。

```typescript
function logAccess(target: any, propertyKey: string, descriptor: PropertyDescriptor) {
    const originalGet = descriptor.get;
    const originalSet = descriptor.set;

    if (originalGet) {
        descriptor.get = function () {
            console.log(`Getting value of ${propertyKey}`);
            return originalGet.call(this);
        };
    }

    if (originalSet) {
        descriptor.set = function (value: any) {
            console.log(`Setting value of ${propertyKey} to ${value}`);
            originalSet.call(this, value);
        };
    }
}

class User {
    private _name: string;

    @logAccess
    get name() {
        return this._name;
    }

    set name(value: string) {
        this._name = value;
    }
}

const user = new User();
user.name = "Alice"; // 控制台输出: Setting value of name to Alice
console.log(user.name); // 控制台输出: Getting value of name, Alice
```

在这个例子中，我们定义了一个 `logAccess` 装饰器，它会在每次访问或修改 `name` 属性时打印日志。通过这种方式，我们可以在不修改 `User` 类的情况下，轻松地添加日志功能。

## 访问器装饰器的实际应用场景

访问器装饰器在实际开发中有许多应用场景。以下是一些常见的例子：

### 1. 属性验证

我们可以使用访问器装饰器来验证属性的值是否符合预期。例如，确保用户的年龄是一个正数。

```typescript
function validateAge(target: any, propertyKey: string, descriptor: PropertyDescriptor) {
    const originalSet = descriptor.set;

    if (originalSet) {
        descriptor.set = function (value: number) {
            if (value < 0) {
                throw new Error("Age cannot be negative");
            }
            originalSet.call(this, value);
        };
    }
}

class Person {
    private _age: number;

    @validateAge
    set age(value: number) {
        this._age = value;
    }

    get age() {
        return this._age;
    }
}

const person = new Person();
person.age = 25; // 正常
person.age = -5; // 抛出错误: Age cannot be negative
```

### 2. 属性缓存

我们可以使用访问器装饰器来实现属性的缓存，以避免重复计算。

```typescript
function cache(target: any, propertyKey: string, descriptor: PropertyDescriptor) {
    const originalGet = descriptor.get;
    let cachedValue: any;

    if (originalGet) {
        descriptor.get = function () {
            if (cachedValue === undefined) {
                cachedValue = originalGet.call(this);
            }
            return cachedValue;
        };
    }
}

class ExpensiveCalculation {
    private _value: number;

    constructor(value: number) {
        this._value = value;
    }

    @cache
    get result() {
        console.log("Performing expensive calculation...");
        return this._value * 2;
    }
}

const calc = new ExpensiveCalculation(10);
console.log(calc.result); // 控制台输出: Performing expensive calculation..., 20
console.log(calc.result); // 控制台输出: 20 (没有重新计算)
```

## 总结

访问器装饰器是 TypeScript 中一个非常有用的特性，它允许我们在不修改类本身的情况下，动态地扩展 getter 和 setter 方法的功能。通过访问器装饰器，我们可以轻松地添加日志记录、属性验证、缓存等功能。

在实际开发中，访问器装饰器可以帮助我们编写更简洁、更可维护的代码。希望本文能帮助你理解并掌握 TypeScript 访问器装饰器的用法。

## 附加资源与练习

- **练习**: 尝试创建一个访问器装饰器，用于限制字符串属性的最大长度。
- **资源**: 阅读 [TypeScript 官方文档](https://www.typescriptlang.org/docs/handbook/decorators.html) 以了解更多关于装饰器的内容。
