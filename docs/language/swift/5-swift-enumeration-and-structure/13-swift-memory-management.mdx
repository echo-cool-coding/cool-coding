---
title: Swift 内存管理
description: 了解 Swift 中的内存管理机制，包括自动引用计数（ARC）的工作原理、强引用循环及其解决方法。通过代码示例和实际案例，掌握如何高效管理内存。
---

## 介绍

在 Swift 中，内存管理是一个重要的概念，尤其是在处理复杂的数据结构和对象时。Swift 使用**自动引用计数（ARC）**来自动管理内存。ARC 会自动跟踪和清理不再使用的对象，从而减少内存泄漏的风险。然而，ARC 并非万能，开发者仍需了解其工作原理，以避免常见的内存管理问题，如**强引用循环**。

本文将逐步讲解 Swift 的内存管理机制，并通过代码示例和实际案例帮助你更好地理解这一概念。

---

## 自动引用计数（ARC）

ARC 是 Swift 中用于管理对象内存的机制。每当创建一个新的对象实例时，ARC 会为其分配内存，并在对象不再被引用时自动释放内存。

### ARC 的工作原理

ARC 通过跟踪对象的引用计数来决定何时释放内存。每当一个对象被引用时，其引用计数加 1；当引用失效时，引用计数减 1。当引用计数为 0 时，对象将被释放。

```swift
class Person {
    let name: String
    init(name: String) {
        self.name = name
        print("\(name) 被初始化")
    }
    deinit {
        print("\(name) 被释放")
    }
}

var person1: Person? = Person(name: "Alice") // 输出: Alice 被初始化
var person2: Person? = person1 // person1 的引用计数加 1

person1 = nil // person1 的引用计数减 1，但 person2 仍然持有引用
person2 = nil // person2 的引用计数减 1，引用计数为 0，输出: Alice 被释放
```

在上面的示例中，`Person` 类的实例 `person1` 和 `person2` 分别持有对同一个对象的引用。当所有引用都被置为 `nil` 时，对象被释放。

---

## 强引用循环

虽然 ARC 可以自动管理内存，但在某些情况下，对象之间可能会形成**强引用循环**，导致内存无法被释放。

### 什么是强引用循环？

强引用循环发生在两个或多个对象相互持有强引用时，导致它们的引用计数永远不会降为 0，从而无法释放内存。

```swift
class Person {
    let name: String
    var friend: Person?
    init(name: String) {
        self.name = name
        print("\(name) 被初始化")
    }
    deinit {
        print("\(name) 被释放")
    }
}

var alice: Person? = Person(name: "Alice")
var bob: Person? = Person(name: "Bob")

alice?.friend = bob
bob?.friend = alice

alice = nil
bob = nil
// 输出: Alice 被初始化
// 输出: Bob 被初始化
// 没有输出释放信息，因为存在强引用循环
```

在上面的示例中，`alice` 和 `bob` 相互持有对方的强引用，导致它们的引用计数始终为 1，即使将 `alice` 和 `bob` 置为 `nil`，对象也不会被释放。

---

## 解决强引用循环

Swift 提供了两种方式来解决强引用循环：**弱引用（weak）**和**无主引用（unowned）**。

### 弱引用（weak）

弱引用不会增加对象的引用计数，因此不会阻止对象被释放。弱引用通常用于可能为 `nil` 的情况。

```swift
class Person {
    let name: String
    weak var friend: Person?
    init(name: String) {
        self.name = name
        print("\(name) 被初始化")
    }
    deinit {
        print("\(name) 被释放")
    }
}

var alice: Person? = Person(name: "Alice")
var bob: Person? = Person(name: "Bob")

alice?.friend = bob
bob?.friend = alice

alice = nil
bob = nil
// 输出: Alice 被初始化
// 输出: Bob 被初始化
// 输出: Alice 被释放
// 输出: Bob 被释放
```

在上面的示例中，`friend` 属性被声明为 `weak`，因此不会增加引用计数。当 `alice` 和 `bob` 被置为 `nil` 时，对象被成功释放。

### 无主引用（unowned）

无主引用类似于弱引用，但它假设引用对象始终存在。如果引用对象被释放，访问无主引用会导致运行时错误。

```swift
class Customer {
    let name: String
    var card: CreditCard?
    init(name: String) {
        self.name = name
        print("\(name) 被初始化")
    }
    deinit {
        print("\(name) 被释放")
    }
}

class CreditCard {
    let number: UInt64
    unowned let customer: Customer
    init(number: UInt64, customer: Customer) {
        self.number = number
        self.customer = customer
        print("信用卡 \(number) 被初始化")
    }
    deinit {
        print("信用卡 \(number) 被释放")
    }
}

var john: Customer? = Customer(name: "John")
john?.card = CreditCard(number: 1234_5678_9012_3456, customer: john!)

john = nil
// 输出: John 被初始化
// 输出: 信用卡 1234567890123456 被初始化
// 输出: John 被释放
// 输出: 信用卡 1234567890123456 被释放
```

在上面的示例中，`CreditCard` 类使用 `unowned` 引用 `Customer` 对象，因为 `CreditCard` 的生命周期不会超过 `Customer`。

---

## 实际案例：闭包中的强引用循环

闭包也可能导致强引用循环，因为闭包会捕获其上下文中的变量。

```swift
class HTMLElement {
    let name: String
    let text: String?

    lazy var asHTML: () -> String = {
        if let text = self.text {
            return "<\(self.name)>\(text)</\(self.name)>"
        } else {
            return "<\(self.name) />"
        }
    }

    init(name: String, text: String? = nil) {
        self.name = name
        self.text = text
        print("\(name) 被初始化")
    }

    deinit {
        print("\(name) 被释放")
    }
}

var paragraph: HTMLElement? = HTMLElement(name: "p", text: "Hello, World!")
print(paragraph!.asHTML()) // 输出: <p>Hello, World!</p>

paragraph = nil
// 输出: p 被初始化
// 没有输出释放信息，因为闭包捕获了 self
```

在上面的示例中，`asHTML` 闭包捕获了 `self`，导致 `HTMLElement` 实例无法被释放。

### 解决方法：使用捕获列表

可以通过在闭包中使用捕获列表来避免强引用循环。

```swift
class HTMLElement {
    let name: String
    let text: String?

    lazy var asHTML: () -> String = { [weak self] in
        guard let self = self else { return "" }
        if let text = self.text {
            return "<\(self.name)>\(text)</\(self.name)>"
        } else {
            return "<\(self.name) />"
        }
    }

    init(name: String, text: String? = nil) {
        self.name = name
        self.text = text
        print("\(name) 被初始化")
    }

    deinit {
        print("\(name) 被释放")
    }
}

var paragraph: HTMLElement? = HTMLElement(name: "p", text: "Hello, World!")
print(paragraph!.asHTML()) // 输出: <p>Hello, World!</p>

paragraph = nil
// 输出: p 被初始化
// 输出: p 被释放
```

在上面的示例中，`asHTML` 闭包使用 `[weak self]` 捕获列表，避免了强引用循环。

---

## 总结

Swift 的内存管理机制（ARC）极大地简化了内存管理的工作，但开发者仍需注意强引用循环等问题。通过使用弱引用、无主引用和捕获列表，可以有效避免内存泄漏。

---

## 附加资源与练习

1. **练习**：尝试创建一个包含多个相互引用的类实例，并使用弱引用或无主引用来解决强引用循环。
2. **深入学习**：阅读 Swift 官方文档中关于 [ARC](https://docs.swift.org/swift-book/LanguageGuide/AutomaticReferenceCounting.html) 的部分，了解更多高级用法。
3. **扩展阅读**：了解 Swift 中的 `defer` 关键字及其在资源管理中的应用。

:::tip
在实际开发中，建议使用工具（如 Xcode 的内存调试器）来检测和修复内存泄漏问题。
:::