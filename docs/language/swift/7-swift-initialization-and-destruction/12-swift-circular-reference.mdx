---
title: Swift 循环引用
description: 了解Swift中的循环引用问题，学习如何通过弱引用和无主引用来避免内存泄漏。
---

# Swift 循环引用

在Swift中，内存管理是通过自动引用计数（ARC）来处理的。ARC会自动跟踪和管理对象的引用计数，当引用计数降为0时，对象会被释放。然而，在某些情况下，对象之间可能会相互持有强引用，导致引用计数无法降为0，从而引发内存泄漏。这种现象被称为**循环引用**。

## 什么是循环引用？

循环引用发生在两个或多个对象相互持有强引用时，导致它们都无法被释放。例如，对象A持有对象B的强引用，而对象B也持有对象A的强引用。这种情况下，即使没有其他对象引用A或B，它们的引用计数也不会降为0，从而导致内存泄漏。

## 代码示例

让我们通过一个简单的例子来理解循环引用：

```swift
class Person {
    var name: String
    var apartment: Apartment?

    init(name: String) {
        self.name = name
    }

    deinit {
        print("\(name) is being deinitialized")
    }
}

class Apartment {
    var unit: String
    var tenant: Person?

    init(unit: String) {
        self.unit = unit
    }

    deinit {
        print("Apartment \(unit) is being deinitialized")
    }
}

var john: Person? = Person(name: "John")
var unit4A: Apartment? = Apartment(unit: "4A")

john?.apartment = unit4A
unit4A?.tenant = john

john = nil
unit4A = nil
```

在这个例子中，`Person`实例`john`和`Apartment`实例`unit4A`相互持有强引用。即使我们将`john`和`unit4A`设置为`nil`，它们的`deinit`方法也不会被调用，因为它们之间的强引用导致引用计数无法降为0。

## 如何解决循环引用？

Swift提供了两种方式来解决循环引用问题：**弱引用（weak reference）**和**无主引用（unowned reference）**。

### 弱引用（Weak Reference）

弱引用不会增加对象的引用计数，因此不会阻止ARC释放对象。当对象被释放时，弱引用会自动设置为`nil`。弱引用通常用于可能为`nil`的情况。

让我们修改上面的例子，使用弱引用来解决循环引用问题：

```swift
class Person {
    var name: String
    var apartment: Apartment?

    init(name: String) {
        self.name = name
    }

    deinit {
        print("\(name) is being deinitialized")
    }
}

class Apartment {
    var unit: String
    weak var tenant: Person?

    init(unit: String) {
        self.unit = unit
    }

    deinit {
        print("Apartment \(unit) is being deinitialized")
    }
}

var john: Person? = Person(name: "John")
var unit4A: Apartment? = Apartment(unit: "4A")

john?.apartment = unit4A
unit4A?.tenant = john

john = nil
unit4A = nil
```

在这个修改后的例子中，`Apartment`类的`tenant`属性被声明为弱引用。当我们将`john`和`unit4A`设置为`nil`时，它们的`deinit`方法会被调用，因为弱引用不会阻止对象被释放。

### 无主引用（Unowned Reference）

无主引用也不会增加对象的引用计数，但它假设引用对象永远不会为`nil`。如果引用对象被释放，无主引用会导致运行时错误。无主引用通常用于引用对象的生命周期与当前对象的生命周期相同或更长的情况。

让我们看一个使用无主引用的例子：

```swift
class Customer {
    var name: String
    var card: CreditCard?

    init(name: String) {
        self.name = name
    }

    deinit {
        print("\(name) is being deinitialized")
    }
}

class CreditCard {
    let number: String
    unowned let customer: Customer

    init(number: String, customer: Customer) {
        self.number = number
        self.customer = customer
    }

    deinit {
        print("CreditCard #\(number) is being deinitialized")
    }
}

var john: Customer? = Customer(name: "John")
john?.card = CreditCard(number: "1234-5678-9012-3456", customer: john!)

john = nil
```

在这个例子中，`CreditCard`类的`customer`属性被声明为无主引用。当我们将`john`设置为`nil`时，`Customer`和`CreditCard`实例都会被正确释放。

## 实际应用场景

循环引用通常发生在以下场景中：

1. **父子关系**：父对象持有子对象的强引用，而子对象也持有父对象的强引用。
2. **委托模式**：委托对象持有委托者的强引用，而委托者也持有委托对象的强引用。
3. **闭包**：闭包捕获了对象的强引用，而对象也持有闭包的强引用。

在这些场景中，使用弱引用或无主引用可以有效地避免循环引用问题。

## 总结

循环引用是Swift中常见的内存管理问题，它会导致内存泄漏。通过使用弱引用和无主引用，我们可以有效地解决循环引用问题。弱引用适用于可能为`nil`的情况，而无主引用适用于引用对象的生命周期与当前对象的生命周期相同或更长的情况。

## 附加资源与练习

- **练习**：尝试在闭包中使用弱引用或无主引用来避免循环引用。
- **资源**：阅读Swift官方文档中关于[自动引用计数](https://docs.swift.org/swift-book/LanguageGuide/AutomaticReferenceCounting.html)的部分，了解更多关于内存管理的细节。

通过理解和应用这些概念，你将能够编写更加健壮和高效的Swift代码。