---
title: Swift 异步序列
description: 了解Swift中的异步序列（AsyncSequence），掌握如何使用它们处理异步数据流，并通过实际案例展示其应用场景。
---

# Swift 异步序列

在现代编程中，处理异步数据流是一个常见的需求。Swift 5.5 引入了 **异步序列（AsyncSequence）**，它允许我们以异步的方式处理一系列数据。与传统的同步序列不同，异步序列可以在数据到达时逐步处理，而不需要等待所有数据都准备好。

## 什么是异步序列？

异步序列是一种特殊的序列，它的元素是异步生成的。你可以将其理解为一个“懒加载”的序列，只有在需要时才会生成下一个元素。与 `Sequence` 类似，`AsyncSequence` 也提供了遍历元素的能力，但它是通过 `await` 关键字来实现的。

### 异步序列的核心概念

- **异步迭代器（AsyncIterator）**：类似于同步序列的迭代器，但它通过 `next()` 方法返回一个 `AsyncIterator.Element?` 类型的值，并且这个方法是一个异步函数。
- **异步序列协议（AsyncSequence）**：定义了如何通过异步迭代器遍历序列。

## 基本用法

让我们从一个简单的例子开始，了解如何使用异步序列。

```swift
import Foundation

struct Counter: AsyncSequence {
    typealias Element = Int
    let limit: Int

    struct AsyncIterator: AsyncIteratorProtocol {
        var current = 1
        let limit: Int

        mutating func next() async -> Int? {
            guard current <= limit else { return nil }
            let result = current
            current += 1
            return result
        }
    }

    func makeAsyncIterator() -> AsyncIterator {
        return AsyncIterator(limit: limit)
    }
}

Task {
    for await number in Counter(limit: 5) {
        print(number)
    }
}
```

### 代码解释

1. **定义异步序列**：我们定义了一个 `Counter` 结构体，它实现了 `AsyncSequence` 协议。
2. **实现异步迭代器**：`AsyncIterator` 结构体实现了 `AsyncIteratorProtocol`，并在 `next()` 方法中生成序列的下一个元素。
3. **遍历异步序列**：在 `Task` 中，我们使用 `for await` 循环遍历 `Counter` 生成的序列。

### 输出

```
1
2
3
4
5
```

## 实际应用场景

异步序列在处理网络请求、文件读取或实时数据流时非常有用。例如，假设我们需要从服务器获取一系列数据，并在数据到达时逐步处理：

```swift
import Foundation

struct DataFetcher: AsyncSequence {
    typealias Element = Data
    let urls: [URL]

    struct AsyncIterator: AsyncIteratorProtocol {
        var index = 0
        let urls: [URL]

        mutating func next() async throws -> Data? {
            guard index < urls.count else { return nil }
            let url = urls[index]
            index += 1
            let (data, _) = try await URLSession.shared.data(from: url)
            return data
        }
    }

    func makeAsyncIterator() -> AsyncIterator {
        return AsyncIterator(urls: urls)
    }
}

Task {
    let urls = [
        URL(string: "https://example.com/data1")!,
        URL(string: "https://example.com/data2")!,
        URL(string: "https://example.com/data3")!
    ]

    for try await data in DataFetcher(urls: urls) {
        print("Received data: \(data)")
    }
}
```

### 代码解释

1. **定义异步序列**：`DataFetcher` 结构体实现了 `AsyncSequence` 协议，用于从多个 URL 异步获取数据。
2. **实现异步迭代器**：`AsyncIterator` 结构体实现了 `AsyncIteratorProtocol`，并在 `next()` 方法中通过 `URLSession` 获取数据。
3. **遍历异步序列**：在 `Task` 中，我们使用 `for try await` 循环遍历 `DataFetcher` 生成的序列。

:::tip
在实际开发中，异步序列非常适合处理需要逐步加载或处理的场景，例如分页数据、实时数据流等。
:::

## 总结

异步序列是 Swift 并发编程中的一个强大工具，它允许我们以异步的方式处理数据流。通过 `AsyncSequence` 和 `AsyncIteratorProtocol`，我们可以轻松地实现异步数据生成和处理。

### 附加资源

- [Swift 官方文档 - AsyncSequence](https://developer.apple.com/documentation/swift/asyncsequence)
- [Swift 并发编程指南](https://docs.swift.org/swift-book/LanguageGuide/Concurrency.html)

### 练习

1. 尝试实现一个异步序列，生成斐波那契数列的前 10 个数。
2. 修改 `DataFetcher` 示例，使其在获取数据时显示加载进度。

通过学习和实践，你将能够更好地掌握 Swift 中的异步序列，并在实际项目中灵活运用它们。