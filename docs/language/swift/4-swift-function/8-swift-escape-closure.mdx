---
title: Swift 逃逸闭包
description: 了解Swift中的逃逸闭包，掌握其定义、使用场景以及如何在实际开发中应用。
---

## 什么是逃逸闭包？

在Swift中，闭包（Closure）是一种自包含的功能块，可以在代码中传递和使用。逃逸闭包（Escaping Closure）是指一个闭包作为参数传递给函数，但在函数返回之后才被调用。换句话说，逃逸闭包的生命周期超出了函数的执行范围。

:::note
逃逸闭包通常用于异步操作，例如网络请求或延迟执行的任务。
:::

## 逃逸闭包的基本语法

在Swift中，如果一个闭包可能会在函数返回之后才被调用，我们需要使用 `@escaping` 关键字来标记它。以下是一个简单的示例：

```swift
func someFunctionWithEscapingClosure(completionHandler: @escaping () -> Void) {
    DispatchQueue.main.asyncAfter(deadline: .now() + 1) {
        completionHandler()
    }
}
```

在这个例子中，`completionHandler` 闭包被标记为 `@escaping`，因为它会在 `someFunctionWithEscapingClosure` 函数返回之后才被调用。

## 逃逸闭包的使用场景

逃逸闭包通常用于以下场景：

1. **异步操作**：例如网络请求、定时器等。
2. **存储闭包**：将闭包存储在某个属性中，以便稍后调用。

### 示例：异步网络请求

假设我们有一个函数，用于从网络获取数据，并在数据返回后执行某个操作：

```swift
func fetchData(completion: @escaping (Data?) -> Void) {
    URLSession.shared.dataTask(with: URL(string: "https://example.com/data")!) { data, response, error in
        completion(data)
    }.resume()
}
```

在这个例子中，`completion` 闭包被标记为 `@escaping`，因为它会在网络请求完成后才被调用。

## 逃逸闭包与内存管理

由于逃逸闭包的生命周期可能超出函数的执行范围，因此在使用逃逸闭包时需要注意内存管理问题，特别是避免循环引用。

### 示例：避免循环引用

在Swift中，我们可以使用 `[weak self]` 来避免循环引用：

```swift
class SomeClass {
    var completionHandler: (() -> Void)?

    func doSomething() {
        someFunctionWithEscapingClosure { [weak self] in
            self?.someMethod()
        }
    }

    func someMethod() {
        print("Method called")
    }
}
```

在这个例子中，`[weak self]` 确保了闭包不会强引用 `self`，从而避免了循环引用。

## 实际应用案例

### 案例：延迟执行任务

假设我们需要在用户点击按钮后延迟1秒执行某个任务：

```swift
func performTaskAfterDelay(completion: @escaping () -> Void) {
    DispatchQueue.main.asyncAfter(deadline: .now() + 1) {
        completion()
    }
}

performTaskAfterDelay {
    print("Task executed after 1 second")
}
```

在这个案例中，`performTaskAfterDelay` 函数使用逃逸闭包来延迟执行任务。

## 总结

逃逸闭包是Swift中一个重要的概念，特别是在处理异步操作和延迟任务时。通过使用 `@escaping` 关键字，我们可以确保闭包在函数返回之后仍然可以被调用。同时，我们也需要注意内存管理，避免循环引用。

## 附加资源与练习

- **练习**：尝试编写一个函数，使用逃逸闭包来处理一个异步任务，例如模拟网络请求。
- **资源**：阅读Swift官方文档中关于闭包和逃逸闭包的更多内容。

:::tip
在实际开发中，逃逸闭包的使用非常广泛。掌握它可以帮助你更好地处理异步任务和延迟执行的操作。
:::