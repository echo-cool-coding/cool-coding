---
title: Swift 类专属协议
description: 了解Swift中的类专属协议，掌握如何限制协议只能被类类型遵循，并通过实际案例展示其应用场景。
---

# Swift 类专属协议

在Swift中，协议（Protocol）是一种强大的工具，用于定义方法、属性和其他需求的蓝图。通常情况下，协议可以被类、结构体和枚举遵循。然而，有时我们希望限制某个协议只能被类类型遵循，这就是**类专属协议**的用武之地。

## 什么是类专属协议？

类专属协议是一种只能被类类型遵循的协议。通过将协议标记为类专属，我们可以确保只有类能够遵循该协议，而结构体和枚举则不能。这在某些场景下非常有用，例如当协议中定义了需要引用语义的方法或属性时。

### 如何定义类专属协议？

在Swift中，我们可以通过在协议继承列表中添加 `AnyObject` 来定义一个类专属协议。例如：

```swift
protocol ClassOnlyProtocol: AnyObject {
    func doSomething()
}
```

在上面的例子中，`ClassOnlyProtocol` 只能被类类型遵循。如果尝试让结构体或枚举遵循该协议，编译器会报错。

## 为什么需要类专属协议？

类专属协议的主要用途是确保协议中的方法或属性能够安全地使用引用语义。由于类类型是引用类型，而结构体和枚举是值类型，某些操作（如弱引用）只能在引用类型中使用。

### 示例场景

假设我们有一个协议 `DelegateProtocol`，它定义了一个方法 `didUpdateData()`。我们希望这个协议只能被类遵循，因为我们需要在协议中使用弱引用以避免循环引用问题。

```swift
protocol DelegateProtocol: AnyObject {
    func didUpdateData()
}

class MyClass: DelegateProtocol {
    func didUpdateData() {
        print("Data updated!")
    }
}

// 以下代码会导致编译错误，因为结构体不能遵循类专属协议
// struct MyStruct: DelegateProtocol {
//     func didUpdateData() {
//         print("Data updated!")
//     }
// }
```

在上面的例子中，`MyClass` 可以成功遵循 `DelegateProtocol`，而 `MyStruct` 则不能，因为 `DelegateProtocol` 是一个类专属协议。

## 实际应用案例

### 1. 委托模式

委托模式是类专属协议的典型应用场景。在委托模式中，我们通常希望委托对象是一个类，以便我们可以使用弱引用来避免循环引用问题。

```swift
protocol DataSourceDelegate: AnyObject {
    func didReceiveData(_ data: String)
}

class DataSource {
    weak var delegate: DataSourceDelegate?

    func fetchData() {
        let data = "Some data"
        delegate?.didReceiveData(data)
    }
}

class ViewController: DataSourceDelegate {
    let dataSource = DataSource()

    init() {
        dataSource.delegate = self
        dataSource.fetchData()
    }

    func didReceiveData(_ data: String) {
        print("Received data: \(data)")
    }
}
```

在这个例子中，`DataSourceDelegate` 是一个类专属协议，确保只有类类型可以作为委托对象。

### 2. 依赖注入

在依赖注入场景中，我们可能希望某些依赖项只能是类类型。通过使用类专属协议，我们可以确保依赖项符合这一要求。

```swift
protocol ServiceProtocol: AnyObject {
    func performTask()
}

class Service: ServiceProtocol {
    func performTask() {
        print("Task performed!")
    }
}

class Client {
    let service: ServiceProtocol

    init(service: ServiceProtocol) {
        self.service = service
    }

    func execute() {
        service.performTask()
    }
}

let service = Service()
let client = Client(service: service)
client.execute()
```

在这个例子中，`ServiceProtocol` 是一个类专属协议，确保 `Client` 只能接受类类型的依赖项。

## 总结

类专属协议是Swift中一种强大的工具，用于限制协议只能被类类型遵循。通过使用 `AnyObject` 标记协议，我们可以确保协议中的方法和属性能够安全地使用引用语义。类专属协议在委托模式、依赖注入等场景中非常有用。

### 附加资源

- [Swift官方文档 - 协议](https://docs.swift.org/swift-book/LanguageGuide/Protocols.html)
- [Swift官方文档 - 类与结构体](https://docs.swift.org/swift-book/LanguageGuide/ClassesAndStructures.html)

### 练习

1. 定义一个类专属协议 `LoggerProtocol`，要求遵循该协议的类实现一个方法 `log(message: String)`。
2. 创建一个类 `ConsoleLogger`，遵循 `LoggerProtocol` 并实现 `log(message: String)` 方法，将消息打印到控制台。
3. 尝试让一个结构体遵循 `LoggerProtocol`，观察编译器的错误提示。

通过完成这些练习，你将更好地理解类专属协议的概念及其应用场景。