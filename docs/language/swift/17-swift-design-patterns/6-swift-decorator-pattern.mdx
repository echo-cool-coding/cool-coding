---
title: Swift 装饰器模式
description: 了解如何在 Swift 中使用装饰器模式动态扩展对象的行为，同时保持代码的灵活性和可维护性。
---

## 介绍

装饰器模式（Decorator Pattern）是一种结构型设计模式，它允许你通过将对象放入包含行为的特殊封装对象中来动态地扩展对象的行为。装饰器模式的核心思想是**在不修改原始类的情况下**，为对象添加新的功能。

在 Swift 中，装饰器模式通常通过协议和组合来实现。它非常适合在需要动态添加功能或避免使用继承的情况下使用。

## 装饰器模式的基本概念

装饰器模式的核心组件包括：

1. **组件（Component）**：定义了一个接口，可以是协议或基类，表示被装饰的对象。
2. **具体组件（Concrete Component）**：实现了组件接口的具体类。
3. **装饰器（Decorator）**：持有一个组件对象，并实现了组件接口。它可以在调用组件的方法前后添加额外的行为。
4. **具体装饰器（Concrete Decorator）**：实现了装饰器接口的具体类，负责添加新的功能。

## 代码示例

让我们通过一个简单的例子来理解装饰器模式。假设我们有一个 `Coffee` 协议，表示咖啡的基本功能，然后我们通过装饰器模式为咖啡添加额外的配料。

```swift
// 1. 定义组件协议
protocol Coffee {
    func cost() -> Double
    func description() -> String
}

// 2. 实现具体组件
class SimpleCoffee: Coffee {
    func cost() -> Double {
        return 5.0
    }
    
    func description() -> String {
        return "Simple Coffee"
    }
}

// 3. 定义装饰器基类
class CoffeeDecorator: Coffee {
    private let decoratedCoffee: Coffee
    
    init(_ coffee: Coffee) {
        self.decoratedCoffee = coffee
    }
    
    func cost() -> Double {
        return decoratedCoffee.cost()
    }
    
    func description() -> String {
        return decoratedCoffee.description()
    }
}

// 4. 实现具体装饰器
class MilkDecorator: CoffeeDecorator {
    override func cost() -> Double {
        return super.cost() + 2.0
    }
    
    override func description() -> String {
        return super.description() + ", Milk"
    }
}

class SugarDecorator: CoffeeDecorator {
    override func cost() -> Double {
        return super.cost() + 1.0
    }
    
    override func description() -> String {
        return super.description() + ", Sugar"
    }
}

// 5. 使用装饰器
let coffee: Coffee = SimpleCoffee()
print("Cost: \(coffee.cost()), Description: \(coffee.description())")

let milkCoffee: Coffee = MilkDecorator(coffee)
print("Cost: \(milkCoffee.cost()), Description: \(milkCoffee.description())")

let sugarMilkCoffee: Coffee = SugarDecorator(milkCoffee)
print("Cost: \(sugarMilkCoffee.cost()), Description: \(sugarMilkCoffee.description())")
```

**输出：**
```
Cost: 5.0, Description: Simple Coffee
Cost: 7.0, Description: Simple Coffee, Milk
Cost: 8.0, Description: Simple Coffee, Milk, Sugar
```

在这个例子中，我们通过装饰器模式动态地为咖啡添加了牛奶和糖的功能，而不需要修改原始的 `SimpleCoffee` 类。

## 实际应用场景

装饰器模式在以下场景中非常有用：

1. **动态扩展功能**：当你需要在运行时为对象添加功能时，装饰器模式是一个很好的选择。例如，在 GUI 框架中，你可以动态地为按钮添加边框、阴影等效果。
2. **避免继承的复杂性**：如果你发现需要通过继承来扩展类的功能，但继承层次变得过于复杂，装饰器模式可以帮助你简化设计。
3. **遵循开闭原则**：装饰器模式允许你扩展对象的功能，而不需要修改原始类的代码，从而遵循了开闭原则。

## 总结

装饰器模式是一种强大的设计模式，它允许你动态地扩展对象的功能，同时保持代码的灵活性和可维护性。通过使用协议和组合，你可以在 Swift 中轻松实现装饰器模式。

:::tip
装饰器模式与继承相比，提供了更大的灵活性，因为它允许你在运行时动态地添加或移除功能。
:::

## 附加资源与练习

1. **练习**：尝试为 `Coffee` 添加一个新的装饰器，例如 `WhippedCreamDecorator`，并测试它的功能。
2. **进一步学习**：阅读更多关于设计模式的书籍，例如《设计模式：可复用面向对象软件的基础》。
3. **实践**：在你的项目中找到一个适合使用装饰器模式的场景，并尝试实现它。

通过不断实践和学习，你将能够更好地理解和应用装饰器模式。