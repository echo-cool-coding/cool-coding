---
title: Swift 无主引用
description: 了解 Swift 中的无主引用（Unowned Reference），掌握其与弱引用的区别，以及如何在实际开发中正确使用无主引用来避免循环引用。
---

# Swift 无主引用

在 Swift 中，内存管理是一个非常重要的主题。Swift 使用自动引用计数（ARC）来管理内存，但有时我们需要手动处理对象之间的引用关系，以避免循环引用。无主引用（Unowned Reference）是 Swift 提供的一种工具，用于解决某些特定场景下的循环引用问题。

## 什么是无主引用？

无主引用是一种不会增加引用计数的引用类型。与弱引用（Weak Reference）类似，无主引用不会阻止 ARC 释放对象。但与弱引用不同的是，无主引用假定引用的对象在其生命周期内始终存在，因此不会自动设置为 `nil`。

:::caution 注意
无主引用假设引用的对象在其生命周期内始终存在。如果引用的对象被释放，访问无主引用会导致运行时崩溃。
:::

## 无主引用与弱引用的区别

- **弱引用**：弱引用是可选类型，当引用的对象被释放时，弱引用会自动设置为 `nil`。
- **无主引用**：无主引用是非可选类型，它假定引用的对象在其生命周期内始终存在。如果引用的对象被释放，访问无主引用会导致崩溃。

## 无主引用的使用场景

无主引用通常用于以下场景：

1. **两个对象之间存在父子关系**：父对象拥有子对象，子对象引用父对象时可以使用无主引用，因为父对象的生命周期通常比子对象长。
2. **闭包捕获列表**：在闭包中捕获 `self` 时，如果闭包的生命周期与 `self` 相同，可以使用无主引用来避免循环引用。

## 代码示例

### 示例 1：父子关系中的无主引用

```swift
class Parent {
    var child: Child?

    init() {
        print("Parent initialized")
    }

    deinit {
        print("Parent deinitialized")
    }
}

class Child {
    unowned let parent: Parent

    init(parent: Parent) {
        self.parent = parent
        print("Child initialized")
    }

    deinit {
        print("Child deinitialized")
    }
}

var parent: Parent? = Parent()
parent?.child = Child(parent: parent!)
parent = nil
```

**输出：**
```
Parent initialized
Child initialized
Parent deinitialized
Child deinitialized
```

在这个例子中，`Child` 类使用无主引用来引用 `Parent` 对象。当 `parent` 被设置为 `nil` 时，`Parent` 和 `Child` 对象都会被正确释放。

### 示例 2：闭包中的无主引用

```swift
class ViewController {
    var onButtonTapped: (() -> Void)?

    init() {
        onButtonTapped = { [unowned self] in
            self.handleButtonTap()
        }
    }

    func handleButtonTap() {
        print("Button tapped")
    }

    deinit {
        print("ViewController deinitialized")
    }
}

var viewController: ViewController? = ViewController()
viewController?.onButtonTapped?()
viewController = nil
```

**输出：**
```
Button tapped
ViewController deinitialized
```

在这个例子中，闭包使用无主引用来捕获 `self`，从而避免了循环引用。当 `viewController` 被设置为 `nil` 时，`ViewController` 对象会被正确释放。

## 实际应用场景

无主引用在实际开发中非常有用，尤其是在处理视图控制器、网络请求等场景时。例如，在网络请求的回调中，如果回调闭包的生命周期与视图控制器相同，可以使用无主引用来避免循环引用。

## 总结

无主引用是 Swift 中一种强大的工具，用于解决特定场景下的循环引用问题。与弱引用不同，无主引用假定引用的对象在其生命周期内始终存在，因此不会自动设置为 `nil`。正确使用无主引用可以避免内存泄漏，但需要谨慎处理，以避免运行时崩溃。

## 附加资源

- [Swift 官方文档 - Automatic Reference Counting](https://docs.swift.org/swift-book/LanguageGuide/AutomaticReferenceCounting.html)
- [Swift 内存管理指南](https://www.raywenderlich.com/books/swift-apprentice/v6.0/chapters/21-memory-management)

## 练习

1. 修改上面的代码示例，将无主引用改为弱引用，观察输出结果的变化。
2. 尝试在实际项目中找到一个可以使用无主引用的场景，并实现它。