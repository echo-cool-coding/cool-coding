---
title: Go 原子操作
description: 了解Go语言中的原子操作，掌握如何在并发编程中安全地操作共享变量。
---

# Go 原子操作

在并发编程中，多个goroutine同时访问和修改共享变量可能会导致数据竞争（data race）问题。为了避免这种情况，Go语言提供了**原子操作**（atomic operations），这些操作能够确保在并发环境中对共享变量的操作是安全的。

## 什么是原子操作？

原子操作是指在执行过程中不会被中断的操作。在多线程或goroutine并发执行的环境中，原子操作能够确保对共享变量的操作是**不可分割**的，即在同一时刻只有一个goroutine能够成功执行该操作。

Go语言中的原子操作通过`sync/atomic`包来实现。该包提供了一系列函数，用于对整数类型（如`int32`、`int64`等）和指针类型进行原子操作。

## 原子操作的基本用法

### 1. 原子加载（Load）

原子加载操作用于安全地读取共享变量的值。以下是一个简单的例子：

```go
package main

import (
    "fmt"
    "sync/atomic"
    "time"
)

func main() {
    var count int32 = 0

    go func() {
        for {
            time.Sleep(time.Millisecond * 500)
            atomic.AddInt32(&count, 1)
        }
    }()

    for i := 0; i < 5; i++ {
        time.Sleep(time.Second)
        fmt.Println("Current count:", atomic.LoadInt32(&count))
    }
}
```

**输出：**
```
Current count: 2
Current count: 4
Current count: 6
Current count: 8
Current count: 10
```

在这个例子中，`atomic.LoadInt32`用于安全地读取`count`的值，而`atomic.AddInt32`用于原子地增加`count`的值。

### 2. 原子存储（Store）

原子存储操作用于安全地设置共享变量的值。以下是一个例子：

```go
package main

import (
    "fmt"
    "sync/atomic"
    "time"
)

func main() {
    var count int32 = 0

    go func() {
        for {
            time.Sleep(time.Millisecond * 500)
            atomic.StoreInt32(&count, 10)
        }
    }()

    for i := 0; i < 5; i++ {
        time.Sleep(time.Second)
        fmt.Println("Current count:", atomic.LoadInt32(&count))
    }
}
```

**输出：**
```
Current count: 10
Current count: 10
Current count: 10
Current count: 10
Current count: 10
```

在这个例子中，`atomic.StoreInt32`用于原子地将`count`的值设置为10。

### 3. 原子加法（Add）

原子加法操作用于原子地增加共享变量的值。以下是一个例子：

```go
package main

import (
    "fmt"
    "sync/atomic"
    "time"
)

func main() {
    var count int32 = 0

    go func() {
        for {
            time.Sleep(time.Millisecond * 500)
            atomic.AddInt32(&count, 1)
        }
    }()

    for i := 0; i < 5; i++ {
        time.Sleep(time.Second)
        fmt.Println("Current count:", atomic.LoadInt32(&count))
    }
}
```

**输出：**
```
Current count: 2
Current count: 4
Current count: 6
Current count: 8
Current count: 10
```

在这个例子中，`atomic.AddInt32`用于原子地增加`count`的值。

### 4. 原子比较并交换（Compare and Swap, CAS）

原子比较并交换操作用于原子地比较共享变量的值，并在值匹配时进行交换。以下是一个例子：

```go
package main

import (
    "fmt"
    "sync/atomic"
)

func main() {
    var count int32 = 0

    // 尝试将count从0改为1
    swapped := atomic.CompareAndSwapInt32(&count, 0, 1)
    fmt.Println("Swapped:", swapped, "Count:", count)

    // 再次尝试将count从0改为1，此时count已经是1，交换失败
    swapped = atomic.CompareAndSwapInt32(&count, 0, 1)
    fmt.Println("Swapped:", swapped, "Count:", count)
}
```

**输出：**
```
Swapped: true Count: 1
Swapped: false Count: 1
```

在这个例子中，`atomic.CompareAndSwapInt32`用于原子地比较`count`的值，并在值匹配时进行交换。

## 实际应用场景

### 1. 计数器

在并发环境中，多个goroutine可能同时修改一个计数器。使用原子操作可以确保计数器的值被正确更新，而不会出现数据竞争问题。

```go
package main

import (
    "fmt"
    "sync"
    "sync/atomic"
)

func main() {
    var count int32 = 0
    var wg sync.WaitGroup

    for i := 0; i < 100; i++ {
        wg.Add(1)
        go func() {
            defer wg.Done()
            atomic.AddInt32(&count, 1)
        }()
    }

    wg.Wait()
    fmt.Println("Final count:", count)
}
```

**输出：**
```
Final count: 100
```

### 2. 标志位

在并发环境中，标志位（flag）通常用于控制某些操作的执行。使用原子操作可以确保标志位的修改是线程安全的。

```go
package main

import (
    "fmt"
    "sync"
    "sync/atomic"
    "time"
)

func main() {
    var flag int32 = 0
    var wg sync.WaitGroup

    wg.Add(1)
    go func() {
        defer wg.Done()
        for atomic.LoadInt32(&flag) == 0 {
            // 等待flag被设置为1
        }
        fmt.Println("Flag is set to 1")
    }()

    time.Sleep(time.Second)
    atomic.StoreInt32(&flag, 1)
    wg.Wait()
}
```

**输出：**
```
Flag is set to 1
```

## 总结

原子操作是Go语言中处理并发编程的重要工具之一。通过使用`sync/atomic`包提供的原子操作函数，可以确保在并发环境中对共享变量的操作是安全的，从而避免数据竞争问题。

:::tip
在实际开发中，如果只需要简单的并发控制，原子操作是一个轻量级的选择。但对于更复杂的并发场景，可能需要使用`sync.Mutex`或`sync.RWMutex`等同步原语。
:::

## 附加资源

- [Go官方文档 - sync/atomic](https://golang.org/pkg/sync/atomic/)
- [Go并发编程实战](https://www.oreilly.com/library/view/concurrency-in-go/9781491941294/)

## 练习

1. 修改计数器示例，使其在达到某个阈值时停止增加。
2. 尝试使用原子操作实现一个简单的自旋锁（spinlock）。
3. 编写一个程序，使用原子操作实现多个goroutine之间的同步。