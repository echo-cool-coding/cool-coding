---
title: Go 并发陷阱
description: 了解Go语言中常见的并发陷阱，帮助初学者避免在并发编程中犯错。
---

# Go 并发陷阱

Go语言以其简洁的并发模型而闻名，尤其是通过goroutine和channel实现的并发编程。然而，并发编程本身是复杂的，即使是经验丰富的开发者也可能陷入一些常见的陷阱。本文将介绍Go语言中常见的并发陷阱，并通过代码示例和实际案例帮助你更好地理解这些问题。

## 什么是并发陷阱？

并发陷阱是指在编写并发程序时，由于对并发机制理解不足或使用不当，导致程序出现难以调试的错误或性能问题。这些陷阱可能包括竞态条件、死锁、goroutine泄漏等。

## 1. 竞态条件（Race Condition）

竞态条件是指多个goroutine同时访问共享资源，且至少有一个goroutine在写入数据时，程序的输出依赖于goroutine的执行顺序。这会导致程序的行为不可预测。

### 示例代码

```go
package main

import (
    "fmt"
    "sync"
)

var counter int

func increment(wg *sync.WaitGroup) {
    defer wg.Done()
    counter++
}

func main() {
    var wg sync.WaitGroup
    for i := 0; i < 1000; i++ {
        wg.Add(1)
        go increment(&wg)
    }
    wg.Wait()
    fmt.Println("Counter:", counter)
}
```

### 输出

每次运行程序时，`Counter`的值可能不同，这是因为多个goroutine同时修改`counter`变量，导致竞态条件。

### 解决方法

使用`sync.Mutex`或`sync/atomic`包来保护共享资源的访问。

```go
package main

import (
    "fmt"
    "sync"
)

var (
    counter int
    mutex   sync.Mutex
)

func increment(wg *sync.WaitGroup) {
    defer wg.Done()
    mutex.Lock()
    counter++
    mutex.Unlock()
}

func main() {
    var wg sync.WaitGroup
    for i := 0; i < 1000; i++ {
        wg.Add(1)
        go increment(&wg)
    }
    wg.Wait()
    fmt.Println("Counter:", counter)
}
```

### 输出

现在，`Counter`的值将始终为1000，因为`mutex`确保了每次只有一个goroutine可以修改`counter`。

## 2. 死锁（Deadlock）

死锁是指两个或多个goroutine相互等待对方释放资源，导致程序无法继续执行。

### 示例代码

```go
package main

import (
    "fmt"
    "sync"
)

func main() {
    var mu1, mu2 sync.Mutex
    var wg sync.WaitGroup

    wg.Add(2)
    go func() {
        defer wg.Done()
        mu1.Lock()
        defer mu1.Unlock()
        mu2.Lock()
        defer mu2.Unlock()
        fmt.Println("Goroutine 1")
    }()

    go func() {
        defer wg.Done()
        mu2.Lock()
        defer mu2.Unlock()
        mu1.Lock()
        defer mu1.Unlock()
        fmt.Println("Goroutine 2")
    }()

    wg.Wait()
}
```

### 输出

程序将陷入死锁，因为两个goroutine分别持有`mu1`和`mu2`，并试图获取对方持有的锁。

### 解决方法

避免死锁的一种方法是确保所有goroutine以相同的顺序获取锁。

```go
package main

import (
    "fmt"
    "sync"
)

func main() {
    var mu1, mu2 sync.Mutex
    var wg sync.WaitGroup

    wg.Add(2)
    go func() {
        defer wg.Done()
        mu1.Lock()
        defer mu1.Unlock()
        mu2.Lock()
        defer mu2.Unlock()
        fmt.Println("Goroutine 1")
    }()

    go func() {
        defer wg.Done()
        mu1.Lock()
        defer mu1.Unlock()
        mu2.Lock()
        defer mu2.Unlock()
        fmt.Println("Goroutine 2")
    }()

    wg.Wait()
}
```

### 输出

现在，程序将正常执行，因为两个goroutine以相同的顺序获取锁。

## 3. Goroutine泄漏

Goroutine泄漏是指goroutine在完成任务后没有被正确终止，导致资源浪费。

### 示例代码

```go
package main

import (
    "fmt"
    "time"
)

func worker(ch chan int) {
    for {
        select {
        case <-ch:
            fmt.Println("Received data")
        default:
            // Do nothing
        }
    }
}

func main() {
    ch := make(chan int)
    go worker(ch)
    time.Sleep(1 * time.Second)
}
```

### 输出

`worker` goroutine将一直运行，即使`main`函数已经退出，导致goroutine泄漏。

### 解决方法

使用`context`或`done` channel来通知goroutine退出。

```go
package main

import (
    "context"
    "fmt"
    "time"
)

func worker(ctx context.Context, ch chan int) {
    for {
        select {
        case <-ch:
            fmt.Println("Received data")
        case <-ctx.Done():
            fmt.Println("Worker exiting")
            return
        }
    }
}

func main() {
    ch := make(chan int)
    ctx, cancel := context.WithCancel(context.Background())
    go worker(ctx, ch)
    time.Sleep(1 * time.Second)
    cancel()
    time.Sleep(1 * time.Second)
}
```

### 输出

`worker` goroutine将在接收到`ctx.Done()`信号后退出，避免了goroutine泄漏。

## 实际案例

在实际开发中，并发陷阱可能会导致严重的性能问题或系统崩溃。例如，在一个高并发的Web服务器中，如果未正确处理竞态条件，可能会导致数据不一致或服务不可用。

### 案例：Web服务器中的竞态条件

假设你正在开发一个Web服务器，多个请求同时修改一个全局计数器。如果不使用锁来保护计数器，可能会导致计数器的值不正确。

```go
package main

import (
    "fmt"
    "net/http"
    "sync"
)

var counter int
var mutex sync.Mutex

func handler(w http.ResponseWriter, r *http.Request) {
    mutex.Lock()
    counter++
    mutex.Unlock()
    fmt.Fprintf(w, "Counter: %d", counter)
}

func main() {
    http.HandleFunc("/", handler)
    http.ListenAndServe(":8080", nil)
}
```

在这个例子中，`mutex`确保了每次只有一个请求可以修改`counter`，从而避免了竞态条件。

## 总结

并发编程是Go语言的一大优势，但也伴随着许多陷阱。通过理解竞态条件、死锁和goroutine泄漏等常见问题，并学会使用`sync.Mutex`、`context`等工具，你可以编写出更安全、更高效的并发程序。

## 附加资源

- [Go官方文档 - 并发](https://golang.org/doc/effective_go#concurrency)
- [Go by Example: Goroutines](https://gobyexample.com/goroutines)
- [Go by Example: Channels](https://gobyexample.com/channels)

## 练习

1. 修改以下代码，使其避免竞态条件：

```go
package main

import (
    "fmt"
    "sync"
)

var counter int

func increment(wg *sync.WaitGroup) {
    defer wg.Done()
    counter++
}

func main() {
    var wg sync.WaitGroup
    for i := 0; i < 1000; i++ {
        wg.Add(1)
        go increment(&wg)
    }
    wg.Wait()
    fmt.Println("Counter:", counter)
}
```

2. 编写一个程序，使用`context`来避免goroutine泄漏。

通过不断练习和深入学习，你将能够更好地掌握Go语言的并发编程技巧，并避免常见的并发陷阱。