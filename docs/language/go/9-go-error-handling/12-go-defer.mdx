---
title: Go Defer
description: "了解 Go 语言中的 defer 关键字，掌握其用法、工作原理以及在实际开发中的应用场景。"
---

# Go Defer

在 Go 语言中，`defer` 是一个非常有用的关键字，用于延迟执行某个函数或方法调用。它的主要作用是确保某些操作在函数返回之前被执行，无论函数是通过正常返回还是由于错误而提前返回。`defer` 常用于资源清理、文件关闭、解锁等场景。

## 什么是 `defer`？

`defer` 关键字用于延迟执行一个函数调用，直到包含它的函数执行完毕。无论函数是正常返回还是由于 panic 而提前退出，`defer` 语句都会被执行。这使得 `defer` 成为处理资源清理和确保某些操作在函数结束时执行的理想工具。

### 基本语法

```go
defer functionCall()
```

在上面的代码中，`functionCall()` 会在包含它的函数返回之前执行。

## `defer` 的工作原理

当 Go 编译器遇到 `defer` 语句时，它会将 `defer` 后面的函数调用压入一个栈中。这个栈遵循“后进先出”（LIFO）的原则，也就是说，最后被压入栈的 `defer` 语句会最先执行。

### 示例代码

```go
package main

import "fmt"

func main() {
    defer fmt.Println("First defer")
    defer fmt.Println("Second defer")
    fmt.Println("Main function")
}
```

**输出：**

```
Main function
Second defer
First defer
```

在这个例子中，`fmt.Println("First defer")` 和 `fmt.Println("Second defer")` 都被延迟执行。由于 `defer` 语句遵循 LIFO 原则，因此 `Second defer` 会先于 `First defer` 执行。

## `defer` 的实际应用

### 1. 文件操作

在处理文件时，我们通常需要在操作完成后关闭文件。使用 `defer` 可以确保文件在函数返回时被关闭，即使函数在执行过程中发生了错误。

```go
package main

import (
    "fmt"
    "os"
)

func main() {
    file, err := os.Open("example.txt")
    if err != nil {
        fmt.Println("Error opening file:", err)
        return
    }
    defer file.Close()

    // 文件操作代码
    fmt.Println("File opened successfully")
}
```

在这个例子中，`file.Close()` 会在 `main` 函数返回之前执行，确保文件被正确关闭。

### 2. 资源清理

`defer` 也常用于资源清理，例如释放锁或关闭数据库连接。

```go
package main

import (
    "fmt"
    "sync"
)

var mu sync.Mutex

func criticalSection() {
    mu.Lock()
    defer mu.Unlock()

    // 临界区代码
    fmt.Println("Critical section executed")
}

func main() {
    criticalSection()
}
```

在这个例子中，`mu.Unlock()` 会在 `criticalSection` 函数返回之前执行，确保锁被正确释放。

### 3. 错误处理

`defer` 可以与 `recover` 结合使用，用于捕获和处理 panic。

```go
package main

import "fmt"

func recoverFromPanic() {
    if r := recover(); r != nil {
        fmt.Println("Recovered from panic:", r)
    }
}

func mayPanic() {
    defer recoverFromPanic()
    panic("something went wrong")
}

func main() {
    mayPanic()
    fmt.Println("Program continues after panic")
}
```

**输出：**

```
Recovered from panic: something went wrong
Program continues after panic
```

在这个例子中，`recoverFromPanic` 函数会在 `mayPanic` 函数发生 panic 时被调用，从而捕获并处理 panic。

## `defer` 的注意事项

1. **参数求值**：`defer` 语句中的函数参数会在 `defer` 语句执行时立即求值，而不是在函数返回时求值。

    ```go
    package main

    import "fmt"

    func main() {
        i := 0
        defer fmt.Println(i) // i 的值是 0
        i++
        fmt.Println(i) // i 的值是 1
    }
    ```

    **输出：**

    ```
    1
    0
    ```

    在这个例子中，`fmt.Println(i)` 的参数 `i` 在 `defer` 语句执行时被求值为 `0`，即使 `i` 在函数返回之前被修改为 `1`。

2. **多个 `defer` 的执行顺序**：多个 `defer` 语句会按照“后进先出”的顺序执行。

    ```go
    package main

    import "fmt"

    func main() {
        defer fmt.Println("First")
        defer fmt.Println("Second")
        defer fmt.Println("Third")
    }
    ```

    **输出：**

    ```
    Third
    Second
    First
    ```

## 总结

`defer` 是 Go 语言中一个非常强大的工具，用于确保某些操作在函数返回之前被执行。它常用于资源清理、文件关闭、解锁等场景。通过理解 `defer` 的工作原理和使用场景，你可以编写出更加健壮和可维护的 Go 代码。

## 附加资源与练习

- **练习 1**：编写一个 Go 程序，使用 `defer` 来确保文件在读取后关闭。
- **练习 2**：修改上面的 `criticalSection` 函数，使其在发生 panic 时仍然能够正确释放锁。
- **练习 3**：尝试在一个函数中使用多个 `defer` 语句，并观察它们的执行顺序。

通过实践这些练习，你将更好地掌握 `defer` 的使用方法和应用场景。