---
title: Go 错误包装
description: 了解如何在Go中包装错误，以便更好地调试和处理错误。
---

# Go 错误包装

在Go编程中，错误处理是一个非常重要的部分。Go语言提供了一种简单而强大的错误处理机制，但有时候我们需要更多的上下文信息来调试和处理错误。这就是**错误包装**的用武之地。通过错误包装，我们可以在不丢失原始错误信息的情况下，添加更多的上下文信息。

## 什么是错误包装？

错误包装是指在捕获一个错误后，为其添加额外的上下文信息，然后将新的错误返回。这样做的目的是为了在调试时能够更容易地追踪错误的来源和原因。

在Go中，我们可以使用 `fmt.Errorf` 和 `%w` 动词来包装错误。`%w` 动词会将原始错误包装在新的错误中，并保留原始错误的信息。

## 基本用法

让我们从一个简单的例子开始：

```go
package main

import (
    "errors"
    "fmt"
)

func main() {
    err := doSomething()
    if err != nil {
        fmt.Println(err)
    }
}

func doSomething() error {
    err := doSomethingElse()
    if err != nil {
        return fmt.Errorf("doSomething failed: %w", err)
    }
    return nil
}

func doSomethingElse() error {
    return errors.New("something went wrong")
}
```

在这个例子中，`doSomething` 函数调用了 `doSomethingElse`，后者返回了一个错误。`doSomething` 使用 `fmt.Errorf` 和 `%w` 动词将这个错误包装在一个新的错误中，并添加了额外的上下文信息。

### 输出

```
doSomething failed: something went wrong
```

## 解包错误

有时候我们需要检查原始错误是什么。Go提供了 `errors.Unwrap` 函数来解包错误：

```go
package main

import (
    "errors"
    "fmt"
)

func main() {
    err := doSomething()
    if err != nil {
        fmt.Println(err)
        unwrappedErr := errors.Unwrap(err)
        fmt.Println("Unwrapped error:", unwrappedErr)
    }
}

func doSomething() error {
    err := doSomethingElse()
    if err != nil {
        return fmt.Errorf("doSomething failed: %w", err)
    }
    return nil
}

func doSomethingElse() error {
    return errors.New("something went wrong")
}
```

### 输出

```
doSomething failed: something went wrong
Unwrapped error: something went wrong
```

## 实际应用场景

在实际开发中，错误包装可以帮助我们更好地理解错误的来源。例如，在处理数据库操作时，我们可能会遇到多种错误，如连接错误、查询错误等。通过错误包装，我们可以为每个错误添加更多的上下文信息，从而更容易地调试和修复问题。

```go
package main

import (
    "database/sql"
    "errors"
    "fmt"
    _ "github.com/go-sql-driver/mysql"
)

func main() {
    db, err := sql.Open("mysql", "user:password@tcp(127.0.0.1:3306)/dbname")
    if err != nil {
        fmt.Println("Failed to connect to database:", err)
        return
    }
    defer db.Close()

    err = queryDatabase(db)
    if err != nil {
        fmt.Println(err)
    }
}

func queryDatabase(db *sql.DB) error {
    var name string
    err := db.QueryRow("SELECT name FROM users WHERE id = ?", 1).Scan(&name)
    if err != nil {
        if errors.Is(err, sql.ErrNoRows) {
            return fmt.Errorf("no user found: %w", err)
        }
        return fmt.Errorf("query failed: %w", err)
    }
    fmt.Println("User name:", name)
    return nil
}
```

在这个例子中，我们首先尝试连接数据库，然后查询用户信息。如果查询失败，我们会根据错误类型包装错误，并添加更多的上下文信息。

## 总结

错误包装是Go语言中一个非常有用的特性，它允许我们在不丢失原始错误信息的情况下，添加更多的上下文信息。通过使用 `fmt.Errorf` 和 `%w` 动词，我们可以轻松地包装错误，并通过 `errors.Unwrap` 函数解包错误。

在实际开发中，错误包装可以帮助我们更好地调试和处理错误，特别是在处理复杂的系统时。

## 附加资源

- [Go官方文档 - 错误处理](https://golang.org/doc/effective_go#errors)
- [Go by Example - Errors](https://gobyexample.com/errors)
- [Go Blog - Error handling and Go](https://blog.golang.org/error-handling-and-go)

## 练习

1. 修改上面的数据库查询示例，使其在连接失败时也包装错误。
2. 编写一个函数，该函数调用多个其他函数，并在每个函数中包装错误。最后，解包并打印所有错误。
