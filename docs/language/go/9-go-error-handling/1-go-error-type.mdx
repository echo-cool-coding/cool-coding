---
title: Go 错误类型
description: 了解Go语言中的错误类型及其处理方式，掌握如何定义、使用和自定义错误类型。
---

# Go 错误类型

在Go语言中，错误处理是一个非常重要的主题。与其他语言不同，Go没有异常机制，而是通过显式的错误返回值来处理错误。理解Go中的错误类型及其处理方式，是编写健壮、可维护代码的关键。

## 什么是错误类型？

在Go中，错误类型是一个接口类型，定义如下：

```go
type error interface {
    Error() string
}
```

任何实现了 `Error() string` 方法的类型都可以被视为错误类型。Go标准库中的 `errors` 包提供了创建简单错误的方法，例如 `errors.New()`。

## 标准错误类型

Go标准库中的 `errors` 包提供了最基本的错误类型。你可以使用 `errors.New()` 函数创建一个简单的错误：

```go
package main

import (
    "errors"
    "fmt"
)

func divide(a, b int) (int, error) {
    if b == 0 {
        return 0, errors.New("division by zero")
    }
    return a / b, nil
}

func main() {
    result, err := divide(10, 0)
    if err != nil {
        fmt.Println("Error:", err)
    } else {
        fmt.Println("Result:", result)
    }
}
```

**输出：**
```
Error: division by zero
```

在这个例子中，`divide` 函数在除数为零时返回一个错误。调用者通过检查 `err` 是否为 `nil` 来判断是否发生了错误。

## 自定义错误类型

虽然 `errors.New()` 可以创建简单的错误，但在某些情况下，你可能需要更复杂的错误类型。你可以通过定义一个结构体并实现 `error` 接口来创建自定义错误类型。

```go
package main

import (
    "fmt"
)

type DivisionError struct {
    dividend int
    divisor  int
}

func (e *DivisionError) Error() string {
    return fmt.Sprintf("cannot divide %d by %d", e.dividend, e.divisor)
}

func divide(a, b int) (int, error) {
    if b == 0 {
        return 0, &DivisionError{dividend: a, divisor: b}
    }
    return a / b, nil
}

func main() {
    result, err := divide(10, 0)
    if err != nil {
        fmt.Println("Error:", err)
    } else {
        fmt.Println("Result:", result)
    }
}
```

**输出：**
```
Error: cannot divide 10 by 0
```

在这个例子中，我们定义了一个 `DivisionError` 结构体，并实现了 `Error() string` 方法。这样，我们可以返回一个包含更多信息的错误。

## 错误包装与解包

在Go 1.13及以上版本中，引入了错误包装（error wrapping）的概念。你可以使用 `fmt.Errorf` 和 `%w` 动词来包装错误，以便在错误链中保留原始错误信息。

```go
package main

import (
    "errors"
    "fmt"
)

func divide(a, b int) (int, error) {
    if b == 0 {
        return 0, fmt.Errorf("division failed: %w", errors.New("division by zero"))
    }
    return a / b, nil
}

func main() {
    result, err := divide(10, 0)
    if err != nil {
        fmt.Println("Error:", err)
        // 解包错误
        if wrappedErr := errors.Unwrap(err); wrappedErr != nil {
            fmt.Println("Wrapped error:", wrappedErr)
        }
    } else {
        fmt.Println("Result:", result)
    }
}
```

**输出：**
```
Error: division failed: division by zero
Wrapped error: division by zero
```

在这个例子中，我们使用 `fmt.Errorf` 和 `%w` 动词将原始错误包装在新的错误中。通过 `errors.Unwrap()` 函数，我们可以解包并获取原始错误。

## 实际应用场景

在实际开发中，错误处理通常涉及多个层次的函数调用。通过自定义错误类型和错误包装，你可以更好地传递和处理错误信息。

例如，在一个Web服务中，你可能需要处理数据库查询错误、网络请求错误等。通过自定义错误类型，你可以为每种错误类型提供更多的上下文信息，从而更容易调试和处理问题。

```go
package main

import (
    "errors"
    "fmt"
)

type DatabaseError struct {
    Query string
    Err   error
}

func (e *DatabaseError) Error() string {
    return fmt.Sprintf("database error: query %s failed: %v", e.Query, e.Err)
}

func queryDatabase(query string) error {
    // 模拟数据库查询失败
    return &DatabaseError{Query: query, Err: errors.New("connection timeout")}
}

func main() {
    err := queryDatabase("SELECT * FROM users")
    if err != nil {
        fmt.Println("Error:", err)
        if dbErr, ok := err.(*DatabaseError); ok {
            fmt.Println("Query:", dbErr.Query)
            fmt.Println("Original error:", dbErr.Err)
        }
    }
}
```

**输出：**
```
Error: database error: query SELECT * FROM users failed: connection timeout
Query: SELECT * FROM users
Original error: connection timeout
```

在这个例子中，我们定义了一个 `DatabaseError` 类型，用于表示数据库查询错误。通过类型断言，我们可以获取更多的错误信息。

## 总结

Go语言中的错误处理是通过显式的错误返回值来实现的。你可以使用标准库中的 `errors` 包创建简单的错误，也可以通过自定义错误类型来提供更多的上下文信息。Go 1.13及以上版本引入了错误包装的概念，使得错误处理更加灵活和强大。

在实际开发中，合理使用错误类型和错误包装，可以帮助你编写更健壮、更易维护的代码。

## 附加资源与练习

- **练习1**：编写一个函数，接受两个整数作为参数，返回它们的商和余数。如果除数为零，返回一个自定义错误类型。
- **练习2**：修改上面的练习，使用错误包装来传递原始错误信息。
- **阅读**：Go官方文档中的 [错误处理](https://golang.org/doc/effective_go.html#errors) 部分，了解更多关于错误处理的最佳实践。

:::tip
在编写Go代码时，始终记得检查错误并妥善处理它们。忽略错误可能会导致程序在运行时出现不可预知的行为。
:::