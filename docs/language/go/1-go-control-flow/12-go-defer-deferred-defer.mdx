---
title: Go 延迟执行defer
description: 了解Go语言中的defer关键字，掌握其工作原理、使用场景以及实际应用。
---

# Go 延迟执行defer

在Go语言中，`defer`是一个非常有用的关键字，它允许我们将某个函数或方法的执行推迟到当前函数返回之前。无论函数是正常返回还是因为错误而提前返回，`defer`语句都会确保被延迟的函数调用被执行。这使得`defer`非常适合用于资源清理、解锁、关闭文件等操作。

## 什么是defer？

`defer`语句用于延迟函数的执行。它的语法非常简单：

```go
defer functionCall()
```

当程序执行到`defer`语句时，`functionCall()`不会立即执行，而是被推迟到当前函数返回之前执行。无论函数是通过`return`语句正常返回，还是因为发生了错误而提前返回，`defer`语句都会确保被延迟的函数调用被执行。

## 基本用法

让我们从一个简单的例子开始，看看`defer`是如何工作的：

```go
package main

import "fmt"

func main() {
    defer fmt.Println("World")
    fmt.Println("Hello")
}
```

**输出：**

```
Hello
World
```

在这个例子中，`fmt.Println("World")`被推迟到`main`函数返回之前执行。因此，`Hello`先被打印出来，然后是`World`。

## 多个defer语句的执行顺序

当一个函数中有多个`defer`语句时，它们会按照**后进先出（LIFO）**的顺序执行。也就是说，最后一个`defer`语句会最先执行，而第一个`defer`语句会最后执行。

```go
package main

import "fmt"

func main() {
    defer fmt.Println("First")
    defer fmt.Println("Second")
    defer fmt.Println("Third")
    fmt.Println("Hello")
}
```

**输出：**

```
Hello
Third
Second
First
```

在这个例子中，`Third`最先被打印出来，然后是`Second`，最后是`First`。

## defer的实际应用场景

### 1. 资源清理

`defer`最常见的用途之一是用于资源清理，例如关闭文件、释放锁等。以下是一个使用`defer`关闭文件的例子：

```go
package main

import (
    "fmt"
    "os"
)

func main() {
    file, err := os.Open("example.txt")
    if err != nil {
        fmt.Println("Error opening file:", err)
        return
    }
    defer file.Close()

    // 读取文件内容
    // ...
}
```

在这个例子中，`file.Close()`被推迟到`main`函数返回之前执行，确保文件在函数结束时被正确关闭，即使函数在中间发生了错误。

### 2. 解锁

`defer`也可以用于解锁互斥锁。以下是一个简单的例子：

```go
package main

import (
    "fmt"
    "sync"
)

var (
    counter int
    mutex   sync.Mutex
)

func increment() {
    mutex.Lock()
    defer mutex.Unlock()
    counter++
    fmt.Println("Counter:", counter)
}

func main() {
    var wg sync.WaitGroup
    for i := 0; i < 10; i++ {
        wg.Add(1)
        go func() {
            defer wg.Done()
            increment()
        }()
    }
    wg.Wait()
}
```

在这个例子中，`mutex.Unlock()`被推迟到`increment`函数返回之前执行，确保互斥锁在函数结束时被正确释放。

### 3. 记录函数执行时间

`defer`还可以用于记录函数的执行时间。以下是一个简单的例子：

```go
package main

import (
    "fmt"
    "time"
)

func measureTime() {
    defer func(start time.Time) {
        fmt.Println("Function execution time:", time.Since(start))
    }(time.Now())

    // 模拟一些耗时操作
    time.Sleep(2 * time.Second)
}

func main() {
    measureTime()
}
```

**输出：**

```
Function execution time: 2.000123456s
```

在这个例子中，`defer`语句用于记录`measureTime`函数的执行时间。

## defer的注意事项

### 1. defer与返回值

`defer`语句中的函数调用会在当前函数返回之前执行，因此它可能会影响函数的返回值。以下是一个例子：

```go
package main

import "fmt"

func main() {
    fmt.Println("Result:", double(2))
}

func double(x int) (result int) {
    defer func() {
        result *= 2
    }()
    return x
}
```

**输出：**

```
Result: 4
```

在这个例子中，`defer`语句修改了`result`的值，因此最终返回的结果是`4`而不是`2`。

### 2. defer与循环

在循环中使用`defer`时需要小心，因为`defer`语句会在循环结束后才执行。以下是一个例子：

```go
package main

import "fmt"

func main() {
    for i := 0; i < 3; i++ {
        defer fmt.Println(i)
    }
}
```

**输出：**

```
2
1
0
```

在这个例子中，`defer`语句会在循环结束后执行，因此打印的顺序是`2, 1, 0`。

## 总结

`defer`是Go语言中一个非常强大的工具，它可以帮助我们简化资源管理、确保代码的健壮性。通过推迟函数的执行，`defer`使得我们可以在函数返回之前执行一些必要的清理操作，而无需担心函数是否提前返回。

在实际开发中，`defer`常用于关闭文件、释放锁、记录日志等场景。掌握`defer`的使用方法，可以让你编写出更加简洁、健壮的Go代码。

## 附加资源与练习

- **练习1**：编写一个函数，使用`defer`语句在函数返回时打印一条消息。
- **练习2**：修改上面的`double`函数，使其返回`x`的平方而不是两倍。
- **练习3**：尝试在循环中使用`defer`，并观察其行为。

通过实践这些练习，你将更好地理解`defer`的工作原理及其在实际开发中的应用。