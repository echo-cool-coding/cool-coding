---
title: Go 装饰器模式
description: 了解如何在Go中使用装饰器模式来增强函数的行为，同时保持代码的简洁性和可扩展性。
---

## 介绍

装饰器模式（Decorator Pattern）是一种结构型设计模式，它允许你通过将对象放入包含行为的特殊封装对象中来为原对象增加新的行为。在Go语言中，虽然没有类和继承的概念，但我们可以通过函数和接口来实现类似的功能。

装饰器模式的核心思想是：**在不改变原有函数或对象的基础上，动态地扩展其功能**。这种模式非常适合在需要对函数进行增强（如日志记录、性能监控、权限校验等）时使用。

## 装饰器模式的基本概念

在Go中，装饰器模式通常通过以下方式实现：

1. **定义一个函数类型**：通常是一个接受特定参数并返回特定结果的函数。
2. **创建一个装饰器函数**：这个函数接受原始函数作为参数，并返回一个新的函数。新函数在调用原始函数之前或之后执行额外的逻辑。

### 代码示例

让我们从一个简单的例子开始。假设我们有一个函数 `Add`，它接受两个整数并返回它们的和。我们希望在不修改 `Add` 函数的情况下，添加一个日志功能，记录每次调用的输入和输出。

```go
package main

import (
    "fmt"
    "log"
)

// 原始函数
func Add(a, b int) int {
    return a + b
}

// 装饰器函数
func LogDecorator(fn func(int, int) int) func(int, int) int {
    return func(a, b int) int {
        log.Printf("Calling Add with arguments: %d, %d", a, b)
        result := fn(a, b)
        log.Printf("Add returned: %d", result)
        return result
    }
}

func main() {
    // 使用装饰器增强Add函数
    decoratedAdd := LogDecorator(Add)
    result := decoratedAdd(3, 5)
    fmt.Println("Result:", result)
}
```

**输出：**
```
2023/10/01 12:00:00 Calling Add with arguments: 3, 5
2023/10/01 12:00:00 Add returned: 8
Result: 8
```

在这个例子中，`LogDecorator` 函数接受一个函数 `fn` 作为参数，并返回一个新的函数。这个新函数在调用 `fn` 之前和之后分别记录了日志。

## 实际应用场景

装饰器模式在实际开发中有很多应用场景，以下是一些常见的例子：

1. **日志记录**：如上面的例子所示，装饰器可以用于记录函数的调用信息。
2. **性能监控**：可以在函数执行前后记录时间，计算函数的执行时间。
3. **权限校验**：在函数执行前检查用户权限，确保只有授权用户才能调用某些函数。
4. **缓存**：在函数执行前检查缓存，如果缓存中存在结果则直接返回，否则执行函数并将结果缓存。

### 性能监控示例

让我们看一个性能监控的示例。假设我们有一个函数 `SlowFunction`，它执行一些耗时的操作。我们希望在不修改 `SlowFunction` 的情况下，记录它的执行时间。

```go
package main

import (
    "fmt"
    "time"
)

// 原始函数
func SlowFunction() {
    time.Sleep(2 * time.Second)
    fmt.Println("SlowFunction executed")
}

// 装饰器函数
func TimeDecorator(fn func()) func() {
    return func() {
        start := time.Now()
        fn()
        elapsed := time.Since(start)
        fmt.Printf("Function took %s to execute\n", elapsed)
    }
}

func main() {
    // 使用装饰器增强SlowFunction
    decoratedSlowFunction := TimeDecorator(SlowFunction)
    decoratedSlowFunction()
}
```

**输出：**
```
SlowFunction executed
Function took 2.000123456s to execute
```

在这个例子中，`TimeDecorator` 函数记录了 `SlowFunction` 的执行时间，并在函数执行完成后输出。

## 总结

装饰器模式是一种强大的设计模式，它允许我们在不修改原始函数的情况下，动态地扩展其功能。通过使用装饰器，我们可以轻松地添加日志记录、性能监控、权限校验等功能，而不会影响原有代码的逻辑。

在Go中，装饰器模式通常通过高阶函数来实现。我们可以定义一个装饰器函数，它接受原始函数作为参数，并返回一个新的函数。这个新函数在调用原始函数之前或之后执行额外的逻辑。

## 附加资源与练习

- **练习1**：尝试为 `Add` 函数添加一个缓存装饰器，使得相同的输入参数只会计算一次。
- **练习2**：编写一个装饰器，用于在函数执行前检查用户权限，如果用户没有权限，则返回错误。

通过练习这些例子，你将更好地理解装饰器模式的应用场景和实现方式。继续探索Go的函数式编程特性，你会发现更多有趣的设计模式和编程技巧！