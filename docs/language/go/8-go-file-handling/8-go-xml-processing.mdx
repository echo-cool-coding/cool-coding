---
title: Go XML 处理
description: "学习如何在 Go 中处理 XML 数据，包括解析和生成 XML 文件。本文适合初学者，包含代码示例和实际应用场景。"
---

# Go XML 处理

XML（可扩展标记语言）是一种广泛使用的数据格式，常用于配置文件、数据交换和 Web 服务。Go 语言提供了强大的标准库支持，使得处理 XML 数据变得非常简单。本文将介绍如何在 Go 中解析和生成 XML 数据。

## 1. 什么是 XML？

XML 是一种用于存储和传输数据的标记语言。它类似于 HTML，但更加灵活，允许用户自定义标签。XML 文件通常以 `.xml` 为扩展名，并且具有良好的可读性。

```xml
<book>
    <title>Go Programming</title>
    <author>John Doe</author>
    <year>2023</year>
</book>
```

## 2. Go 中的 XML 解析

Go 的 `encoding/xml` 包提供了对 XML 数据的解析和生成支持。我们可以使用 `Unmarshal` 函数将 XML 数据解析为 Go 的结构体。

### 2.1 解析 XML 到结构体

假设我们有一个 XML 文件 `book.xml`，内容如下：

```xml
<book>
    <title>Go Programming</title>
    <author>John Doe</author>
    <year>2023</year>
</book>
```

我们可以定义一个结构体来表示这个 XML 数据：

```go
type Book struct {
    Title  string `xml:"title"`
    Author string `xml:"author"`
    Year   int    `xml:"year"`
}
```

然后，使用 `Unmarshal` 函数将 XML 数据解析到结构体中：

```go
package main

import (
    "encoding/xml"
    "fmt"
    "os"
)

type Book struct {
    Title  string `xml:"title"`
    Author string `xml:"author"`
    Year   int    `xml:"year"`
}

func main() {
    data := []byte(`
        <book>
            <title>Go Programming</title>
            <author>John Doe</author>
            <year>2023</year>
        </book>
    `)

    var book Book
    err := xml.Unmarshal(data, &book)
    if err != nil {
        fmt.Println("Error:", err)
        return
    }

    fmt.Printf("Title: %s, Author: %s, Year: %d\n", book.Title, book.Author, book.Year)
}
```

**输出：**

```
Title: Go Programming, Author: John Doe, Year: 2023
```

### 2.2 解析嵌套 XML

XML 数据可能包含嵌套结构。例如：

```xml
<library>
    <book>
        <title>Go Programming</title>
        <author>John Doe</author>
        <year>2023</year>
    </book>
    <book>
        <title>Advanced Go</title>
        <author>Jane Smith</author>
        <year>2024</year>
    </book>
</library>
```

我们可以定义一个 `Library` 结构体来解析这个嵌套的 XML：

```go
type Library struct {
    Books []Book `xml:"book"`
}

type Book struct {
    Title  string `xml:"title"`
    Author string `xml:"author"`
    Year   int    `xml:"year"`
}
```

然后，使用 `Unmarshal` 函数解析：

```go
package main

import (
    "encoding/xml"
    "fmt"
)

type Library struct {
    Books []Book `xml:"book"`
}

type Book struct {
    Title  string `xml:"title"`
    Author string `xml:"author"`
    Year   int    `xml:"year"`
}

func main() {
    data := []byte(`
        <library>
            <book>
                <title>Go Programming</title>
                <author>John Doe</author>
                <year>2023</year>
            </book>
            <book>
                <title>Advanced Go</title>
                <author>Jane Smith</author>
                <year>2024</year>
            </book>
        </library>
    `)

    var library Library
    err := xml.Unmarshal(data, &library)
    if err != nil {
        fmt.Println("Error:", err)
        return
    }

    for _, book := range library.Books {
        fmt.Printf("Title: %s, Author: %s, Year: %d\n", book.Title, book.Author, book.Year)
    }
}
```

**输出：**

```
Title: Go Programming, Author: John Doe, Year: 2023
Title: Advanced Go, Author: Jane Smith, Year: 2024
```

## 3. Go 中的 XML 生成

除了解析 XML，Go 还可以使用 `Marshal` 函数将结构体转换为 XML 数据。

### 3.1 生成 XML 数据

我们可以使用 `Marshal` 函数将 `Book` 结构体转换为 XML：

```go
package main

import (
    "encoding/xml"
    "fmt"
)

type Book struct {
    Title  string `xml:"title"`
    Author string `xml:"author"`
    Year   int    `xml:"year"`
}

func main() {
    book := Book{
        Title:  "Go Programming",
        Author: "John Doe",
        Year:   2023,
    }

    data, err := xml.MarshalIndent(book, "", "    ")
    if err != nil {
        fmt.Println("Error:", err)
        return
    }

    fmt.Println(string(data))
}
```

**输出：**

```xml
<Book>
    <title>Go Programming</title>
    <author>John Doe</author>
    <year>2023</year>
</Book>
```

### 3.2 生成嵌套 XML

我们也可以生成嵌套的 XML 数据。例如，生成一个包含多本书的图书馆 XML：

```go
package main

import (
    "encoding/xml"
    "fmt"
)

type Library struct {
    Books []Book `xml:"book"`
}

type Book struct {
    Title  string `xml:"title"`
    Author string `xml:"author"`
    Year   int    `xml:"year"`
}

func main() {
    library := Library{
        Books: []Book{
            {Title: "Go Programming", Author: "John Doe", Year: 2023},
            {Title: "Advanced Go", Author: "Jane Smith", Year: 2024},
        },
    }

    data, err := xml.MarshalIndent(library, "", "    ")
    if err != nil {
        fmt.Println("Error:", err)
        return
    }

    fmt.Println(string(data))
}
```

**输出：**

```xml
<Library>
    <book>
        <title>Go Programming</title>
        <author>John Doe</author>
        <year>2023</year>
    </book>
    <book>
        <title>Advanced Go</title>
        <author>Jane Smith</author>
        <year>2024</year>
    </book>
</Library>
```

## 4. 实际应用场景

XML 在许多实际场景中都有应用，例如：

- **配置文件**：许多应用程序使用 XML 文件来存储配置信息。
- **数据交换**：XML 常用于不同系统之间的数据交换格式。
- **Web 服务**：SOAP 是一种基于 XML 的 Web 服务协议。

### 4.1 读取配置文件

假设我们有一个配置文件 `config.xml`：

```xml
<config>
    <server>
        <host>localhost</host>
        <port>8080</port>
    </server>
    <database>
        <name>mydb</name>
        <user>admin</user>
        <password>secret</password>
    </database>
</config>
```

我们可以定义一个结构体来解析这个配置文件：

```go
type Config struct {
    Server   Server   `xml:"server"`
    Database Database `xml:"database"`
}

type Server struct {
    Host string `xml:"host"`
    Port int    `xml:"port"`
}

type Database struct {
    Name     string `xml:"name"`
    User     string `xml:"user"`
    Password string `xml:"password"`
}
```

然后，读取并解析配置文件：

```go
package main

import (
    "encoding/xml"
    "fmt"
    "os"
)

type Config struct {
    Server   Server   `xml:"server"`
    Database Database `xml:"database"`
}

type Server struct {
    Host string `xml:"host"`
    Port int    `xml:"port"`
}

type Database struct {
    Name     string `xml:"name"`
    User     string `xml:"user"`
    Password string `xml:"password"`
}

func main() {
    data, err := os.ReadFile("config.xml")
    if err != nil {
        fmt.Println("Error reading file:", err)
        return
    }

    var config Config
    err = xml.Unmarshal(data, &config)
    if err != nil {
        fmt.Println("Error parsing XML:", err)
        return
    }

    fmt.Printf("Server: %s:%d\n", config.Server.Host, config.Server.Port)
    fmt.Printf("Database: %s, User: %s, Password: %s\n", config.Database.Name, config.Database.User, config.Database.Password)
}
```

**输出：**

```
Server: localhost:8080
Database: mydb, User: admin, Password: secret
```

## 5. 总结

本文介绍了如何在 Go 中处理 XML 数据，包括解析和生成 XML 文件。我们通过代码示例展示了如何将 XML 数据解析为 Go 结构体，以及如何将结构体转换为 XML 数据。此外，我们还探讨了 XML 在实际应用中的一些常见场景。

:::tip
如果你对 XML 处理有更深入的需求，可以查阅 Go 的官方文档，了解更多高级用法，如处理 XML 命名空间、属性等。
:::

## 6. 附加资源与练习

- **官方文档**：[encoding/xml](https://pkg.go.dev/encoding/xml)
- **练习**：尝试解析一个包含嵌套结构的复杂 XML 文件，并生成一个新的 XML 文件。
- **扩展阅读**：了解 JSON 与 XML 的区别，以及在不同场景下的选择。

通过本文的学习，你应该已经掌握了 Go 中处理 XML 的基本技能。继续练习和探索，你将能够更加熟练地处理各种数据格式。