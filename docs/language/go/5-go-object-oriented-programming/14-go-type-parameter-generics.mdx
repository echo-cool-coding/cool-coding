---
title: Go 类型参数（泛型）
description: 了解 Go 语言中的类型参数（泛型），掌握如何使用泛型编写更通用、灵活的代码。
---

# Go 类型参数（泛型）

## 介绍

Go 语言在 1.18 版本中引入了类型参数（泛型）的支持，这是 Go 语言发展历程中的一个重要里程碑。泛型允许我们编写更通用、灵活的代码，而不必为每种类型重复编写相似的逻辑。通过泛型，我们可以定义适用于多种类型的函数、结构体和方法。

在本节中，我们将逐步介绍 Go 中的类型参数（泛型），并通过代码示例和实际案例帮助你理解其用法。

## 什么是类型参数（泛型）？

类型参数（泛型）是一种编程技术，允许我们编写可以处理多种类型的代码，而不必为每种类型编写单独的实现。在 Go 中，类型参数通过 `type` 关键字和方括号 `[]` 来定义。

例如，我们可以定义一个泛型函数，它可以接受任何类型的参数并返回相同类型的值：

```go
func Identity[T any](value T) T {
    return value
}
```

在这个例子中，`T` 是一个类型参数，`any` 表示 `T` 可以是任何类型。我们可以用这个函数来处理 `int`、`string` 或其他任何类型的数据。

## 泛型的基本语法

### 定义泛型函数

泛型函数的定义与普通函数类似，但在函数名后添加了类型参数列表。类型参数列表用方括号 `[]` 包裹，参数之间用逗号分隔。

```go
func PrintSlice[T any](slice []T) {
    for _, v := range slice {
        fmt.Println(v)
    }
}
```

在这个例子中，`PrintSlice` 函数可以打印任何类型的切片。

### 定义泛型结构体

我们也可以定义泛型结构体。泛型结构体的定义方式与泛型函数类似，类型参数列表放在结构体名后。

```go
type Box[T any] struct {
    Content T
}
```

在这个例子中，`Box` 结构体可以存储任何类型的值。

### 调用泛型函数

调用泛型函数时，通常不需要显式指定类型参数，Go 编译器会根据传入的参数自动推断类型。

```go
PrintSlice([]int{1, 2, 3})  // 打印整数切片
PrintSlice([]string{"a", "b", "c"})  // 打印字符串切片
```

## 实际案例

### 泛型栈

让我们通过一个实际的例子来展示泛型的强大之处。我们将实现一个泛型栈（Stack），它可以存储任何类型的元素。

```go
type Stack[T any] struct {
    elements []T
}

func (s *Stack[T]) Push(element T) {
    s.elements = append(s.elements, element)
}

func (s *Stack[T]) Pop() (T, bool) {
    if len(s.elements) == 0 {
        var zero T
        return zero, false
    }
    element := s.elements[len(s.elements)-1]
    s.elements = s.elements[:len(s.elements)-1]
    return element, true
}
```

我们可以使用这个泛型栈来存储 `int`、`string` 或其他任何类型的数据：

```go
intStack := Stack[int]{}
intStack.Push(1)
intStack.Push(2)
fmt.Println(intStack.Pop())  // 输出: 2, true

stringStack := Stack[string]{}
stringStack.Push("hello")
stringStack.Push("world")
fmt.Println(stringStack.Pop())  // 输出: world, true
```

### 泛型映射函数

另一个常见的用例是编写一个泛型映射函数，它可以对切片的每个元素应用一个函数，并返回一个新的切片。

```go
func Map[T any, U any](slice []T, f func(T) U) []U {
    result := make([]U, len(slice))
    for i, v := range slice {
        result[i] = f(v)
    }
    return result
}
```

我们可以使用这个函数将一个整数切片转换为字符串切片：

```go
numbers := []int{1, 2, 3}
strings := Map(numbers, func(n int) string {
    return fmt.Sprintf("%d", n)
})
fmt.Println(strings)  // 输出: [1 2 3]
```

## 总结

Go 的类型参数（泛型）为我们提供了一种强大的工具，可以编写更通用、灵活的代码。通过泛型，我们可以避免为每种类型重复编写相似的逻辑，从而提高代码的复用性和可维护性。

在本节中，我们介绍了泛型的基本语法，并通过实际案例展示了泛型的应用场景。希望这些内容能帮助你更好地理解和使用 Go 中的泛型。

## 附加资源

- [Go 官方文档：泛型](https://go.dev/doc/tutorial/generics)
- [Go 泛型设计提案](https://go.googlesource.com/proposal/+/refs/heads/master/design/43651-type-parameters.md)

## 练习

1. 编写一个泛型函数 `Filter`，它接受一个切片和一个谓词函数，并返回一个新的切片，其中包含满足谓词条件的元素。
2. 实现一个泛型队列（Queue），并编写相应的 `Enqueue` 和 `Dequeue` 方法。
3. 尝试使用泛型实现一个二叉树（Binary Tree）结构，并编写插入和查找方法。

通过完成这些练习，你将更深入地理解 Go 中的泛型编程。