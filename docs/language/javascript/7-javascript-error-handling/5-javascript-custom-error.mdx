---
title: JavaScript 自定义错误
description: 学习如何在JavaScript中创建和使用自定义错误类型，掌握错误处理的高级技巧。
---

# JavaScript 自定义错误

在编程过程中，错误处理是一项重要技能。JavaScript提供了一些内置错误类型（如`Error`、`TypeError`、`RangeError`等），但有时候这些标准错误类型不足以满足我们的需求。这就是**自定义错误**发挥作用的时候了。

## 什么是自定义错误？

自定义错误是指开发者根据特定应用场景，通过扩展JavaScript内置`Error`类（或其子类）创建的新错误类型。它们允许我们：

- 创建特定于应用程序的错误类型
- 提供更具描述性的错误信息
- 实现更精细的错误处理逻辑
- 增强代码的可读性和可维护性

## 创建自定义错误

在JavaScript中创建自定义错误的基本方法是扩展内置的`Error`类：

```javascript
class CustomError extends Error {
  constructor(message) {
    super(message);
    this.name = "CustomError";
  }
}
```

让我们分析这段代码：

1. 我们创建一个继承自`Error`的新类
2. 在构造函数中，我们调用父类构造函数并传入错误消息
3. 我们设置`name`属性来标识这种特定类型的错误

## 使用自定义错误

一旦定义了自定义错误，就可以像使用内置错误一样使用它：

```javascript
try {
  throw new CustomError("这是一个自定义错误");
} catch (error) {
  console.log(error.name); // 输出: "CustomError"
  console.log(error.message); // 输出: "这是一个自定义错误"
}
```

## 添加额外属性

自定义错误的一个主要优势是可以添加额外的属性来提供更多上下文：

```javascript
class ValidationError extends Error {
  constructor(message, field) {
    super(message);
    this.name = "ValidationError";
    this.field = field; // 添加额外的属性
  }
}

// 使用示例
try {
  throw new ValidationError("用户名长度必须至少为3个字符", "username");
} catch (error) {
  if (error instanceof ValidationError) {
    console.log(`错误字段: ${error.field}`); // 输出: "错误字段: username"
    console.log(`错误消息: ${error.message}`); // 输出: "错误消息: 用户名长度必须至少为3个字符"
  }
}
```

## 创建错误层次结构

对于复杂应用，可以创建错误层次结构，使错误处理更具组织性：

```javascript
// 基础应用错误
class AppError extends Error {
  constructor(message) {
    super(message);
    this.name = this.constructor.name;
  }
}

// 网络相关错误
class NetworkError extends AppError {
  constructor(message, statusCode) {
    super(message);
    this.statusCode = statusCode;
  }
}

// 数据相关错误
class DataError extends AppError {
  constructor(message, field) {
    super(message);
    this.field = field;
  }
}

// 使用示例
try {
  const response = { status: 404 };
  if (response.status === 404) {
    throw new NetworkError("资源未找到", 404);
  }
} catch (error) {
  if (error instanceof NetworkError) {
    console.log(`网络错误(${error.statusCode}): ${error.message}`);
    // 输出: "网络错误(404): 资源未找到"
  } else if (error instanceof AppError) {
    console.log(`应用错误: ${error.message}`);
  } else {
    console.log(`未知错误: ${error.message}`);
  }
}
```

## 实际应用场景

让我们看看自定义错误在实际项目中的应用场景：

### 场景1: 表单验证

```javascript
class FormValidationError extends Error {
  constructor(message, fieldName, value) {
    super(message);
    this.name = "FormValidationError";
    this.fieldName = fieldName;
    this.value = value;
  }
}

function validateUsername(username) {
  if (!username) {
    throw new FormValidationError("用户名不能为空", "username", username);
  }
  
  if (username.length < 3) {
    throw new FormValidationError(
      "用户名长度必须至少为3个字符", 
      "username", 
      username
    );
  }
  
  return true;
}

// 使用示例
try {
  const username = "ab";
  validateUsername(username);
} catch (error) {
  if (error instanceof FormValidationError) {
    console.log(`字段 ${error.fieldName} 验证失败: ${error.message}`);
    console.log(`提供的值: ${error.value}`);
    // 输出:
    // 字段 username 验证失败: 用户名长度必须至少为3个字符
    // 提供的值: ab
  }
}
```

### 场景2: API请求处理

```javascript
class APIError extends Error {
  constructor(message, statusCode, endpoint) {
    super(message);
    this.name = "APIError";
    this.statusCode = statusCode;
    this.endpoint = endpoint;
    this.timestamp = new Date();
  }
  
  get isServerError() {
    return this.statusCode >= 500;
  }
  
  get isClientError() {
    return this.statusCode >= 400 && this.statusCode < 500;
  }
}

async function fetchUserData(userId) {
  try {
    const response = await fetch(`/api/users/${userId}`);
    
    if (!response.ok) {
      throw new APIError(
        `获取用户数据失败: ${response.statusText}`,
        response.status,
        `/api/users/${userId}`
      );
    }
    
    return await response.json();
  } catch (error) {
    if (error instanceof APIError) {
      console.error(`API错误: ${error.message}`);
      console.error(`状态码: ${error.statusCode}`);
      console.error(`接口: ${error.endpoint}`);
      console.error(`时间: ${error.timestamp}`);
      
      if (error.isServerError) {
        console.error("服务器错误，请稍后重试");
      } else if (error.isClientError) {
        console.error("请求参数有误，请检查输入");
      }
    } else {
      console.error("发生未知错误:", error);
    }
    
    throw error; // 重新抛出错误，让调用方也能处理
  }
}
```

:::tip 最佳实践
当创建自定义错误时，始终保持错误的名称与类名一致，这样在调试时更容易识别错误类型。
:::

## 错误堆栈问题

在某些JavaScript环境中，扩展Error类可能会导致堆栈跟踪信息丢失。为了解决这个问题，我们可以使用`Error.captureStackTrace`方法：

```javascript
class CustomError extends Error {
  constructor(message) {
    super(message);
    this.name = "CustomError";
    
    // 捕获堆栈跟踪
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, CustomError);
    }
  }
}
```

这确保了错误堆栈不会包含错误类构造函数本身的调用，使错误追踪更加清晰。

## ES5中的自定义错误

虽然现代JavaScript推荐使用类语法来创建自定义错误，但为了兼容性，有时我们可能需要使用ES5的函数构造方式：

```javascript
function LegacyError(message) {
  // 确保以构造函数形式调用
  if (!(this instanceof LegacyError)) {
    return new LegacyError(message);
  }
  
  // 设置错误消息
  this.message = message || "发生错误";
  
  // 捕获堆栈
  Error.captureStackTrace(this, LegacyError);
  
  // 设置错误名称
  this.name = "LegacyError";
}

// 设置原型链
LegacyError.prototype = Object.create(Error.prototype);
LegacyError.prototype.constructor = LegacyError;

// 使用示例
try {
  throw new LegacyError("这是一个旧式的自定义错误");
} catch (error) {
  console.log(error.name); // 输出: "LegacyError"
  console.log(error.message); // 输出: "这是一个旧式的自定义错误"
}
```

## 总结

自定义错误是JavaScript错误处理的强大工具，它们使我们能够：

- 创建更有意义的错误类型
- 添加更多上下文信息
- 实现更精细的错误处理逻辑
- 创建应用程序特定的错误层次结构

通过有效地使用自定义错误，你可以编写更健壮的代码，提供更好的调试体验，并增强应用程序的可维护性。

## 练习题

1. 创建一个`DatabaseError`类，扩展自`Error`，包含额外的`code`、`table`和`operation`属性。
2. 为电子商务应用创建错误层次结构，包含`PaymentError`、`InventoryError`和`ShippingError`。
3. 修改上面的`APIError`示例，添加一个方法用于记录错误到服务器。

## 进一步学习资源

- [MDN Web 文档: Error](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Error)
- [JavaScript 错误处理实践指南](https://github.com/goldbergyoni/nodebestpractices#2-error-handling-practices)

:::caution
记住，虽然自定义错误很有用，但不要过度使用它们。只在真正需要区分不同类型的错误或添加额外上下文信息时才创建新的错误类型。
:::