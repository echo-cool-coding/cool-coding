---
title: JavaScript 对象不变性
description: 学习如何确保JavaScript对象的不变性，掌握Object.freeze、Object.seal和其他创建不可变数据的技术。
---

# JavaScript 对象不变性

在JavaScript中，对象默认是可变的(mutable)，这意味着我们可以在创建后修改它们的属性。然而，在某些情况下，我们可能希望防止对象被修改，这就是对象不变性(immutability)的概念。

## 为什么需要对象不变性？

对象不变性有几个重要优势：

1. **可预测性** - 不可变对象更容易推理，因为它们的状态不会改变
2. **安全性** - 防止意外或恶意修改对象
3. **简化调试** - 当对象不可变时，查找问题的来源会更容易
4. **支持函数式编程** - 不变性是函数式编程的核心原则之一

## JavaScript 中实现不变性的方法

### 1. Object.freeze()

`Object.freeze()` 是实现对象不变性最直接的方法，它可以防止添加新属性、移除现有属性以及修改现有属性的值或可配置性、可写性。

```js
const user = {
  name: "张三",
  age: 30,
  address: {
    city: "北京",
    district: "海淀区"
  }
};

// 冻结对象
Object.freeze(user);

// 尝试修改属性
user.name = "李四"; // 在严格模式下会抛出错误，非严格模式下静默失败
console.log(user.name); // 输出: "张三" (未被修改)

// 尝试添加新属性
user.email = "zhangsan@example.com";
console.log(user.email); // 输出: undefined (未被添加)

// 尝试删除属性
delete user.age;
console.log(user.age); // 输出: 30 (未被删除)
```

:::caution 注意
`Object.freeze()` 是浅冻结，只冻结对象的直接属性，不会冻结嵌套对象。
:::

例如，尽管我们冻结了上面的 `user` 对象，我们仍然可以修改 `user.address` 的属性：

```js
user.address.city = "上海";
console.log(user.address.city); // 输出: "上海" (被修改了)
```

要实现深度冻结，我们需要递归地冻结对象的所有嵌套属性：

```js
function deepFreeze(object) {
  // 获取对象的属性名
  const propNames = Object.getOwnPropertyNames(object);
  
  // 在冻结当前对象之前，确保其属性已被冻结
  for (const name of propNames) {
    const value = object[name];
    
    // 如果属性是对象，则递归冻结它
    if (value && typeof value === "object") {
      deepFreeze(value);
    }
  }
  
  // 冻结当前对象
  return Object.freeze(object);
}

// 使用深度冻结
const user = deepFreeze({
  name: "张三",
  age: 30,
  address: {
    city: "北京",
    district: "海淀区"
  }
});

// 尝试修改嵌套属性
user.address.city = "上海";
console.log(user.address.city); // 输出: "北京" (未被修改)
```

### 2. Object.seal()

如果你只想防止添加和删除属性，但允许修改现有属性的值，可以使用 `Object.seal()`：

```js
const user = {
  name: "张三",
  age: 30
};

Object.seal(user);

// 允许修改现有属性
user.name = "李四";
console.log(user.name); // 输出: "李四" (被修改)

// 不允许添加新属性
user.email = "lisi@example.com";
console.log(user.email); // 输出: undefined (未被添加)

// 不允许删除属性
delete user.age;
console.log(user.age); // 输出: 30 (未被删除)
```

### 3. Object.preventExtensions()

`Object.preventExtensions()` 仅防止向对象添加新属性，但仍允许修改或删除现有属性：

```js
const user = {
  name: "张三",
  age: 30
};

Object.preventExtensions(user);

// 允许修改现有属性
user.name = "李四";
console.log(user.name); // 输出: "李四"

// 允许删除现有属性
delete user.age;
console.log(user.age); // 输出: undefined (被删除)

// 不允许添加新属性
user.email = "lisi@example.com";
console.log(user.email); // 输出: undefined (未被添加)
```

### 4. 检测对象的不变性

JavaScript提供了几个方法来检测对象的不变性状态：

```js
const user = {
  name: "张三"
};

// 冻结对象
Object.freeze(user);

console.log(Object.isFrozen(user)); // 输出: true
console.log(Object.isSealed(user)); // 输出: true (冻结的对象也是密封的)
console.log(Object.isExtensible(user)); // 输出: false (冻结的对象不可扩展)
```

## 使用常量声明

在JavaScript中，使用 `const` 关键字声明变量并不能使对象不可变，它只是防止变量被重新赋值：

```js
const user = {
  name: "张三"
};

user.name = "李四"; // 这是允许的
console.log(user.name); // 输出: "李四"

user = {}; // 错误: Assignment to constant variable
```

## 实际应用场景

### 1. 配置对象

当你创建一个应用程序配置对象，你可能希望它是不可变的，以防止在运行时意外修改：

```js
const CONFIG = Object.freeze({
  API_URL: "https://api.example.com",
  MAX_RETRIES: 3,
  TIMEOUT: 5000,
  DEBUG: {
    ENABLED: true,
    LEVEL: "info"
  }
});

// 深度冻结配置
deepFreeze(CONFIG);

// 现在CONFIG的所有属性和嵌套属性都不能被修改
```

### 2. Redux状态管理

Redux等状态管理库依赖于不可变状态更新模式。这确保了状态变化的可预测性和可追踪性：

```js
// 不正确的方式（直接修改状态）
function badReducer(state, action) {
  if (action.type === 'ADD_TODO') {
    state.todos.push(action.payload); // 直接修改状态!
    return state;
  }
  return state;
}

// 正确的方式（创建新的状态对象）
function goodReducer(state, action) {
  if (action.type === 'ADD_TODO') {
    return {
      ...state,
      todos: [...state.todos, action.payload]
    };
  }
  return state;
}
```

### 3. 多线程环境中的数据共享

在Web Workers或Node.js中的多线程环境，不可变对象可以安全地在线程间共享，而无需担心竞态条件：

```js
// 主线程
const sharedData = Object.freeze({
  settings: { /* 一些设置 */ },
  constants: { /* 一些常量 */ }
});

// 发送给worker线程
worker.postMessage(sharedData);
```

## 性能考虑

虽然不变性有许多好处，但也会带来性能开销，特别是在处理大型对象时。每次"修改"不可变对象实际上都会创建一个新对象。对于性能关键的应用程序，可以考虑以下方案：

1. 仅在必要时使用不可变模式
2. 考虑使用专门的不可变数据库（如Immutable.js或Immer）
3. 对大型集合，可以考虑使用持久数据结构，它们优化了不可变操作

## 总结

JavaScript对象不变性是一个强大的概念，可以帮助我们编写更安全、更可预测的代码。主要的实现方法包括：

- `Object.freeze()`: 完全冻结对象，防止所有修改
- `Object.seal()`: 防止添加和删除属性，但允许修改现有属性
- `Object.preventExtensions()`: 只防止添加新属性

记住，这些方法只提供浅层不变性，对于深层嵌套对象，需要实现递归冻结或使用专门的不可变数据库。

## 练习

1. 创建一个深度冻结函数，该函数可以递归地冻结对象及其所有嵌套属性。
2. 尝试在实际项目中识别可以从不变性中受益的对象（如配置、常量等）。
3. 比较使用原生JavaScript方法（如`Object.freeze()`）和特定库（如Immutable.js）实现不变性的优缺点。

## 附加资源

- MDN Web文档: [`Object.freeze()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze)
- MDN Web文档: [`Object.seal()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/seal)
- MDN Web文档: [`Object.preventExtensions()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/preventExtensions)
- [Immutable.js](https://immutable-js.com/) - Facebook的不可变数据集合库
- [Immer](https://immerjs.github.io/immer/) - 一个允许以更简单方式处理不可变状态的库

:::tip
对象不变性是函数式编程的重要概念，掌握它将帮助你编写更健壮、更可维护的代码，并可能避免许多难以追踪的bug。
:::