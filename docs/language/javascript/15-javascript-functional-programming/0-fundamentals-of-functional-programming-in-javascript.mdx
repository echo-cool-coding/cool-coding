---
title: JavaScript 函数式编程基础
description: 学习JavaScript函数式编程的核心概念、实践和优势，从纯函数、不可变性到高阶函数，帮助初学者建立坚实的函数式编程思维基础。
---

# JavaScript 函数式编程基础

## 什么是函数式编程？

函数式编程（Functional Programming，简称 FP）是一种编程范式，它将计算视为数学函数的求值，并避免状态变化和可变数据。在JavaScript中，函数式编程提供了一种强大的工具，帮助我们编写更加简洁、可测试和可维护的代码。

:::note 函数式编程的核心思想
函数式编程把计算机程序视为数学上的函数计算，避免使用程序状态以及易变对象。
:::

函数式编程的主要特点：

1. **纯函数** - 相同的输入总是产生相同的输出，没有副作用
2. **不可变性** - 数据不可修改，创建新数据而不是修改现有数据
3. **函数是一等公民** - 函数可以赋值给变量，可以作为参数传递，可以作为返回值
4. **高阶函数** - 接受函数作为参数或返回函数的函数
5. **声明式编程** - 关注"做什么"而不是"怎么做"

## 纯函数

纯函数是函数式编程的基石。一个纯函数有两个主要特点：

1. 给定相同的输入，总是返回相同的输出
2. 没有副作用（不修改外部状态）

### 纯函数示例

```javascript
// 纯函数
function add(a, b) {
  return a + b;
}

console.log(add(2, 3)); // 输出: 5
console.log(add(2, 3)); // 输出: 5 (始终相同)
```

### 非纯函数示例

```javascript
// 非纯函数 - 依赖外部变量
let counter = 0;

function increment() {
  counter++; // 修改外部状态（副作用）
  return counter;
}

console.log(increment()); // 输出: 1
console.log(increment()); // 输出: 2 (结果不同)
```

## 不可变性

不可变性（Immutability）是函数式编程的另一个核心概念。它意味着一旦创建了一个对象，就不能再更改它。

### 可变数据的问题

```javascript
// 可变数据示例
const user = { name: "Alice", age: 25 };
function birthdayCelebration(user) {
  user.age++; // 直接修改原对象
  return user;
}

console.log(user); // { name: "Alice", age: 25 }
birthdayCelebration(user);
console.log(user); // { name: "Alice", age: 26 } - 原对象已更改
```

### 不可变数据的正确方法

```javascript
// 使用不可变方法
const user = { name: "Alice", age: 25 };
function birthdayCelebration(user) {
  return { ...user, age: user.age + 1 }; // 创建新对象
}

console.log(user); // { name: "Alice", age: 25 }
const updatedUser = birthdayCelebration(user);
console.log(user); // { name: "Alice", age: 25 } - 原对象未变
console.log(updatedUser); // { name: "Alice", age: 26 } - 新对象
```

## 高阶函数

高阶函数是函数式编程中的一个重要概念。它们接受一个或多个函数作为参数，并/或返回一个新函数。JavaScript内置了许多高阶函数。

### Array.prototype.map

`map`方法创建一个新数组，其结果是对原数组中的每个元素调用提供的函数。

```javascript
const numbers = [1, 2, 3, 4, 5];
const doubled = numbers.map(num => num * 2);

console.log(doubled); // 输出: [2, 4, 6, 8, 10]
```

### Array.prototype.filter

`filter`方法创建一个新数组，其中包含通过提供的函数测试的所有元素。

```javascript
const numbers = [1, 2, 3, 4, 5];
const evenNumbers = numbers.filter(num => num % 2 === 0);

console.log(evenNumbers); // 输出: [2, 4]
```

### Array.prototype.reduce

`reduce`方法将数组中的所有元素减少到一个值。

```javascript
const numbers = [1, 2, 3, 4, 5];
const sum = numbers.reduce((acc, curr) => acc + curr, 0);

console.log(sum); // 输出: 15
```

## 柯里化（Currying）

柯里化是将一个接受多个参数的函数转换为一系列接受单个参数的函数的过程。

```javascript
// 未柯里化的函数
function add(x, y) {
  return x + y;
}

// 柯里化版本
function curriedAdd(x) {
  return function(y) {
    return x + y;
  };
}

// 使用柯里化函数
const add5 = curriedAdd(5);
console.log(add5(3)); // 输出: 8

// 也可以直接调用
console.log(curriedAdd(5)(3)); // 输出: 8
```

## 组合（Composition）

函数组合是将多个函数组合成一个函数的过程，其中一个函数的输出作为下一个函数的输入。

```javascript
// 简单的组合函数
const compose = (f, g) => x => f(g(x));

const addOne = x => x + 1;
const double = x => x * 2;

// 组合这些函数
const addOneThenDouble = compose(double, addOne);

console.log(addOneThenDouble(3)); // 输出: 8
// 等同于 double(addOne(3))
// 等同于 double(4)
// 等同于 8
```

更通用的组合函数可以接受任意数量的函数：

```javascript
// 通用组合函数
const compose = (...fns) => x => fns.reduceRight((acc, fn) => fn(acc), x);

// 多个函数组合
const addOne = x => x + 1;
const double = x => x * 2;
const square = x => x * x;

const operation = compose(square, double, addOne);

console.log(operation(3)); // 输出: 64
// 等同于 square(double(addOne(3)))
// 等同于 square(double(4))
// 等同于 square(8)
// 等同于 64
```

## 实际应用案例

让我们通过一个实际案例来展示函数式编程如何简化复杂任务。

### 案例：电子商务产品过滤和排序

假设我们有一个产品列表，需要筛选特定类别的产品，然后按价格排序，最后格式化显示。

```javascript
// 产品数据
const products = [
  { id: 1, name: "Laptop", category: "Electronics", price: 999 },
  { id: 2, name: "Headphones", category: "Electronics", price: 99 },
  { id: 3, name: "Keyboard", category: "Electronics", price: 129 },
  { id: 4, name: "Running Shoes", category: "Sports", price: 89 },
  { id: 5, name: "Yoga Mat", category: "Sports", price: 29 }
];

// 筛选特定类别商品
const filterByCategory = category => products => 
  products.filter(product => product.category === category);

// 按价格排序
const sortByPrice = products => 
  [...products].sort((a, b) => a.price - b.price);

// 格式化产品显示
const formatProducts = products => 
  products.map(({ name, price }) => `${name} - $${price}`);

// 组合所有操作
const processProducts = compose(
  formatProducts,
  sortByPrice,
  filterByCategory("Electronics")
);

// 应用组合函数
const result = processProducts(products);
console.log(result);
// 输出: ["Headphones - $99", "Keyboard - $129", "Laptop - $999"]
```

这个例子展示了函数式编程的几个关键优势：

1. **可组合性** - 我们可以组合小函数来创建复杂操作
2. **可重用性** - 每个函数都可以单独使用和测试
3. **可读性** - 代码清晰地表达了其意图
4. **可测试性** - 纯函数易于测试，无需模拟

## 函数式编程的优势

1. **代码更加简洁、易读** - 通过高阶函数和组合等技术减少样板代码
2. **更容易测试** - 纯函数依赖少，输入输出明确
3. **并行处理更安全** - 不可变性和无副作用使并行代码更安全
4. **错误少** - 副作用减少意味着不易出错
5. **可维护性强** - 函数独立，容易理解和修改

## 函数式编程的挑战

1. **学习曲线** - 需要一种不同的思维方式
2. **性能考虑** - 创建新对象而非修改现有对象可能导致性能开销
3. **与现有代码集成** - 可能需要适应非函数式的代码库

## 总结

函数式编程为 JavaScript 开发者提供了一种强大的编程范式，帮助我们编写更简洁、更可维护的代码。通过纯函数、不可变性、高阶函数、柯里化和组合等核心概念，我们可以构建出更易于理解和测试的应用程序。

虽然完全的函数式编程在 JavaScript 中并不总是实际可行，但将函数式编程原则融入到我们的代码中可以带来显著的好处。

:::tip 学习建议
函数式编程需要一种不同的思维方式。从小的概念开始，如纯函数和使用内置高阶函数，然后逐步深入更复杂的概念如柯里化和组合。
:::

## 练习

1. 编写一个纯函数，计算数组中所有数字的平均值。
2. 使用 `map`、`filter` 和 `reduce` 函数创建一个管道，该管道筛选数组中的偶数，将其乘以2，然后计算总和。
3. 创建一个柯里化函数，可以用不同方式过滤数组元素。
4. 尝试组合多个函数，解决一个实际问题，如数据转换或过滤。

## 附加资源

- [JavaScript函数式编程指南](https://github.com/MostlyAdequate/mostly-adequate-guide)
- [函数式JavaScript介绍](https://eloquentjavascript.net/05_higher_order.html)
- [MDN文档：Array方法](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array)

通过实践和持续学习，函数式编程可以成为您JavaScript工具箱中的强大工具！