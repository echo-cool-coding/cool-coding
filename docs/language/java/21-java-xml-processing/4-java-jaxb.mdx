---
title: Java JAXB
description: 了解Java JAXB (Java Architecture for XML Binding)的基础知识，学习如何在Java应用程序中实现XML数据绑定
---

# Java JAXB

## 介绍

JAXB (Java Architecture for XML Binding) 是Java提供的一种用于XML数据绑定的技术。它允许开发者将Java对象转换为XML文档，或者将XML文档转换为Java对象。这种双向转换大大简化了Java应用程序处理XML数据的过程，使开发者无需深入了解XML解析的复杂细节。

JAXB主要提供两个核心功能：
- **编组(Marshal)**：将Java对象转换为XML文档
- **解组(Unmarshal)**：将XML文档转换为Java对象

:::note
JAXB从Java 6开始被包含在Java标准库中，在Java 11之前是Java SE的一部分。从Java 11开始，它被移出核心JDK，需要作为单独的依赖引入。
:::

## JAXB基础概念

在使用JAXB之前，我们需要了解几个关键注解：

1. **@XmlRootElement**: 标记Java类作为XML根元素
2. **@XmlElement**: 标记字段或属性作为XML元素
3. **@XmlAttribute**: 标记字段或属性作为XML属性
4. **@XmlAccessorType**: 控制JAXB如何访问类中的字段
5. **@XmlType**: 定义XML Schema类型

## 入门示例

### 步骤1：创建Java类并添加JAXB注解

```java
import jakarta.xml.bind.annotation.*;

@XmlRootElement(name = "student")
@XmlAccessorType(XmlAccessType.FIELD)
public class Student {
    @XmlAttribute
    private int id;
    
    @XmlElement
    private String name;
    
    @XmlElement
    private int age;
    
    // 默认构造函数（JAXB需要）
    public Student() {}
    
    public Student(int id, String name, int age) {
        this.id = id;
        this.name = name;
        this.age = age;
    }
    
    // Getters and Setters
    public int getId() { return id; }
    public void setId(int id) { this.id = id; }
    
    public String getName() { return name; }
    public void setName(String name) { this.name = name; }
    
    public int getAge() { return age; }
    public void setAge(int age) { this.age = age; }
    
    @Override
    public String toString() {
        return "Student [id=" + id + ", name=" + name + ", age=" + age + "]";
    }
}
```

:::caution
JAXB需要一个无参构造函数来创建对象实例，因此在使用JAXB的类中务必提供默认构造函数。
:::

### 步骤2：Java对象转换为XML（编组/Marshal）

```java
import jakarta.xml.bind.JAXBContext;
import jakarta.xml.bind.JAXBException;
import jakarta.xml.bind.Marshaller;
import java.io.File;

public class JaxbMarshalExample {
    public static void main(String[] args) {
        try {
            // 创建JAXBContext对象
            JAXBContext context = JAXBContext.newInstance(Student.class);
            
            // 创建Marshaller对象
            Marshaller marshaller = context.createMarshaller();
            
            // 设置格式化输出
            marshaller.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, true);
            
            // 创建Student对象
            Student student = new Student(1, "张三", 20);
            
            // 将Java对象转换为XML并输出到控制台
            System.out.println("输出到控制台:");
            marshaller.marshal(student, System.out);
            
            // 将Java对象转换为XML并保存到文件
            File file = new File("student.xml");
            marshaller.marshal(student, file);
            System.out.println("\nXML已保存到: " + file.getAbsolutePath());
            
        } catch (JAXBException e) {
            e.printStackTrace();
        }
    }
}
```

**输出结果:**
```xml
输出到控制台:
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<student id="1">
    <name>张三</name>
    <age>20</age>
</student>

XML已保存到: /path/to/student.xml
```

### 步骤3：XML转换为Java对象（解组/Unmarshal）

```java
import jakarta.xml.bind.JAXBContext;
import jakarta.xml.bind.JAXBException;
import jakarta.xml.bind.Unmarshaller;
import java.io.File;

public class JaxbUnmarshalExample {
    public static void main(String[] args) {
        try {
            // 创建JAXBContext对象
            JAXBContext context = JAXBContext.newInstance(Student.class);
            
            // 创建Unmarshaller对象
            Unmarshaller unmarshaller = context.createUnmarshaller();
            
            // 从XML文件读取并转换为Java对象
            File file = new File("student.xml");
            Student student = (Student) unmarshaller.unmarshal(file);
            
            // 输出转换后的Java对象
            System.out.println("解析XML后的Student对象: " + student);
            
        } catch (JAXBException e) {
            e.printStackTrace();
        }
    }
}
```

**输出结果:**
```
解析XML后的Student对象: Student [id=1, name=张三, age=20]
```

## 深入了解JAXB注解

### @XmlAccessorType

控制JAXB如何访问类中的字段:

```java
@XmlAccessorType(XmlAccessType.FIELD) // 直接访问字段
@XmlAccessorType(XmlAccessType.PROPERTY) // 通过getter/setter访问
@XmlAccessorType(XmlAccessType.PUBLIC_MEMBER) // 访问公共字段和属性（默认）
@XmlAccessorType(XmlAccessType.NONE) // 不自动访问任何字段或属性
```

### @XmlTransient

用于排除不需要转换为XML的字段:

```java
@XmlRootElement
@XmlAccessorType(XmlAccessType.FIELD)
public class Person {
    private String name;
    
    @XmlTransient
    private String password; // 此字段不会包含在XML中
}
```

### @XmlElementWrapper

用于生成集合周围的包装元素:

```java
@XmlRootElement
@XmlAccessorType(XmlAccessType.FIELD)
public class Course {
    private String courseName;
    
    @XmlElementWrapper(name = "students")
    @XmlElement(name = "student")
    private List<Student> studentList;
}
```

生成的XML:
```xml
<course>
    <courseName>Java编程</courseName>
    <students>
        <student>...</student>
        <student>...</student>
    </students>
</course>
```

## 实际应用案例：学生成绩管理系统

让我们来看一个更复杂的例子，展示如何使用JAXB处理多层嵌套的对象关系。

### 步骤1：定义数据模型

```java
@XmlRootElement(name = "school")
@XmlAccessorType(XmlAccessType.FIELD)
public class School {
    @XmlAttribute
    private String name;
    
    @XmlElementWrapper(name = "classes")
    @XmlElement(name = "class")
    private List<ClassRoom> classes;
    
    // 构造函数、getter和setter
}

@XmlAccessorType(XmlAccessType.FIELD)
public class ClassRoom {
    @XmlAttribute
    private String name;
    
    @XmlElementWrapper(name = "students")
    @XmlElement(name = "student")
    private List<Student> students;
    
    // 构造函数、getter和setter
}

@XmlAccessorType(XmlAccessType.FIELD)
public class Student {
    @XmlAttribute
    private int id;
    
    @XmlElement
    private String name;
    
    @XmlElementWrapper(name = "scores")
    @XmlElement(name = "subject")
    private Map<String, Integer> subjectScores;
    
    // 构造函数、getter和setter
}
```

### 步骤2：创建数据并转换为XML

```java
import jakarta.xml.bind.JAXBContext;
import jakarta.xml.bind.JAXBException;
import jakarta.xml.bind.Marshaller;
import java.io.File;
import java.util.*;

public class SchoolManagementSystem {
    public static void main(String[] args) {
        try {
            // 创建学生和分数
            Map<String, Integer> scores1 = new HashMap<>();
            scores1.put("数学", 95);
            scores1.put("语文", 88);
            scores1.put("英语", 92);
            
            Map<String, Integer> scores2 = new HashMap<>();
            scores2.put("数学", 78);
            scores2.put("语文", 90);
            scores2.put("英语", 85);
            
            // 创建学生
            Student student1 = new Student(1, "李明", scores1);
            Student student2 = new Student(2, "王红", scores2);
            
            // 创建班级并添加学生
            ClassRoom classRoom = new ClassRoom();
            classRoom.setName("一年级(1)班");
            classRoom.setStudents(Arrays.asList(student1, student2));
            
            // 创建学校并添加班级
            School school = new School();
            school.setName("实验小学");
            school.setClasses(Collections.singletonList(classRoom));
            
            // 创建JAXBContext
            JAXBContext context = JAXBContext.newInstance(School.class);
            Marshaller marshaller = context.createMarshaller();
            marshaller.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, true);
            
            // 将对象转换为XML并保存
            File file = new File("school.xml");
            marshaller.marshal(school, file);
            System.out.println("学校数据已保存到: " + file.getAbsolutePath());
            
            // 输出到控制台
            marshaller.marshal(school, System.out);
            
        } catch (JAXBException e) {
            e.printStackTrace();
        }
    }
}
```

**输出结果:**
```xml
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<school name="实验小学">
    <classes>
        <class name="一年级(1)班">
            <students>
                <student id="1">
                    <name>李明</name>
                    <scores>
                        <subject key="数学">95</subject>
                        <subject key="语文">88</subject>
                        <subject key="英语">92</subject>
                    </scores>
                </student>
                <student id="2">
                    <name>王红</name>
                    <scores>
                        <subject key="数学">78</subject>
                        <subject key="语文">90</subject>
                        <subject key="英语">85</subject>
                    </scores>
                </student>
            </students>
        </class>
    </classes>
</school>
```

### 步骤3：从XML读取数据

```java
import jakarta.xml.bind.JAXBContext;
import jakarta.xml.bind.JAXBException;
import jakarta.xml.bind.Unmarshaller;
import java.io.File;

public class ReadSchoolData {
    public static void main(String[] args) {
        try {
            // 创建JAXBContext
            JAXBContext context = JAXBContext.newInstance(School.class);
            Unmarshaller unmarshaller = context.createUnmarshaller();
            
            // 从XML文件读取学校数据
            File file = new File("school.xml");
            School school = (School) unmarshaller.unmarshal(file);
            
            // 打印学校信息
            System.out.println("学校名称: " + school.getName());
            
            // 遍历班级
            for (ClassRoom classRoom : school.getClasses()) {
                System.out.println("班级: " + classRoom.getName());
                
                // 遍历学生
                for (Student student : classRoom.getStudents()) {
                    System.out.println("  学生: " + student.getId() + " - " + student.getName());
                    
                    // 打印成绩
                    System.out.println("    成绩:");
                    for (Map.Entry<String, Integer> entry : student.getSubjectScores().entrySet()) {
                        System.out.println("      " + entry.getKey() + ": " + entry.getValue());
                    }
                }
            }
            
        } catch (JAXBException e) {
            e.printStackTrace();
        }
    }
}
```

**输出结果:**
```
学校名称: 实验小学
班级: 一年级(1)班
  学生: 1 - 李明
    成绩:
      数学: 95
      语文: 88
      英语: 92
  学生: 2 - 王红
    成绩:
      数学: 78
      语文: 90
      英语: 85
```

## 自定义适配器

当需要处理特殊数据类型时，可以使用JAXB适配器来自定义转换逻辑。

例如，假设我们要处理日期格式:

```java
import jakarta.xml.bind.annotation.adapters.XmlAdapter;
import java.text.SimpleDateFormat;
import java.util.Date;

public class DateAdapter extends XmlAdapter<String, Date> {
    private SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd");
    
    @Override
    public Date unmarshal(String v) throws Exception {
        return dateFormat.parse(v);
    }
    
    @Override
    public String marshal(Date v) throws Exception {
        return dateFormat.format(v);
    }
}
```

在类中使用适配器:

```java
import jakarta.xml.bind.annotation.*;
import jakarta.xml.bind.annotation.adapters.XmlJavaTypeAdapter;
import java.util.Date;

@XmlRootElement
@XmlAccessorType(XmlAccessType.FIELD)
public class Event {
    private String name;
    
    @XmlJavaTypeAdapter(DateAdapter.class)
    private Date eventDate;
    
    // 构造函数、getter和setter
}
```

## JAXB与命名空间

当处理带有命名空间的XML时，可以使用以下注解:

```java
@XmlRootElement(namespace = "http://www.example.org/student")
@XmlAccessorType(XmlAccessType.FIELD)
public class Student {
    @XmlElement(namespace = "http://www.example.org/student")
    private String name;
    
    // 其他字段和方法
}
```

生成的XML:
```xml
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<ns2:student xmlns:ns2="http://www.example.org/student">
    <ns2:name>张三</ns2:name>
</ns2:student>
```

## 常见问题及解决方案

### 1. 循环引用

当对象之间存在循环引用时，JAXB可能会陷入无限循环。解决方法是使用`@XmlTransient`注解排除导致循环的引用。

### 2. 大文件处理

当处理大型XML文件时，可以使用JAXB的流处理API:

```java
import jakarta.xml.bind.JAXBContext;
import jakarta.xml.bind.Unmarshaller;
import javax.xml.stream.XMLInputFactory;
import javax.xml.stream.XMLStreamReader;
import java.io.FileReader;

public class LargeFileProcessing {
    public static void main(String[] args) throws Exception {
        // 创建StAX解析器
        XMLInputFactory xif = XMLInputFactory.newFactory();
        XMLStreamReader xsr = xif.createXMLStreamReader(new FileReader("large-file.xml"));
        
        // 创建JAXB上下文
        JAXBContext context = JAXBContext.newInstance(Student.class);
        
        // 进入学生元素
        while (xsr.hasNext()) {
            xsr.next();
            if (xsr.isStartElement() && xsr.getLocalName().equals("student")) {
                // 解组单个student元素
                Unmarshaller unmarshaller = context.createUnmarshaller();
                Student student = (Student) unmarshaller.unmarshal(xsr);
                
                // 处理学生对象
                System.out.println("处理学生: " + student.getName());
            }
        }
    }
}
```

### 3. 版本兼容性

从Java 11开始，JAXB不再是Java SE的一部分，需要添加外部依赖。在Maven项目中添加:

```xml
<dependency>
    <groupId>jakarta.xml.bind</groupId>
    <artifactId>jakarta.xml.bind-api</artifactId>
    <version>3.0.1</version>
</dependency>
<dependency>
    <groupId>com.sun.xml.bind</groupId>
    <artifactId>jaxb-impl</artifactId>
    <version>3.0.1</version>
    <scope>runtime</scope>
</dependency>
```

## 总结

JAXB提供了一种简便的方式在Java对象和XML之间进行转换，大大简化了XML数据处理。通过本教程，我们学习了:

- JAXB的基本原理和工作方式
- 关键注解(@XmlRootElement, @XmlElement等)的使用方法
- 如何将Java对象转换为XML(Marshal)和将XML转换为Java对象(Unmarshal)
- 处理复杂数据结构和嵌套对象
- 自定义适配器的使用
- 处理命名空间和其他高级特性

无论是构建Web服务、配置文件处理，还是数据交换系统，JAXB都是处理XML数据的强大工具。

## 练习

1. 创建一个`Book`类，包含id、title、author和publishDate字段，并使用JAXB注解使其可以转换为XML。
2. 创建一个`Library`类，包含多本图书，并实现将整个图书馆保存为XML文件的功能。
3. 编写程序从XML文件中读取图书信息，并按发布日期排序。
4. 使用自定义适配器处理价格字段，确保它始终显示两位小数。
5. 创建一个带有命名空间的XML结构，包含图书和作者信息。

## 附加资源

- [Oracle JAXB官方文档](https://eclipse-ee4j.github.io/jaxb-ri/)
- [Jakarta XML Binding](https://jakarta.ee/specifications/xml-binding/)
- [JAXB GitHub项目](https://github.com/eclipse-ee4j/jaxb-ri)
- [JAXB API JavaDoc](https://jakarta.ee/specifications/xml-binding/3.0/apidocs/)

通过以上资源和练习，您将能够掌握JAXB并在实际项目中灵活应用XML数据绑定技术。