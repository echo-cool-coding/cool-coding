---
title: Java 不可变集合
description: 详细介绍Java中的不可变集合，包括其概念、特性、使用方法及应用场景
---

# Java 不可变集合

## 什么是不可变集合？

不可变集合(Immutable Collections)是指一旦创建后就不能被修改的集合。所谓"不能被修改"包括：不能添加元素、不能删除元素、不能替换元素，也不能改变集合的结构。如果尝试修改不可变集合，通常会抛出`UnsupportedOperationException`异常。

:::note 关键特点
不可变集合在创建后内容就固定下来，不能被更改。这与常规的可变集合（如ArrayList、HashMap等）有本质区别。
:::

## 为什么需要不可变集合？

不可变集合在Java编程中有多种优势：

1. **线程安全**：由于不可变性，多线程环境下不需要额外的同步措施
2. **防御性编程**：避免集合内容被意外修改
3. **减少错误**：避免因误操作而导致的数据损坏
4. **优化性能**：在某些情况下可以提供更好的性能和内存使用效率

## Java 中创建不可变集合的方式

### 1. 使用Collections工具类

Java提供了`Collections`工具类来创建不可变集合的包装器：

```java
// 创建不可变List
List<String> mutableList = new ArrayList<>();
mutableList.add("Java");
mutableList.add("Python");
List<String> immutableList = Collections.unmodifiableList(mutableList);

// 创建不可变Set
Set<Integer> mutableSet = new HashSet<>();
mutableSet.add(1);
mutableSet.add(2);
Set<Integer> immutableSet = Collections.unmodifiableSet(mutableSet);

// 创建不可变Map
Map<String, Integer> mutableMap = new HashMap<>();
mutableMap.put("One", 1);
mutableMap.put("Two", 2);
Map<String, Integer> immutableMap = Collections.unmodifiableMap(mutableMap);
```

:::caution 注意事项
使用`Collections.unmodifiable*`方法创建的不可变集合是原集合的"视图"。如果原集合改变，不可变集合也会随之改变。这可能导致潜在的问题！
:::

让我们看看这种情况的示例：

```java
List<String> mutableList = new ArrayList<>();
mutableList.add("Java");
List<String> immutableList = Collections.unmodifiableList(mutableList);

System.out.println(immutableList); // 输出: [Java]

// 修改原始集合
mutableList.add("Python");

// 不可变集合也会改变！
System.out.println(immutableList); // 输出: [Java, Python]

// 但直接修改不可变集合会抛出异常
try {
    immutableList.add("Ruby"); // 抛出UnsupportedOperationException
} catch (UnsupportedOperationException e) {
    System.out.println("无法修改不可变集合");
}
```

### 2. Java 9及以后版本的of()方法

从Java 9开始，集合接口提供了更简洁的创建不可变集合的方法：

```java
// 创建不可变List
List<String> immutableList = List.of("Java", "Python", "Ruby");

// 创建不可变Set
Set<String> immutableSet = Set.of("Red", "Green", "Blue");

// 创建不可变Map
Map<String, Integer> immutableMap = Map.of(
    "One", 1,
    "Two", 2,
    "Three", 3
);

// 对于更多的键值对，使用Map.ofEntries
Map<String, Integer> largeImmutableMap = Map.ofEntries(
    Map.entry("One", 1),
    Map.entry("Two", 2),
    Map.entry("Three", 3),
    Map.entry("Four", 4)
    // 可以添加更多
);
```

:::tip 优势
`of()`方法创建的集合是真正的不可变集合，它们不依赖于任何底层的可变集合。
:::

让我们尝试修改使用`of()`方法创建的不可变集合：

```java
List<String> immutableList = List.of("Java", "Python");
try {
    immutableList.add("Ruby"); // 抛出UnsupportedOperationException
} catch (UnsupportedOperationException e) {
    System.out.println("无法修改不可变集合");
}

Map<String, Integer> immutableMap = Map.of("One", 1, "Two", 2);
try {
    immutableMap.put("Three", 3); // 抛出UnsupportedOperationException
} catch (UnsupportedOperationException e) {
    System.out.println("无法修改不可变Map");
}
```

输出：
```
无法修改不可变集合
无法修改不可变Map
```

### 3. Java 10引入的copyOf()方法

Java 10为集合接口添加了`copyOf()`方法，该方法接受一个现有集合并创建其不可变副本：

```java
// 创建一个可变集合
List<String> mutableList = new ArrayList<>();
mutableList.add("Java");
mutableList.add("Python");

// 创建不可变副本
List<String> immutableList = List.copyOf(mutableList);

// 修改原始集合不会影响不可变副本
mutableList.add("Ruby");
System.out.println(mutableList);    // 输出: [Java, Python, Ruby]
System.out.println(immutableList);  // 输出: [Java, Python]
```

## 不可变集合的特性和限制

### 特性

1. **线程安全**：多线程环境下不需要额外的同步
2. **防御性**：保护数据不被篡改
3. **内存效率**：某些实现（如Java 9+的`of()`方法）提供了内存高效的实现

### 限制

1. **不允许null值**：Java 9及以后版本的`of()`和`copyOf()`方法不接受null元素
2. **不支持修改操作**：所有修改操作（如add、remove等）都会抛出异常
3. **没有增量构建API**：无法像构建器模式那样逐步构建

让我们验证不允许null值的限制：

```java
try {
    List<String> list = List.of("Java", null, "Python"); // 抛出NullPointerException
} catch (NullPointerException e) {
    System.out.println("List.of()方法不接受null元素");
}
```

输出：
```
List.of()方法不接受null元素
```

## 实际应用场景

### 1. 配置信息

当你需要在应用程序中存储不应被修改的配置信息时：

```java
public class ApplicationConfig {
    private static final Map<String, String> DEFAULT_SETTINGS = Map.of(
        "timeout", "30",
        "maxConnections", "100",
        "defaultLocale", "en_US"
    );
    
    public static Map<String, String> getDefaultSettings() {
        return DEFAULT_SETTINGS; // 安全返回，因为是不可变的
    }
}
```

### 2. 常量集合

定义应用程序中的常量集合：

```java
public class CountryCodes {
    public static final Set<String> EUROPEAN_COUNTRIES = Set.of(
        "DE", "FR", "IT", "ES", "UK", "NL"
    );
    
    public static final Map<String, String> COUNTRY_NAMES = Map.of(
        "DE", "Germany",
        "FR", "France",
        "IT", "Italy"
    );
}
```

### 3. 多线程环境中的共享数据

当多个线程需要访问相同的数据集合，但不需要修改它：

```java
public class ThreadSafeCache {
    private final Map<String, User> userCache;
    
    public ThreadSafeCache(Map<String, User> initialUsers) {
        // 创建原始Map的不可变副本
        this.userCache = Map.copyOf(initialUsers);
    }
    
    public User getUser(String id) {
        return userCache.get(id);
    }
    
    // 不提供setUser方法，确保缓存不可修改
}
```

### 4. 返回集合的API

当你的方法需要返回集合，但不希望调用者修改这些集合时：

```java
public class ProductCatalog {
    private List<Product> products = new ArrayList<>();
    
    public void addProduct(Product product) {
        products.add(product);
    }
    
    public List<Product> getProducts() {
        // 返回不可变副本，防止外部修改
        return List.copyOf(products);
    }
}
```

## 性能考虑

不可变集合通常在某些操作上比可变集合更高效：

1. **不需要拷贝防御**：方法返回不可变集合时，不需要创建防御性拷贝
2. **减少内存使用**：一些不可变集合实现针对内存使用进行了优化
3. **无需同步**：在多线程环境中不需要同步，可以提高性能

## 实践练习

### 练习1: 创建并使用不可变集合

```java
import java.util.*;

public class ImmutableCollectionsDemo {
    public static void main(String[] args) {
        // 创建并使用不可变List
        List<String> fruits = List.of("Apple", "Banana", "Orange");
        System.out.println("Fruits: " + fruits);
        
        // 使用stream和过滤器
        List<String> longFruitNames = fruits.stream()
                                          .filter(name -> name.length() > 5)
                                          .toList(); // Java 16+的新方法，创建不可变List
        System.out.println("Long fruit names: " + longFruitNames);
        
        // 创建不可变Map
        Map<String, Integer> fruitCalories = Map.of(
            "Apple", 95,
            "Banana", 105,
            "Orange", 45
        );
        System.out.println("Calories in Apple: " + fruitCalories.get("Apple"));
    }
}
```

### 练习2: 防止集合修改错误

```java
import java.util.*;

public class ImmutableDefense {
    // 存储产品目录
    private static final List<String> productCodes = new ArrayList<>();
    
    static {
        productCodes.add("A001");
        productCodes.add("B002");
        productCodes.add("C003");
    }
    
    // 不安全的方法 - 返回可变集合
    public static List<String> getProductCodesUnsafe() {
        return productCodes; // 危险！调用者可以修改我们的内部列表
    }
    
    // 安全的方法 - 返回不可变集合
    public static List<String> getProductCodesSafe() {
        return Collections.unmodifiableList(productCodes);
    }
    
    // 更安全的方法 (Java 10+) - 返回不可变副本
    public static List<String> getProductCodesSafer() {
        return List.copyOf(productCodes);
    }
    
    public static void main(String[] args) {
        // 演示不安全方法的风险
        List<String> codes = getProductCodesUnsafe();
        codes.add("D004"); // 这会修改原始列表！
        System.out.println("After unsafe modification: " + productCodes);
        
        // 演示安全方法
        try {
            List<String> safeCodes = getProductCodesSafe();
            safeCodes.add("E005"); // 会抛出异常
        } catch (UnsupportedOperationException e) {
            System.out.println("安全地阻止了修改");
        }
        
        // 原始列表仍然可以修改
        productCodes.add("F006");
        System.out.println("Final product codes: " + productCodes);
    }
}
```

## 总结

Java不可变集合是编写安全、可靠代码的重要工具：

1. 不可变集合创建后不能被修改
2. Java提供了多种创建不可变集合的方法：
   - `Collections.unmodifiable*`方法（所有Java版本）
   - `List.of()`, `Set.of()`, `Map.of()`（Java 9+）
   - `List.copyOf()`, `Set.copyOf()`, `Map.copyOf()`（Java 10+）
3. 不可变集合的主要优势包括线程安全、防御性编程和潜在的性能优化
4. 实际应用场景包括配置信息、常量集合、多线程环境和API设计

在日常开发中，应当积极考虑使用不可变集合来提高代码的安全性和可维护性。

## 进一步学习资源

- Java官方文档中的[Immutable List](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/List.html#unmodifiable)部分
- [Java 9中的集合工厂方法](https://docs.oracle.com/javase/9/core/creating-immutable-lists-sets-and-maps.htm)
- 《Effective Java》第3版，第15条：使类和成员的可访问性最小化
- 《Java Concurrency in Practice》：深入讨论了不变性与线程安全

:::tip 练习建议
尝试在您的下一个项目中识别可以使用不可变集合的场景，特别是那些需要线程安全性或防止意外修改的情况。将可变集合替换为不可变集合，并观察代码质量的提升。
:::