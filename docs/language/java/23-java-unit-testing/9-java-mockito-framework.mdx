---
title: Java Mockito框架
description: 了解Mockito框架如何简化Java单元测试，掌握模拟对象创建、验证与存根技术的基础知识及实际应用
---

# Java Mockito框架

## 什么是Mockito？

Mockito是Java中最流行的模拟测试框架之一，它允许我们创建和配置**模拟对象**（mock objects），以便在进行单元测试时替代真实的依赖对象。当我们需要测试一个类但不想涉及其依赖项时，Mockito提供了一种简单的方式来模拟这些依赖项的行为。

:::tip
单元测试应该专注于测试特定单元的功能，而不是它的依赖项。Mockito帮助我们实现这个目标！
:::

## 为什么需要Mockito？

想象一下这个场景：你正在测试一个处理用户信息的服务类，该类依赖于数据库访问。如果不使用模拟技术，你的测试将会：

1. 需要一个实际的数据库连接
2. 运行速度变慢
3. 可能因为数据库问题而失败
4. 难以构造特定的测试场景

使用Mockito，我们可以模拟数据库交互，使测试更加：
- 快速
- 可靠
- 独立
- 专注于被测试的功能逻辑

## 开始使用Mockito

### 添加依赖

首先，我们需要在项目中添加Mockito依赖。如果你使用Maven：

```xml
<dependency>
    <groupId>org.mockito</groupId>
    <artifactId>mockito-core</artifactId>
    <version>5.3.1</version>
    <scope>test</scope>
</dependency>
```

如果你使用Gradle：

```groovy
testImplementation 'org.mockito:mockito-core:5.3.1'
```

### Mockito基础知识

Mockito主要提供三个核心功能：

1. **创建模拟对象** - 生成一个类或接口的模拟实现
2. **存根(Stubbing)** - 定义当模拟对象的方法被调用时应该返回什么
3. **验证(Verification)** - 检查模拟对象的方法是否按预期被调用

## 创建模拟对象

创建模拟对象有几种方法：

```java
// 方法1：使用mock静态方法
import static org.mockito.Mockito.mock;

List<String> mockedList = mock(List.class);

// 方法2：使用注解(需要初始化注解)
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;

public class MyTest {
    @Mock
    List<String> mockedList;
    
    @BeforeEach
    public void init() {
        MockitoAnnotations.openMocks(this);
    }
}

// 方法3：使用JUnit 5的@ExtendWith
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import org.junit.jupiter.api.extension.ExtendWith;

@ExtendWith(MockitoExtension.class)
public class MyTest {
    @Mock
    List<String> mockedList;
}
```

## 存根方法(Stubbing)

存根是指告诉模拟对象在调用某个方法时应该有什么行为：

```java
// 导入需要的静态方法
import static org.mockito.Mockito.*;

// 创建模拟对象
List<String> mockedList = mock(List.class);

// 设置存根 - 定义方法调用的返回值
when(mockedList.get(0)).thenReturn("first element");
when(mockedList.size()).thenReturn(1);

// 使用模拟对象
System.out.println(mockedList.get(0)); // 输出: first element
System.out.println(mockedList.get(1)); // 输出: null (未存根的方法返回默认值)
System.out.println(mockedList.size()); // 输出: 1
```

### 存根异常抛出

```java
// 设置当调用get(1)时抛出异常
when(mockedList.get(1)).thenThrow(new RuntimeException("索引越界"));

// 这行代码会抛出RuntimeException
mockedList.get(1);
```

## 验证方法调用

验证模拟对象的方法是否按预期被调用：

```java
// 创建模拟对象
List<String> mockedList = mock(List.class);

// 调用方法
mockedList.add("one");
mockedList.add("two");
mockedList.add("two");
mockedList.clear();

// 验证add("one")被调用了1次
verify(mockedList).add("one");
// 验证add("two")被调用了2次
verify(mockedList, times(2)).add("two");
// 验证clear()被调用
verify(mockedList).clear();
```

## 参数匹配器

当你不关心方法的具体参数值，或者需要更灵活的参数匹配时，可以使用参数匹配器：

```java
import static org.mockito.ArgumentMatchers.*;

// 使用参数匹配器
when(mockedList.get(anyInt())).thenReturn("element");
when(mockedList.contains(argThat(str -> str.length() > 5))).thenReturn(true);

// 以下两个调用都会返回"element"
System.out.println(mockedList.get(0));  // 输出: element
System.out.println(mockedList.get(999)); // 输出: element

// 检查包含长度大于5的字符串
System.out.println(mockedList.contains("123456")); // 输出: true
System.out.println(mockedList.contains("1234")); // 输出: false
```

## 实际应用案例

让我们来看一个真实的应用场景。假设我们有一个`UserService`类，它依赖于`UserRepository`来获取和保存用户数据：

```java
public class UserService {
    private final UserRepository userRepository;
    
    public UserService(UserRepository userRepository) {
        this.userRepository = userRepository;
    }
    
    public User getUserById(String id) {
        return userRepository.findById(id);
    }
    
    public boolean updateUserEmail(String id, String newEmail) {
        User user = userRepository.findById(id);
        if (user == null) {
            return false;
        }
        
        if (!isValidEmail(newEmail)) {
            return false;
        }
        
        user.setEmail(newEmail);
        userRepository.save(user);
        return true;
    }
    
    private boolean isValidEmail(String email) {
        // 简单的邮箱验证逻辑
        return email != null && email.matches("^[A-Za-z0-9+_.-]+@(.+)$");
    }
}

// 依赖接口
public interface UserRepository {
    User findById(String id);
    void save(User user);
}

// 用户类
public class User {
    private String id;
    private String name;
    private String email;
    
    // 构造函数、getter和setter省略
}
```

现在，我们可以使用Mockito来测试`UserService`类，而不需要实际的`UserRepository`实现：

```java
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

public class UserServiceTest {
    
    @Mock
    private UserRepository userRepository;
    
    private UserService userService;
    
    @BeforeEach
    public void setup() {
        MockitoAnnotations.openMocks(this);
        userService = new UserService(userRepository);
    }
    
    @Test
    public void testGetUserById() {
        // 准备测试数据
        String userId = "123";
        User expectedUser = new User();
        expectedUser.setId(userId);
        expectedUser.setName("张三");
        expectedUser.setEmail("zhangsan@example.com");
        
        // 设置模拟行为
        when(userRepository.findById(userId)).thenReturn(expectedUser);
        
        // 执行测试
        User result = userService.getUserById(userId);
        
        // 验证结果
        assertEquals(expectedUser, result);
        verify(userRepository).findById(userId);
    }
    
    @Test
    public void testUpdateUserEmail_Success() {
        // 准备测试数据
        String userId = "123";
        String newEmail = "new.email@example.com";
        
        User user = new User();
        user.setId(userId);
        user.setEmail("old.email@example.com");
        
        // 设置模拟行为
        when(userRepository.findById(userId)).thenReturn(user);
        
        // 执行测试
        boolean result = userService.updateUserEmail(userId, newEmail);
        
        // 验证结果
        assertTrue(result);
        assertEquals(newEmail, user.getEmail());
        verify(userRepository).findById(userId);
        verify(userRepository).save(user);
    }
    
    @Test
    public void testUpdateUserEmail_UserNotFound() {
        // 设置模拟行为 - 找不到用户
        when(userRepository.findById(anyString())).thenReturn(null);
        
        // 执行测试
        boolean result = userService.updateUserEmail("unknown", "email@example.com");
        
        // 验证结果
        assertFalse(result);
        verify(userRepository).findById("unknown");
        verify(userRepository, never()).save(any());
    }
    
    @Test
    public void testUpdateUserEmail_InvalidEmail() {
        // 准备测试数据
        String userId = "123";
        String invalidEmail = "invalid-email";
        
        User user = new User();
        user.setId(userId);
        
        // 设置模拟行为
        when(userRepository.findById(userId)).thenReturn(user);
        
        // 执行测试
        boolean result = userService.updateUserEmail(userId, invalidEmail);
        
        // 验证结果
        assertFalse(result);
        verify(userRepository).findById(userId);
        verify(userRepository, never()).save(any());
    }
}
```

## Mockito高级功能

### 1. 监听器（Spy）

Spy允许部分模拟一个真实的对象，未被存根的方法将调用真实的逻辑：

```java
List<String> realList = new ArrayList<>();
List<String> spyList = spy(realList);

// 使用真实方法
spyList.add("one");
spyList.add("two");

// 验证
assertEquals(2, spyList.size());

// 存根特定方法
when(spyList.size()).thenReturn(100);
assertEquals(100, spyList.size());

// 其他方法仍然调用实际实现
assertEquals("one", spyList.get(0));
```

### 2. 参数捕获器

捕获传递给模拟对象方法的参数，以便进行额外断言：

```java
import org.mockito.ArgumentCaptor;

@Test
public void testArgumentCaptor() {
    // 创建模拟对象
    List<String> mockedList = mock(List.class);
    
    // 使用模拟对象
    mockedList.addAll(Arrays.asList("one", "two", "three"));
    
    // 创建参数捕获器
    ArgumentCaptor<List<String>> argumentCaptor = ArgumentCaptor.forClass(List.class);
    
    // 验证方法调用并捕获参数
    verify(mockedList).addAll(argumentCaptor.capture());
    
    // 对捕获的参数进行断言
    List<String> capturedArgument = argumentCaptor.getValue();
    assertEquals(3, capturedArgument.size());
    assertEquals("one", capturedArgument.get(0));
    assertEquals("two", capturedArgument.get(1));
    assertEquals("three", capturedArgument.get(2));
}
```

### 3. 连续调用

配置模拟对象在连续调用时返回不同的值：

```java
// 连续调用返回不同的值
when(mockedList.get(0))
    .thenReturn("first call")
    .thenReturn("second call")
    .thenReturn("third call");

// 等价于
when(mockedList.get(0)).thenReturn("first call", "second call", "third call");

// 测试结果
assertEquals("first call", mockedList.get(0));
assertEquals("second call", mockedList.get(0));
assertEquals("third call", mockedList.get(0));
assertEquals("third call", mockedList.get(0)); // 之后的调用都返回最后一个值
```

## 最佳实践

1. **只模拟必要的依赖**：避免过度模拟，只模拟那些你无法在测试环境中控制的依赖项。

2. **不要模拟被测系统**：模拟是用来测试系统与其依赖项的交互，不是为了测试系统本身。

3. **保持测试简单**：每个测试方法应该只测试一个行为或场景。

4. **使用有意义的命名**：给测试方法起名时应该描述被测试的行为。

5. **验证必要的交互**：只验证对测试结果有意义的交互，避免验证实现细节。

```mermaid
graph LR
    A[单元测试] --> B[创建Mock对象]
    B --> C[设置Mock对象行为]
    C --> D[调用被测试方法]
    D --> E[验证结果]
    E --> F[验证Mock对象交互]
```

## 总结

Mockito是Java单元测试中强大且易用的模拟框架，它帮助我们：

- 隔离被测试代码与其依赖
- 通过模拟对象控制测试环境
- 验证代码是否按预期与依赖交互
- 编写更快、更可靠的单元测试

通过Mockito，我们可以轻松测试复杂系统中单个组件的行为，而不必担心其依赖项的实际实现和状态。

## 练习

1. 创建一个`EmailService`类，它依赖于`EmailSender`接口来发送电子邮件，然后使用Mockito测试这个服务类。

2. 编写一个`ProductService`，它从`ProductRepository`获取产品信息并计算折扣价格，使用Mockito测试不同的折扣计算场景。

3. 实现一个`NotificationService`，它需要协调多个依赖（如`UserService`、`MessageFormatter`和`NotificationSender`）来发送通知，然后使用Mockito测试各种通知场景。

## 进一步学习资源

- [官方Mockito文档](https://javadoc.io/doc/org.mockito/mockito-core/latest/org/mockito/Mockito.html)
- 《Practical Unit Testing with JUnit and Mockito》by Tomek Kaczanowski
- 《Test-Driven Development: By Example》by Kent Beck

通过掌握Mockito，你将能够编写更健壮、更可维护的单元测试，进而提高代码质量和可靠性！