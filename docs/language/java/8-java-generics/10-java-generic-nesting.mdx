---
title: Java 泛型嵌套
description: 深入理解Java泛型的嵌套使用，包括嵌套泛型容器的声明、使用及实际应用场景
---

# Java 泛型嵌套

在学习了Java泛型的基础知识后，你可能会遇到更复杂的场景，需要在泛型中嵌套使用泛型。本文将详细介绍Java泛型嵌套的概念、语法和实际应用，帮助你更全面地掌握泛型的高级用法。

## 什么是泛型嵌套？

泛型嵌套是指在一个泛型类型中再次使用泛型类型作为类型参数。简单来说，就是泛型中的泛型。常见的例子包括：

- `List<List<String>>` - 字符串列表的列表
- `Map<String, List<Integer>>` - 键为字符串，值为整数列表的映射
- `Pair<K, List<V>>` - 第一个元素为K类型，第二个元素为V类型列表的键值对

泛型嵌套使我们能够构建更复杂的数据结构，更精确地表达程序的数据模型。

## 嵌套泛型的声明和使用

### 基本语法

嵌套泛型的声明语法如下：

```java
CollectionType1<CollectionType2<ElementType>> variableName;
```

例如：

```java
// 字符串列表的列表
List<List<String>> listOfStringLists = new ArrayList<>();

// 键为String，值为Integer列表的映射
Map<String, List<Integer>> mapOfLists = new HashMap<>();
```

### 初始化与赋值

嵌套泛型的初始化需要逐层进行，例如：

```java
// 初始化外层容器
List<List<String>> nestedList = new ArrayList<>();

// 初始化并添加内层容器
List<String> innerList1 = new ArrayList<>();
innerList1.add("Java");
innerList1.add("Python");
nestedList.add(innerList1);

// 再添加一个内层容器
List<String> innerList2 = new ArrayList<>();
innerList2.add("C++");
innerList2.add("JavaScript");
nestedList.add(innerList2);
```

### 访问嵌套泛型中的元素

访问嵌套泛型中的元素需要多次索引或键值操作：

```java
// 获取第一个列表的第二个元素
String language = nestedList.get(0).get(1); // "Python"

// 遍历嵌套列表
for (List<String> innerList : nestedList) {
    for (String language : innerList) {
        System.out.println(language);
    }
}
```

## 深入理解泛型嵌套

### 类型擦除与嵌套泛型

Java的泛型是通过类型擦除实现的，这意味着在运行时所有泛型信息都会被擦除。对于嵌套泛型，外层和内层的泛型信息都会被擦除：

```java
List<List<String>> nestedList = new ArrayList<>();
// 在运行时等同于
List rawNestedList = new ArrayList();
```

但编译器会在编译时执行类型检查，确保你正确使用了嵌套泛型。

### 嵌套泛型的类型通配符

泛型通配符也可以应用于嵌套泛型：

```java
// 接受任何类型列表的列表
void processLists(List<List<?>> listOfLists) { ... }

// 接受Number或其子类的列表的列表
void processNumberLists(List<List<? extends Number>> listOfNumberLists) { ... }

// 接受Integer或其父类的列表的列表
void addToIntegerLists(List<List<? super Integer>> listOfSuperIntegerLists) { ... }
```

## 实际应用场景

### 场景一：二维数据结构

嵌套泛型非常适合表示二维数据结构，如矩阵、表格数据等：

```java
// 创建表示矩阵的嵌套列表
List<List<Double>> matrix = new ArrayList<>();
// 添加行
for (int i = 0; i < 3; i++) {
    List<Double> row = new ArrayList<>();
    for (int j = 0; j < 3; j++) {
        row.add(Math.random() * 100);
    }
    matrix.add(row);
}

// 计算矩阵的每行之和
List<Double> rowSums = new ArrayList<>();
for (List<Double> row : matrix) {
    double sum = 0;
    for (Double value : row) {
        sum += value;
    }
    rowSums.add(sum);
}

// 输出每行及其和
for (int i = 0; i < matrix.size(); i++) {
    System.out.println("Row " + (i+1) + ": " + matrix.get(i));
    System.out.println("Sum: " + rowSums.get(i));
}
```

### 场景二：分组数据

嵌套泛型适用于需要按某种规则分组的数据：

```java
// 按首字母分组单词
Map<Character, List<String>> wordsByFirstLetter = new HashMap<>();

// 添加单词到相应的分组
void addWord(String word) {
    if (word == null || word.isEmpty()) {
        return;
    }
    
    char firstLetter = Character.toUpperCase(word.charAt(0));
    
    // 如果该字母的列表不存在，则创建一个
    wordsByFirstLetter.putIfAbsent(firstLetter, new ArrayList<>());
    
    // 添加单词到相应的列表
    wordsByFirstLetter.get(firstLetter).add(word);
}

// 测试代码
public static void main(String[] args) {
    Main app = new Main();
    String[] words = {"Apple", "Banana", "Avocado", "Bear", "Cat"};
    
    for (String word : words) {
        app.addWord(word);
    }
    
    // 打印结果
    for (Map.Entry<Character, List<String>> entry : app.wordsByFirstLetter.entrySet()) {
        System.out.println(entry.getKey() + ": " + entry.getValue());
    }
}

// 输出:
// A: [Apple, Avocado]
// B: [Banana, Bear]
// C: [Cat]
```

### 场景三：树形结构

嵌套泛型也可以用来表示树形结构：

```java
class TreeNode<T> {
    private T data;
    private List<TreeNode<T>> children;
    
    public TreeNode(T data) {
        this.data = data;
        this.children = new ArrayList<>();
    }
    
    public void addChild(T childData) {
        children.add(new TreeNode<>(childData));
    }
    
    public void addChild(TreeNode<T> child) {
        children.add(child);
    }
    
    public T getData() {
        return data;
    }
    
    public List<TreeNode<T>> getChildren() {
        return children;
    }
}

// 使用示例
public static void main(String[] args) {
    TreeNode<String> root = new TreeNode<>("Root");
    
    TreeNode<String> child1 = new TreeNode<>("Child 1");
    child1.addChild("Grandchild 1.1");
    child1.addChild("Grandchild 1.2");
    
    TreeNode<String> child2 = new TreeNode<>("Child 2");
    child2.addChild("Grandchild 2.1");
    
    root.addChild(child1);
    root.addChild(child2);
    root.addChild(new TreeNode<>("Child 3"));
    
    // 打印树形结构
    printTree(root, 0);
}

static void printTree(TreeNode<String> node, int level) {
    for (int i = 0; i < level; i++) {
        System.out.print("  ");
    }
    System.out.println("- " + node.getData());
    
    for (TreeNode<String> child : node.getChildren()) {
        printTree(child, level + 1);
    }
}

// 输出:
// - Root
//   - Child 1
//     - Grandchild 1.1
//     - Grandchild 1.2
//   - Child 2
//     - Grandchild 2.1
//   - Child 3
```

## 嵌套泛型的常见陷阱和注意事项

### 1. 代码复杂性增加

嵌套泛型可能导致代码变得复杂且难以阅读：

:::tip 改进可读性的技巧
使用类型别名或将复杂的泛型类型提取为单独的类可以提高代码的可读性：

```java
// 原始复杂类型
Map<String, List<Map<Integer, Set<Long>>>> complexType;

// 提取为单独的类型
class DataNode {
    private Map<Integer, Set<Long>> mappings;
    // ... 方法和构造器
}

// 简化后的类型
Map<String, List<DataNode>> moreReadableType;
```
:::

### 2. 类型安全与原始类型

在使用嵌套泛型时，确保所有层次都指定了类型参数，避免使用原始类型：

```java
// 错误：混合使用泛型和原始类型
List<List> badPractice = new ArrayList<>(); // 内部List没有指定类型参数

// 正确：所有层次都有类型参数
List<List<String>> goodPractice = new ArrayList<>();
```

### 3. 泛型数组的限制

Java不允许创建泛型类型的数组，这一限制在嵌套泛型时也存在：

```java
// 编译错误
List<String>[] arrayOfLists = new List<String>[10]; // 不允许

// 替代方案
List<List<String>> listOfLists = new ArrayList<>();
for (int i = 0; i < 10; i++) {
    listOfLists.add(new ArrayList<>());
}
```

## 总结

泛型嵌套是Java泛型的高级用法，它允许我们构建更复杂、更灵活的数据结构。通过嵌套泛型，我们可以：

1. 创建多维数据结构，如列表的列表、映射的列表等
2. 更精确地表达程序的数据模型和类型关系
3. 在编译时获得更严格的类型检查，提高代码的健壮性

虽然嵌套泛型使用起来可能较为复杂，但掌握这一技术能够帮助你编写更加类型安全和表达力强的代码。

## 练习

1. 创建一个表示学校的数据结构，其中包含年级（Grade）、班级（Class）和学生（Student）的嵌套结构。
2. 实现一个方法，接受一个`List<List<Integer>>`参数，计算所有内部列表元素的总和。
3. 创建一个`Map<String, Map<String, Integer>>`结构，用于存储不同国家不同城市的人口数量，并实现相关的查询功能。
4. 设计一个泛型树形结构，并实现深度优先和广度优先遍历算法。

:::caution 警告
务必注意泛型嵌套的层次不要过多，否则会导致代码可读性急剧下降。一般来说，嵌套不应超过2-3层。如果需要更复杂的结构，考虑创建自定义类来封装部分类型信息。
:::

## 延伸阅读

- Java官方文档中的泛型指南
- 《Effective Java》中关于泛型的章节
- 《Java泛型与集合》一书

通过深入学习泛型嵌套，你将能够更加灵活地使用Java泛型，构建更复杂、更类型安全的应用程序。