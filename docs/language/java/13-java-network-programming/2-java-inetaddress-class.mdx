---
title: Java InetAddress类
description: 本文详细介绍了Java网络编程中的InetAddress类，包括其基本概念、主要方法以及实际应用示例，帮助初学者理解如何在Java中处理IP地址和主机名。
---

# Java InetAddress类

## 介绍

在Java网络编程中，`InetAddress`类是一个非常重要的类，它代表互联网协议(IP)地址。无论是IPv4还是IPv6地址，在Java中都使用`InetAddress`类来表示。这个类提供了将主机名解析为IP地址（或反之）的方法，是构建网络应用的基础。

`InetAddress`类位于`java.net`包中，它是一个抽象类，有两个子类：`Inet4Address`（用于IPv4）和`Inet6Address`（用于IPv6）。大多数情况下，我们不需要直接使用这两个子类，而是通过`InetAddress`类的静态方法来获取实例。

## InetAddress类的基本使用

### 获取InetAddress实例

`InetAddress`类没有公共构造函数，我们需要通过其静态方法来创建实例。以下是常用的几种方法：

```java
import java.net.InetAddress;
import java.net.UnknownHostException;

public class InetAddressDemo {
    public static void main(String[] args) {
        try {
            // 通过主机名获取InetAddress实例
            InetAddress address1 = InetAddress.getByName("www.example.com");
            System.out.println("通过主机名获取: " + address1);
            
            // 通过IP地址获取InetAddress实例
            InetAddress address2 = InetAddress.getByName("192.168.1.1");
            System.out.println("通过IP地址获取: " + address2);
            
            // 获取本地主机的InetAddress实例
            InetAddress localHost = InetAddress.getLocalHost();
            System.out.println("本地主机: " + localHost);
            
        } catch (UnknownHostException e) {
            e.printStackTrace();
        }
    }
}
```

输出示例：
```
通过主机名获取: www.example.com/93.184.216.34
通过IP地址获取: /192.168.1.1
本地主机: your-computer-name/192.168.0.100
```

### 主要方法

`InetAddress`类提供了许多有用的方法，下面列出一些常用的：

1. **获取主机名和IP地址**

```java
InetAddress address = InetAddress.getByName("www.example.com");
// 获取主机名
String hostname = address.getHostName();
System.out.println("主机名: " + hostname);

// 获取主机地址（IP地址）
String hostAddress = address.getHostAddress();
System.out.println("IP地址: " + hostAddress);
```

2. **检查可达性**

```java
InetAddress address = InetAddress.getByName("www.example.com");
// 检查主机是否可达（超时设置为5000毫秒）
boolean reachable = address.isReachable(5000);
System.out.println("主机是否可达: " + reachable);
```

3. **获取全限定域名**

```java
InetAddress address = InetAddress.getByName("www.example.com");
// 获取全限定域名
String canonicalHostName = address.getCanonicalHostName();
System.out.println("全限定域名: " + canonicalHostName);
```

4. **判断地址类型**

```java
InetAddress address = InetAddress.getByName("www.example.com");
// 检查是否是环回地址
boolean isLoopback = address.isLoopbackAddress();
System.out.println("是否为环回地址: " + isLoopback);

// 检查是否是链路本地地址
boolean isLinkLocal = address.isLinkLocalAddress();
System.out.println("是否为链路本地地址: " + isLinkLocal);
```

## 实际应用场景

### 场景一：简单的主机名解析器

以下是一个简单的应用，可以解析多个主机名并显示它们的IP地址：

```java
import java.net.InetAddress;
import java.net.UnknownHostException;
import java.util.Scanner;

public class HostResolver {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        
        System.out.println("欢迎使用主机名解析器！");
        System.out.println("请输入主机名（输入'exit'退出）:");
        
        while (true) {
            String input = scanner.nextLine().trim();
            
            if ("exit".equalsIgnoreCase(input)) {
                System.out.println("谢谢使用，再见！");
                break;
            }
            
            try {
                InetAddress address = InetAddress.getByName(input);
                System.out.println("主机名: " + address.getHostName());
                System.out.println("IP地址: " + address.getHostAddress());
                
                boolean reachable = address.isReachable(3000);
                System.out.println("主机是否可达: " + (reachable ? "是" : "否"));
                
            } catch (UnknownHostException e) {
                System.out.println("无法解析主机名: " + input);
            } catch (Exception e) {
                System.out.println("发生错误: " + e.getMessage());
            }
            
            System.out.println("\n请输入主机名（输入'exit'退出）:");
        }
        
        scanner.close();
    }
}
```

### 场景二：网站可用性检查工具

以下是一个简单的工具，可以检查多个网站的可用性：

```java
import java.net.InetAddress;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.*;

public class WebsiteAvailabilityChecker {
    public static void main(String[] args) {
        // 要检查的网站列表
        List<String> websites = new ArrayList<>();
        websites.add("www.google.com");
        websites.add("www.github.com");
        websites.add("www.example.com");
        websites.add("www.nonexistentwebsite123456789.com");
        
        // 创建线程池
        ExecutorService executor = Executors.newFixedThreadPool(websites.size());
        List<Future<CheckResult>> results = new ArrayList<>();
        
        // 提交任务
        for (String website : websites) {
            results.add(executor.submit(new WebsiteChecker(website)));
        }
        
        // 获取结果
        for (Future<CheckResult> future : results) {
            try {
                CheckResult result = future.get(10, TimeUnit.SECONDS);
                System.out.println(result);
            } catch (Exception e) {
                System.out.println("检查过程中出错: " + e.getMessage());
            }
        }
        
        executor.shutdown();
    }
    
    static class WebsiteChecker implements Callable<CheckResult> {
        private String website;
        
        public WebsiteChecker(String website) {
            this.website = website;
        }
        
        @Override
        public CheckResult call() {
            try {
                long startTime = System.currentTimeMillis();
                InetAddress address = InetAddress.getByName(website);
                String ip = address.getHostAddress();
                boolean reachable = address.isReachable(5000);
                long responseTime = System.currentTimeMillis() - startTime;
                
                return new CheckResult(website, ip, reachable, responseTime);
            } catch (UnknownHostException e) {
                return new CheckResult(website, "无法解析", false, 0);
            } catch (IOException e) {
                return new CheckResult(website, "IO错误", false, 0);
            }
        }
    }
    
    static class CheckResult {
        String website;
        String ip;
        boolean reachable;
        long responseTime;
        
        public CheckResult(String website, String ip, boolean reachable, long responseTime) {
            this.website = website;
            this.ip = ip;
            this.reachable = reachable;
            this.responseTime = responseTime;
        }
        
        @Override
        public String toString() {
            return "网站: " + website + 
                   "\nIP地址: " + ip + 
                   "\n可达性: " + (reachable ? "可达" : "不可达") +
                   (reachable ? "\n响应时间: " + responseTime + "ms" : "") +
                   "\n----------------------------";
        }
    }
}
```

## InetAddress类的特点和注意事项

### 缓存机制

`InetAddress`类维护着一个内部缓存，用于存储已解析的主机名和IP地址映射。这可以提高性能，但也意味着当DNS记录更改时，Java可能不会立即反映这些更改。Java提供了两个系统属性来控制这种缓存行为：

- `networkaddress.cache.ttl`：成功查找的缓存时间（秒）
- `networkaddress.cache.negative.ttl`：失败查找的缓存时间（秒）

### 同步阻塞性质

`InetAddress`类的方法（如`getByName`和`isReachable`）是同步阻塞的，它们会阻塞当前线程直到操作完成。在处理多个主机时，应考虑使用多线程或异步方法来提高效率。

:::caution
在网络状况不佳或DNS服务器响应慢的情况下，`getByName`方法可能会花费较长时间才能返回或抛出异常。因此，在生产环境中使用此方法时，应设置适当的超时机制或使用多线程处理。
:::

### IPv4与IPv6

`InetAddress`类既可以处理IPv4地址，也可以处理IPv6地址。默认情况下，Java会优先使用IPv4。如果需要优先使用IPv6，可以设置系统属性：`java.net.preferIPv6Addresses=true`。

## 总结

`InetAddress`类是Java网络编程中处理IP地址和主机名的基础类。通过本文，我们了解了：

1. 如何获取`InetAddress`实例
2. 主要方法及其用法
3. 实际应用场景示例
4. 使用时的注意事项

掌握`InetAddress`类对于理解和开发Java网络应用至关重要，它是构建更复杂网络功能（如套接字通信）的基础。

## 练习

为了巩固所学知识，建议尝试以下练习：

1. 编写一个程序，获取本地主机的所有网络接口和IP地址。
2. 创建一个简单的DNS查询工具，支持正向查询（主机名→IP）和反向查询（IP→主机名）。
3. 扩展网站可用性检查工具，加入HTTP状态码检测功能。
4. 探索`InetAddress`类的缓存机制，编写测试程序验证缓存的影响。

## 附加资源

- [Java官方文档 - InetAddress类](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/net/InetAddress.html)
- [RFC 1034 - 域名概念和设施](https://tools.ietf.org/html/rfc1034)
- [RFC 1035 - 域名实现和规范](https://tools.ietf.org/html/rfc1035)

通过学习`InetAddress`类，你已经迈出了Java网络编程的第一步。接下来，可以进一步学习套接字编程、HTTP客户端等更高级的网络编程主题。