---
title: Java 数组复制
description: 了解在Java中复制数组的多种方法，包括浅拷贝和深拷贝的概念，以及各种数组复制技术的性能比较和适用场景。
---

# Java 数组复制

在Java编程中，数组复制是一项基础而重要的操作。当我们需要备份数组数据、扩展数组大小或者需要在不改变原始数组的情况下操作数据时，数组复制就显得尤为重要。本文将详细介绍Java中各种数组复制的方法，帮助你选择最适合的技术。

## 为什么需要复制数组？

在实际应用中，我们可能出于以下原因需要复制数组：

1. 保留原始数据，创建可操作的副本
2. 扩展或缩减数组大小
3. 合并多个数组
4. 在方法之间安全地传递数组（避免引用问题）

## 基本概念：浅拷贝与深拷贝

在了解具体的复制方法前，我们需要理解两个关键概念：

### 浅拷贝 (Shallow Copy)

浅拷贝创建一个新数组，并复制原数组中的元素引用。对于基本数据类型（如int、float等），这意味着复制值本身；但对于对象类型，只复制对象的引用，而不是对象本身。

:::caution
使用浅拷贝时，如果原数组包含对象元素，那么修改复制后数组中的对象会影响原数组中的对象，反之亦然，因为它们引用的是相同的对象。
:::

### 深拷贝 (Deep Copy)

深拷贝不仅创建一个新数组，还创建数组中每个对象元素的新副本。这样，原数组和复制后的数组完全独立，修改一个不会影响另一个。

## Java 中的数组复制方法

### 1. 使用循环手动复制

最基本的方法是通过循环遍历原数组并将每个元素赋值给新数组。

```java
public class ArrayCopyExample1 {
    public static void main(String[] args) {
        int[] originalArray = {1, 2, 3, 4, 5};
        int[] newArray = new int[originalArray.length];
        
        // 手动复制数组元素
        for (int i = 0; i < originalArray.length; i++) {
            newArray[i] = originalArray[i];
        }
        
        // 打印两个数组
        System.out.println("原始数组: " + Arrays.toString(originalArray));
        System.out.println("复制后数组: " + Arrays.toString(newArray));
    }
}
```

输出：
```
原始数组: [1, 2, 3, 4, 5]
复制后数组: [1, 2, 3, 4, 5]
```

这种方法简单直观，适用于所有类型的数组，但不是最高效的方式。

### 2. 使用System.arraycopy()方法

Java提供了`System.arraycopy()`方法，它是一个本地方法，效率很高。

```java
public class ArrayCopyExample2 {
    public static void main(String[] args) {
        int[] originalArray = {1, 2, 3, 4, 5};
        int[] newArray = new int[originalArray.length];
        
        // 使用System.arraycopy()
        System.arraycopy(originalArray, 0, newArray, 0, originalArray.length);
        
        System.out.println("原始数组: " + Arrays.toString(originalArray));
        System.out.println("复制后数组: " + Arrays.toString(newArray));
    }
}
```

输出：
```
原始数组: [1, 2, 3, 4, 5]
复制后数组: [1, 2, 3, 4, 5]
```

`System.arraycopy()`方法参数说明：
- 源数组
- 源数组中的起始位置
- 目标数组
- 目标数组中的起始位置
- 要复制的元素数量

这种方法效率高，是复制大型数组的推荐方式。

### 3. 使用Arrays.copyOf()方法

Java的`Arrays`类提供了`copyOf()`方法，它在内部调用`System.arraycopy()`，但使用更简便。

```java
import java.util.Arrays;

public class ArrayCopyExample3 {
    public static void main(String[] args) {
        int[] originalArray = {1, 2, 3, 4, 5};
        
        // 使用Arrays.copyOf()复制数组
        int[] newArray = Arrays.copyOf(originalArray, originalArray.length);
        
        // 创建一个更大的数组并复制
        int[] largerArray = Arrays.copyOf(originalArray, 10);
        
        System.out.println("原始数组: " + Arrays.toString(originalArray));
        System.out.println("复制后数组: " + Arrays.toString(newArray));
        System.out.println("扩展后数组: " + Arrays.toString(largerArray));
    }
}
```

输出：
```
原始数组: [1, 2, 3, 4, 5]
复制后数组: [1, 2, 3, 4, 5]
扩展后数组: [1, 2, 3, 4, 5, 0, 0, 0, 0, 0]
```

`Arrays.copyOf()`方法不仅可以精确复制数组，还可以通过指定更大的长度来扩展数组，不足的部分会用默认值填充（如整数为0）。

### 4. 使用Arrays.copyOfRange()方法

如果只需要复制数组的一部分，可以使用`Arrays.copyOfRange()`方法。

```java
import java.util.Arrays;

public class ArrayCopyExample4 {
    public static void main(String[] args) {
        int[] originalArray = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
        
        // 复制索引2到5的元素（包括2，不包括6）
        int[] subArray = Arrays.copyOfRange(originalArray, 2, 6);
        
        System.out.println("原始数组: " + Arrays.toString(originalArray));
        System.out.println("部分复制的数组: " + Arrays.toString(subArray));
    }
}
```

输出：
```
原始数组: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
部分复制的数组: [3, 4, 5, 6]
```

这个方法适合需要提取子数组的场景。

### 5. 使用clone()方法

所有数组都继承了`Object`类的`clone()`方法，可以用来创建数组的副本。

```java
public class ArrayCopyExample5 {
    public static void main(String[] args) {
        int[] originalArray = {1, 2, 3, 4, 5};
        
        // 使用clone()方法
        int[] clonedArray = originalArray.clone();
        
        System.out.println("原始数组: " + Arrays.toString(originalArray));
        System.out.println("克隆的数组: " + Arrays.toString(clonedArray));
    }
}
```

输出：
```
原始数组: [1, 2, 3, 4, 5]
克隆的数组: [1, 2, 3, 4, 5]
```

`clone()`方法创建的是浅拷贝，对于基本类型数组足够了，但对于对象数组需要小心使用。

### 6. 使用数组流操作（Java 8+）

在Java 8及更高版本中，可以使用流操作来复制数组：

```java
import java.util.Arrays;

public class ArrayCopyExample6 {
    public static void main(String[] args) {
        int[] originalArray = {1, 2, 3, 4, 5};
        
        // 使用Stream API复制数组
        int[] streamCopiedArray = Arrays.stream(originalArray).toArray();
        
        System.out.println("原始数组: " + Arrays.toString(originalArray));
        System.out.println("通过流复制的数组: " + Arrays.toString(streamCopiedArray));
    }
}
```

输出：
```
原始数组: [1, 2, 3, 4, 5]
通过流复制的数组: [1, 2, 3, 4, 5]
```

对于对象数组，可以使用：

```java
String[] originalArray = {"Java", "Python", "C++"};
String[] streamCopiedArray = Arrays.stream(originalArray).toArray(String[]::new);
```

## 复制对象数组的注意事项

当复制对象数组时，上述所有方法都只创建浅拷贝。以下示例说明了这一点：

```java
public class DeepCopyExample {
    static class Student {
        String name;
        
        Student(String name) {
            this.name = name;
        }
        
        @Override
        public String toString() {
            return name;
        }
    }
    
    public static void main(String[] args) {
        Student[] originalArray = new Student[3];
        originalArray[0] = new Student("Alice");
        originalArray[1] = new Student("Bob");
        originalArray[2] = new Student("Charlie");
        
        // 使用clone()方法创建浅拷贝
        Student[] shallowCopy = originalArray.clone();
        
        // 修改复制数组中第一个学生的名字
        shallowCopy[0].name = "Alicia";
        
        System.out.println("原始数组第一个学生: " + originalArray[0]);
        System.out.println("复制数组第一个学生: " + shallowCopy[0]);
    }
}
```

输出：
```
原始数组第一个学生: Alicia
复制数组第一个学生: Alicia
```

:::warning
注意！修改复制数组中的对象也影响了原始数组中的对象，因为它们引用的是同一个对象。
:::

### 创建对象数组的深拷贝

要创建对象数组的真正深拷贝，需要逐个复制每个对象：

```java
public class DeepCopyExample2 {
    static class Student implements Cloneable {
        String name;
        
        Student(String name) {
            this.name = name;
        }
        
        @Override
        public Student clone() {
            try {
                return (Student) super.clone();
            } catch (CloneNotSupportedException e) {
                return new Student(this.name);
            }
        }
        
        @Override
        public String toString() {
            return name;
        }
    }
    
    public static void main(String[] args) {
        Student[] originalArray = new Student[3];
        originalArray[0] = new Student("Alice");
        originalArray[1] = new Student("Bob");
        originalArray[2] = new Student("Charlie");
        
        // 创建深拷贝
        Student[] deepCopy = new Student[originalArray.length];
        for (int i = 0; i < originalArray.length; i++) {
            deepCopy[i] = originalArray[i].clone();
        }
        
        // 修改复制数组中第一个学生的名字
        deepCopy[0].name = "Alicia";
        
        System.out.println("原始数组第一个学生: " + originalArray[0]);
        System.out.println("复制数组第一个学生: " + deepCopy[0]);
    }
}
```

输出：
```
原始数组第一个学生: Alice
复制数组第一个学生: Alicia
```

这次修改复制数组中的对象不会影响原始数组，因为我们创建了真正的深拷贝。

## 数组复制方法的性能比较

不同的复制方法有不同的性能特征：

```mermaid
graph LR
    A[性能从高到低] --> B[System.arraycopy]
    B --> C[Arrays.copyOf]
    C --> D[clone]
    D --> E[Arrays.stream]
    E --> F[手动循环]
```

对于大多数应用场景：
- 如果需要高性能，使用`System.arraycopy()`或`Arrays.copyOf()`
- 如果需要代码简洁性，使用`clone()`或`Arrays.copyOf()`
- 如果需要部分复制，使用`Arrays.copyOfRange()`
- 如果需要在复制过程中进行转换，使用流操作

## 实际应用案例

### 案例一：动态扩展数组大小

```java
import java.util.Arrays;

public class DynamicArrayExample {
    public static void main(String[] args) {
        int[] array = {1, 2, 3};
        System.out.println("原始数组: " + Arrays.toString(array));
        
        // 添加新元素前需要扩展数组
        array = addElement(array, 4);
        System.out.println("添加元素后: " + Arrays.toString(array));
        
        array = addElement(array, 5);
        System.out.println("再次添加元素后: " + Arrays.toString(array));
    }
    
    // 扩展数组并添加新元素
    public static int[] addElement(int[] originalArray, int element) {
        int[] newArray = Arrays.copyOf(originalArray, originalArray.length + 1);
        newArray[originalArray.length] = element;
        return newArray;
    }
}
```

输出：
```
原始数组: [1, 2, 3]
添加元素后: [1, 2, 3, 4]
再次添加元素后: [1, 2, 3, 4, 5]
```

### 案例二：合并两个数组

```java
import java.util.Arrays;

public class MergeArraysExample {
    public static void main(String[] args) {
        int[] array1 = {1, 2, 3};
        int[] array2 = {4, 5, 6};
        
        int[] mergedArray = mergeArrays(array1, array2);
        
        System.out.println("数组1: " + Arrays.toString(array1));
        System.out.println("数组2: " + Arrays.toString(array2));
        System.out.println("合并后的数组: " + Arrays.toString(mergedArray));
    }
    
    // 合并两个数组
    public static int[] mergeArrays(int[] array1, int[] array2) {
        int[] result = new int[array1.length + array2.length];
        
        // 复制第一个数组到结果数组
        System.arraycopy(array1, 0, result, 0, array1.length);
        
        // 复制第二个数组到结果数组
        System.arraycopy(array2, 0, result, array1.length, array2.length);
        
        return result;
    }
}
```

输出：
```
数组1: [1, 2, 3]
数组2: [4, 5, 6]
合并后的数组: [1, 2, 3, 4, 5, 6]
```

## 总结

本文详细介绍了Java中复制数组的多种方法：

1. 使用循环手动复制 - 简单但效率较低
2. 使用`System.arraycopy()` - 高效的本地方法
3. 使用`Arrays.copyOf()` - 便捷且高效
4. 使用`Arrays.copyOfRange()` - 适合部分复制
5. 使用`clone()` - 简洁的一行代码解决方案
6. 使用流操作 - 提供了额外的功能性

我们还讨论了浅拷贝与深拷贝的区别，以及如何处理对象数组的复制。在实际应用中，选择合适的方法取决于特定的需求和性能考虑。

:::tip
记住一点：对于基本类型数组，所有方法都能正常工作；但对于对象数组，默认只会创建浅拷贝，如果需要深拷贝，需要手动复制每个对象。
:::

## 练习

1. 创建一个包含5个整数的数组，然后使用三种不同的方法复制这个数组。
2. 编写一个方法，接受一个字符串数组并返回它的深拷贝。
3. 实现一个动态数组类，当数组满时自动将其大小增加一倍。
4. 编写代码复制一个二维整型数组。
5. 创建两个对象数组，一个使用浅拷贝，一个使用深拷贝，然后证明它们的行为差异。

## 进一步学习资源

- Java API文档中的[Arrays类](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/Arrays.html)
- Java中的[System类](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/System.html)，特别是`arraycopy`方法
- 学习Java中的[Object.clone()](https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Object.html#clone())方法和Cloneable接口

通过掌握这些数组复制技术，你将能够更有效地处理Java中的数组操作，并为更高级的数据结构实现打下坚实的基础。