---
title: Python 属性装饰器
description: 本文详细介绍Python中属性装饰器(@property)的概念、用法和实际应用场景，帮助初学者理解如何优雅地控制属性的访问。
---

# Python 属性装饰器

在Python面向对象编程中，属性装饰器(@property)是一个强大且优雅的工具，它允许我们像访问普通属性一样调用方法，同时还能对属性的获取、设置和删除过程进行精细控制。本文将详细介绍Python属性装饰器的概念及用法，帮助初学者更好地理解和应用这一特性。

## 什么是属性装饰器？

在传统的面向对象编程中，我们通常会设置私有属性，然后通过getter和setter方法来访问和修改这些属性：

```python
class Student:
    def __init__(self, name, score):
        self.__name = name
        self.__score = score
        
    def get_score(self):
        return self.__score
    
    def set_score(self, score):
        if 0 <= score <= 100:
            self.__score = score
        else:
            raise ValueError('分数必须在0到100之间')
```

使用这种方法时，我们需要这样操作：

```python
s = Student('张三', 85)
print(s.get_score())  # 输出: 85
s.set_score(95)
print(s.get_score())  # 输出: 95
```

虽然这种方式能够实现对属性的控制，但调用方法的语法与直接访问属性的语法不一致，显得有些繁琐。

Python的属性装饰器(@property)提供了一种更优雅的解决方案，使得我们可以像访问属性一样调用getter和setter方法。

## @property装饰器基本用法

`@property`装饰器可以将一个方法转换为属性，使其可以像属性一样被访问：

```python
class Student:
    def __init__(self, name, score):
        self.__name = name
        self.__score = score
    
    @property
    def score(self):
        return self.__score
    
    @score.setter
    def score(self, score):
        if 0 <= score <= 100:
            self.__score = score
        else:
            raise ValueError('分数必须在0到100之间')
```

有了这些装饰器，我们就可以这样使用：

```python
s = Student('张三', 85)
print(s.score)  # 输出: 85
s.score = 95   # 实际上调用了setter方法
print(s.score)  # 输出: 95

# 如果尝试设置无效的分数
try:
    s.score = 101  # 会引发ValueError
except ValueError as e:
    print(e)  # 输出: 分数必须在0到100之间
```

### 解析工作原理

1. `@property`装饰器将`score`方法转换为getter方法，使其在被访问时调用
2. `@score.setter`装饰器将同名方法定义为setter方法，在属性被赋值时调用
3. 通过这种方式，我们可以在属性被访问或修改时执行额外的逻辑

## 只读属性

如果只定义`@property`装饰器而不定义`@xxx.setter`装饰器，那么这个属性就变成了只读属性：

```python
class Circle:
    def __init__(self, radius):
        self.__radius = radius
    
    @property
    def radius(self):
        return self.__radius
    
    @property
    def area(self):
        return 3.14 * self.__radius * self.__radius
```

使用示例：

```python
c = Circle(5)
print(c.radius)  # 输出: 5
print(c.area)    # 输出: 78.5

# 尝试修改只读属性
try:
    c.area = 100  # 会引发AttributeError
except AttributeError as e:
    print("无法设置只读属性")  # 输出: 无法设置只读属性
```

:::tip
只读属性特别适合那些需要根据其他属性计算得出且不应被直接修改的属性。
:::

## 完整的属性装饰器

除了`@property`和`@xxx.setter`外，Python还提供了`@xxx.deleter`装饰器，用于定义当删除属性时的行为：

```python
class User:
    def __init__(self, name, email):
        self.__name = name
        self.__email = email
    
    @property
    def email(self):
        return self.__email
    
    @email.setter
    def email(self, new_email):
        if '@' in new_email:
            self.__email = new_email
        else:
            raise ValueError('无效的邮箱格式')
    
    @email.deleter
    def email(self):
        print(f"删除 {self.__name} 的邮箱信息")
        self.__email = None
```

使用示例：

```python
user = User('李四', 'lisi@example.com')
print(user.email)  # 输出: lisi@example.com

user.email = 'lisi.new@example.com'
print(user.email)  # 输出: lisi.new@example.com

# 尝试设置无效邮箱
try:
    user.email = 'invalid_email'  # 会引发ValueError
except ValueError as e:
    print(e)  # 输出: 无效的邮箱格式

# 删除邮箱属性
del user.email  # 输出: 删除 李四 的邮箱信息
print(user.email)  # 输出: None
```

## 属性装饰器的实际应用场景

### 1. 数据验证

属性装饰器最常见的应用场景之一是对属性值进行验证：

```python
class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age  # 这里会调用age的setter方法
    
    @property
    def age(self):
        return self.__age
    
    @age.setter
    def age(self, value):
        if not isinstance(value, int):
            raise TypeError('年龄必须是整数')
        if value < 0 or value > 120:
            raise ValueError('年龄必须在0到120之间')
        self.__age = value
```

### 2. 惰性计算

属性装饰器可以用于实现惰性计算，即只在需要时才进行计算：

```python
class DataProcessor:
    def __init__(self, data):
        self.data = data
        self.__processed_data = None
    
    @property
    def processed_data(self):
        if self.__processed_data is None:
            print("正在处理数据...")
            # 假设这是一个耗时的数据处理操作
            self.__processed_data = [x * 2 for x in self.data]
        return self.__processed_data
```

使用示例：

```python
processor = DataProcessor([1, 2, 3, 4, 5])
# 第一次访问时会执行处理
print(processor.processed_data)  # 输出: 正在处理数据... [2, 4, 6, 8, 10]
# 再次访问时直接返回缓存结果
print(processor.processed_data)  # 输出: [2, 4, 6, 8, 10]
```

### 3. 状态管理与通知

属性装饰器可以用于管理对象的状态变化并发送通知：

```python
class Account:
    def __init__(self, owner, initial_balance=0):
        self.owner = owner
        self.__balance = initial_balance
    
    @property
    def balance(self):
        return self.__balance
    
    @balance.setter
    def balance(self, value):
        if value < 0:
            raise ValueError('余额不能为负')
        
        old_balance = self.__balance
        self.__balance = value
        
        # 状态变化通知
        if value > old_balance:
            print(f"账户存入: ¥{value - old_balance}")
        elif value < old_balance:
            print(f"账户支出: ¥{old_balance - value}")
```

使用示例：

```python
acct = Account('王五', 1000)
print(f"当前余额: ¥{acct.balance}")  # 输出: 当前余额: ¥1000

acct.balance = 1500  # 输出: 账户存入: ¥500
print(f"当前余额: ¥{acct.balance}")  # 输出: 当前余额: ¥1500

acct.balance = 800  # 输出: 账户支出: ¥700
print(f"当前余额: ¥{acct.balance}")  # 输出: 当前余额: ¥800
```

## 属性装饰器与描述符

属性装饰器实际上是Python描述符协议的一种简便实现方式。描述符是Python的一个强大特性，允许我们自定义属性的访问方式。`@property`装饰器是对描述符的一种简化使用。

下面是一个使用描述符而不是属性装饰器的等效实现：

```python
class ScoreProperty:
    def __get__(self, obj, objtype=None):
        return obj._score
    
    def __set__(self, obj, value):
        if 0 <= value <= 100:
            obj._score = value
        else:
            raise ValueError('分数必须在0到100之间')
    
    def __delete__(self, obj):
        del obj._score

class Student:
    score = ScoreProperty()
    
    def __init__(self, name, score):
        self.name = name
        self.score = score  # 这会调用ScoreProperty的__set__方法
```

使用属性装饰器时，Python会在背后创建一个类似的描述符对象，这是Python语言内部实现的细节。

:::note
描述符是更底层的机制，提供更大的灵活性，但对于大多数常见用例，属性装饰器提供了更简洁优雅的语法。
:::

## 总结

Python的属性装饰器是一个强大的特性，它可以：

1. **简化语法**：让使用者可以以访问属性的方式调用方法
2. **封装控制**：在不改变API的情况下，调整属性的内部实现
3. **数据验证**：在设置属性时进行验证，确保数据的有效性
4. **计算属性**：创建只读的计算属性，使其像普通属性一样被访问
5. **状态管理**：管理对象的状态变化，并在属性变化时执行附加操作

属性装饰器的使用使得Python的面向对象编程更加优雅和灵活，是Python程序员应该熟练掌握的工具之一。

## 练习与扩展

1. 创建一个`Temperature`类，包含摄氏度(`celsius`)和华氏度(`fahrenheit`)两个属性，使得修改其中一个属性时，另一个属性会自动更新。

2. 为`Rectangle`类创建属性，其中包含`width`和`height`属性，并添加`area`和`perimeter`只读属性。

3. 尝试创建一个`Password`类，使用属性装饰器来实现密码的加密存储和验证。

4. 研究如何结合`@property`和类继承，探索当子类重写父类的属性时应该注意的事项。

:::tip
练习是掌握属性装饰器的最佳方式！尝试结合实际问题来应用这一概念，将会加深你的理解。
:::

通过掌握Python的属性装饰器，你将能够编写出更加优雅、可维护的面向对象代码，同时保持对对象状态的有效控制。