---
title: Python 柯里化
description: 探索Python函数式编程中的柯里化技术，了解如何将多参数函数转换为一系列单参数函数的调用链，以及其在实际编程中的应用场景。
---

# Python 柯里化

## 柯里化的概念

柯里化（Currying）是函数式编程中的一个重要概念，它以数学家哈斯凯尔·柯里（Haskell Curry）的名字命名。柯里化是指将一个接受多个参数的函数转换成一系列使用一个参数的函数的技术。

简单来说，如果我们有一个函数 `f(a, b, c)`，通过柯里化，它会变成 `f(a)(b)(c)`，即一个参数的函数链。这种转换让我们能够部分地应用一个函数，得到一个新的函数，这在函数式编程中非常有用。

## 为什么需要柯里化？

柯里化有以下几个主要优势：

1. **函数的部分应用**：允许你固定一部分参数，创建一个新的函数
2. **提高代码复用性**：能够基于已有函数轻松创建特定的函数变体
3. **提高函数的组合能力**：便于函数组合和管道操作
4. **延迟执行**：可以先设置参数，稍后再执行完整的函数

## Python 中的柯里化基础

在Python中实现柯里化并不像在Haskell等函数式编程语言中那样原生支持，但我们可以通过闭包和高阶函数来实现它。

### 基本示例

让我们从一个简单的加法函数开始：

```python
def add(x, y):
    return x + y

# 普通调用
result = add(5, 3)  # 结果为 8
```

现在，让我们将它柯里化：

```python
def add_curry(x):
    def inner(y):
        return x + y
    return inner

# 柯里化调用
add_5 = add_curry(5)
result = add_5(3)  # 结果为 8

# 也可以直接链式调用
result = add_curry(5)(3)  # 结果为 8
```

在这个例子中，`add_curry` 是 `add` 的柯里化版本。当我们调用 `add_curry(5)` 时，它返回一个新函数 `inner`，这个函数记住了 `x=5`，然后等待接收第二个参数 `y`。

## 自动柯里化函数

手动为每个函数编写柯里化版本会很繁琐，我们可以创建一个通用的柯里化装饰器：

```python
def curry(func):
    def curried(*args, **kwargs):
        if len(args) + len(kwargs) >= func.__code__.co_argcount:
            return func(*args, **kwargs)
        return lambda *more_args, **more_kwargs: curried(*(args + more_args), **{**kwargs, **more_kwargs})
    return curried

# 使用装饰器
@curry
def add_three(x, y, z):
    return x + y + z

# 现在可以进行各种柯里化调用
result1 = add_three(1)(2)(3)      # 6
result2 = add_three(1, 2)(3)      # 6
result3 = add_three(1)(2, 3)      # 6
```

这个装饰器可以将任何接受固定数量参数的函数转换为柯里化版本。它会检查是否提供了足够的参数；如果是，则执行原始函数；如果否，则返回一个等待更多参数的新函数。

:::tip
柯里化装饰器适用于有固定数量参数的函数。对于接受可变数量参数的函数（如使用 `*args` 的函数），需要特殊处理。
:::

## 柯里化的实际应用

### 1. 创建特定函数

柯里化最常见的用途是从通用函数创建特定的函数版本：

```python
@curry
def multiply(x, y):
    return x * y

# 创建特定的倍增函数
double = multiply(2)
triple = multiply(3)

print(double(5))  # 输出: 10
print(triple(5))  # 输出: 15
```

这种方式可以很容易地创建一系列相关但特定的函数。

### 2. 函数组合和链式调用

柯里化使函数组合变得更加简单：

```python
@curry
def pipe(data, *funcs):
    result = data
    for func in funcs:
        result = func(result)
    return result

@curry
def add(x, y):
    return x + y

@curry
def multiply(x, y):
    return x * y

# 创建特定函数
add_5 = add(5)
multiply_by_3 = multiply(3)

# 组合函数
result = pipe(10, add_5, multiply_by_3)  # ((10 + 5) * 3) = 45
print(result)  # 输出: 45
```

### 3. 数据处理和过滤

柯里化在数据处理中也很有用：

```python
@curry
def filter_by_attribute(attr_name, value, items):
    return [item for item in items if getattr(item, attr_name) == value]

# 模拟数据类
class Person:
    def __init__(self, name, age, city):
        self.name = name
        self.age = age
        self.city = city

# 创建一些数据
people = [
    Person("Alice", 30, "New York"),
    Person("Bob", 25, "Boston"),
    Person("Charlie", 30, "New York"),
    Person("Diana", 35, "Boston")
]

# 创建特定的过滤函数
filter_by_age_30 = filter_by_attribute("age", 30)
filter_by_city_boston = filter_by_attribute("city", "Boston")

# 应用过滤器
people_age_30 = filter_by_age_30(people)  # 找出所有30岁的人
people_in_boston = filter_by_city_boston(people)  # 找出所有在波士顿的人

# 打印结果
print([person.name for person in people_age_30])  # 输出: ['Alice', 'Charlie']
print([person.name for person in people_in_boston])  # 输出: ['Bob', 'Diana']
```

## 柯里化与偏函数（Partial Functions）

Python 标准库 `functools` 模块中的 `partial` 函数提供了类似柯里化的功能，但两者有一些区别：

```python
from functools import partial

def add(x, y, z):
    return x + y + z

# 使用偏函数
add_5_and_10 = partial(add, 5, 10)
result = add_5_and_10(3)  # 5 + 10 + 3 = 18
print(result)  # 输出: 18
```

区别在于：
- 偏函数一次绑定多个参数，并返回等待剩余参数的新函数
- 柯里化每次只接受一个参数，并返回嵌套的一元函数链

:::note
在实际应用中，偏函数通常比自定义的柯里化实现更加高效和方便。除非你特别需要一个参数一个参数地应用的函数形式，否则考虑使用 `partial`。
:::

## 柯里化的局限性

虽然柯里化在函数式编程中很有价值，但在Python中也有一些局限性：

1. **语法冗长**：Python的语法使柯里化调用看起来不如其他语言（如Haskell）那么优雅
2. **性能开销**：嵌套函数调用会带来一定的性能损失
3. **可读性问题**：过度使用柯里化可能会让代码变得难以理解
4. **不适合可变参数函数**：处理 `*args` 和 `**kwargs` 的柯里化比较复杂

## 实现更复杂的柯里化装饰器

如果需要支持关键字参数和可变参数，可以实现更复杂的柯里化装饰器：

```python
import inspect

def advanced_curry(func):
    sig = inspect.signature(func)
    
    def curried(*args, **kwargs):
        bound_args = sig.bind_partial(*args, **kwargs)
        if len(bound_args.arguments) == len(sig.parameters):
            return func(*args, **kwargs)
        
        def inner(*more_args, **more_kwargs):
            return curried(*(args + more_args), **{**kwargs, **more_kwargs})
        return inner
    
    return curried
```

这个版本使用了 `inspect` 模块来检查函数签名，可以更准确地处理参数绑定。

## 总结

柯里化是函数式编程中的强大技术，它允许你：

- 将多参数函数转换为单参数函数链
- 创建特定的函数变体
- 促进函数的组合和重用
- 实现参数的延迟绑定

尽管Python不像Haskell等语言那样原生支持柯里化，但通过闭包和高阶函数，我们可以实现类似的功能。在Python中，根据具体情况，偏函数（`functools.partial`）往往是一个更实用的选择。

## 练习题

1. 编写一个柯里化版本的 `divide(x, y)` 函数，并创建一个 `divide_by_2` 的特化版本。

2. 使用柯里化实现一个 `compose` 函数，该函数接受多个函数作为参数，并返回一个将这些函数从右到左组合的新函数。

3. 创建一个柯里化的 `map_filter` 函数，它先接受一个映射函数，然后接受一个过滤条件，最后接受一个列表，并返回经过映射和过滤的结果。

4. 比较使用柯里化和使用偏函数来解决同一个问题的代码，分析两种方法的优缺点。

## 进一步学习资源

- **函数式编程书籍**：《Functional Python Programming》by Steven Lott
- **Python文档**：[functools模块](https://docs.python.org/3/library/functools.html)
- **函数式编程库**：探索toolz、fn.py等Python函数式编程库