---
title: PHP 代理模式
description: 了解PHP中的代理模式，掌握如何通过代理对象控制对真实对象的访问，并学习其实际应用场景。
---

# PHP 代理模式

代理模式（Proxy Pattern）是一种结构型设计模式，它允许你提供一个代理对象来控制对另一个对象的访问。代理对象可以在客户端和真实对象之间充当中间人，从而在不改变客户端代码的情况下添加额外的功能或限制访问。

## 什么是代理模式？

代理模式的核心思想是通过一个代理类来控制对真实对象的访问。代理类通常与真实对象实现相同的接口，因此客户端无法区分它们。代理对象可以在调用真实对象的方法之前或之后执行一些额外的操作，例如：

- **延迟初始化**：在需要时才创建真实对象。
- **访问控制**：限制对真实对象的访问。
- **日志记录**：记录对真实对象的访问。
- **缓存**：缓存真实对象的结果，避免重复计算。

## 代理模式的实现

让我们通过一个简单的例子来理解代理模式的实现。假设我们有一个 `RealSubject` 类，它执行一些耗时的操作。我们可以创建一个 `Proxy` 类来控制对 `RealSubject` 的访问。

### 代码示例

```php
<?php

// 定义接口
interface Subject {
    public function request(): void;
}

// 真实对象
class RealSubject implements Subject {
    public function request(): void {
        echo "RealSubject: Handling request.\n";
    }
}

// 代理对象
class Proxy implements Subject {
    private $realSubject;

    public function __construct(RealSubject $realSubject) {
        $this->realSubject = $realSubject;
    }

    public function request(): void {
        if ($this->checkAccess()) {
            $this->realSubject->request();
            $this->logAccess();
        }
    }

    private function checkAccess(): bool {
        echo "Proxy: Checking access prior to firing a real request.\n";
        return true;
    }

    private function logAccess(): void {
        echo "Proxy: Logging the time of request.\n";
    }
}

// 客户端代码
function clientCode(Subject $subject) {
    $subject->request();
}

echo "Client: Executing the client code with a real subject:\n";
$realSubject = new RealSubject();
clientCode($realSubject);

echo "\n";

echo "Client: Executing the same client code with a proxy:\n";
$proxy = new Proxy($realSubject);
clientCode($proxy);
```

### 输出

```
Client: Executing the client code with a real subject:
RealSubject: Handling request.

Client: Executing the same client code with a proxy:
Proxy: Checking access prior to firing a real request.
RealSubject: Handling request.
Proxy: Logging the time of request.
```

在这个例子中，`Proxy` 类在调用 `RealSubject` 的 `request` 方法之前检查访问权限，并在调用之后记录访问时间。

## 代理模式的实际应用场景

代理模式在实际开发中有许多应用场景，以下是一些常见的例子：

1. **虚拟代理**：用于延迟初始化一个昂贵的对象，直到真正需要时才创建它。
2. **保护代理**：用于控制对敏感对象的访问，只有满足特定条件的客户端才能访问。
3. **远程代理**：用于在不同的地址空间中代表一个对象，例如远程服务调用。
4. **缓存代理**：用于缓存昂贵操作的结果，以避免重复计算。

### 虚拟代理示例

假设我们有一个 `Image` 类，它加载一个非常大的图片文件。我们可以使用虚拟代理来延迟加载图片，直到真正需要显示它时才加载。

```php
<?php

interface Image {
    public function display(): void;
}

class RealImage implements Image {
    private $filename;

    public function __construct(string $filename) {
        $this->filename = $filename;
        $this->loadFromDisk();
    }

    private function loadFromDisk(): void {
        echo "Loading image: {$this->filename}\n";
    }

    public function display(): void {
        echo "Displaying image: {$this->filename}\n";
    }
}

class ProxyImage implements Image {
    private $realImage;
    private $filename;

    public function __construct(string $filename) {
        $this->filename = $filename;
    }

    public function display(): void {
        if ($this->realImage === null) {
            $this->realImage = new RealImage($this->filename);
        }
        $this->realImage->display();
    }
}

// 客户端代码
$image = new ProxyImage("large_image.jpg");

// 图片尚未加载
$image->display(); // 图片加载并显示
```

### 输出

```
Loading image: large_image.jpg
Displaying image: large_image.jpg
```

在这个例子中，`ProxyImage` 类延迟了 `RealImage` 的加载，直到调用 `display` 方法时才真正加载图片。

## 总结

代理模式是一种强大的设计模式，它允许你通过代理对象控制对真实对象的访问。代理模式可以用于延迟初始化、访问控制、日志记录、缓存等多种场景。通过使用代理模式，你可以在不修改客户端代码的情况下添加额外的功能或限制访问。

:::tip
**提示**：代理模式与装饰器模式有些相似，但它们的目的不同。装饰器模式用于动态地添加功能，而代理模式用于控制访问。
:::

## 附加资源与练习

- **练习**：尝试实现一个保护代理，限制只有特定用户才能访问某个敏感对象。
- **进一步阅读**：了解其他结构型设计模式，如适配器模式、装饰器模式等。

通过掌握代理模式，你将能够更好地控制对象的访问，并在需要时添加额外的功能。希望这篇教程对你理解PHP中的代理模式有所帮助！