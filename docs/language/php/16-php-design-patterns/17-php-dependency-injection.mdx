---
title: PHP 依赖注入
description: 了解PHP中的依赖注入概念，掌握如何通过依赖注入实现松耦合的代码设计，并通过实际案例展示其应用场景。
---

# PHP 依赖注入

依赖注入（Dependency Injection，简称DI）是一种设计模式，用于实现**控制反转**（Inversion of Control，IoC）。它通过将对象的依赖关系从代码内部转移到外部容器中，从而实现松耦合的代码设计。依赖注入的核心思想是：**一个类不应该自己创建它所需要的依赖，而是应该由外部提供这些依赖**。

## 为什么需要依赖注入？

在传统的编程模式中，一个类可能会直接创建它所需要的依赖对象。例如：

```php
class UserService {
    private $userRepository;

    public function __construct() {
        $this->userRepository = new UserRepository();
    }
}
```

这种方式的问题在于，`UserService` 类与 `UserRepository` 类紧密耦合。如果 `UserRepository` 的实现发生变化，或者我们需要使用不同的实现（例如在测试中使用模拟对象），就必须修改 `UserService` 类的代码。

依赖注入通过将依赖对象的创建和注入过程分离，解决了这个问题。

## 依赖注入的三种方式

依赖注入通常有三种实现方式：

1. **构造函数注入**：通过构造函数传递依赖对象。
2. **Setter注入**：通过Setter方法传递依赖对象。
3. **接口注入**：通过接口方法传递依赖对象。

### 1. 构造函数注入

构造函数注入是最常用的依赖注入方式。它通过类的构造函数将依赖对象传递进来。

```php
class UserService {
    private $userRepository;

    public function __construct(UserRepository $userRepository) {
        $this->userRepository = $userRepository;
    }
}
```

在这个例子中，`UserService` 类不再自己创建 `UserRepository` 对象，而是通过构造函数接收它。这使得 `UserService` 类与 `UserRepository` 类解耦。

### 2. Setter注入

Setter注入通过Setter方法传递依赖对象。

```php
class UserService {
    private $userRepository;

    public function setUserRepository(UserRepository $userRepository) {
        $this->userRepository = $userRepository;
    }
}
```

这种方式允许在对象创建后动态地注入依赖对象。

### 3. 接口注入

接口注入通过接口方法传递依赖对象。这种方式较少使用，但在某些框架中可能会遇到。

```php
interface UserRepositoryAware {
    public function setUserRepository(UserRepository $userRepository);
}

class UserService implements UserRepositoryAware {
    private $userRepository;

    public function setUserRepository(UserRepository $userRepository) {
        $this->userRepository = $userRepository;
    }
}
```

## 依赖注入的实际应用

让我们通过一个实际案例来展示依赖注入的应用场景。

### 案例：用户注册服务

假设我们有一个用户注册服务 `UserRegistrationService`，它依赖于 `UserRepository` 和 `EmailService`。我们可以通过依赖注入来实现这个服务。

```php
class UserRegistrationService {
    private $userRepository;
    private $emailService;

    public function __construct(UserRepository $userRepository, EmailService $emailService) {
        $this->userRepository = $userRepository;
        $this->emailService = $emailService;
    }

    public function registerUser($userData) {
        $user = $this->userRepository->save($userData);
        $this->emailService->sendWelcomeEmail($user);
        return $user;
    }
}
```

在这个例子中，`UserRegistrationService` 类通过构造函数接收 `UserRepository` 和 `EmailService` 的实例。这使得 `UserRegistrationService` 类与具体的 `UserRepository` 和 `EmailService` 实现解耦。

### 依赖注入容器

在实际应用中，我们通常会使用**依赖注入容器**（Dependency Injection Container）来管理对象的创建和依赖注入。依赖注入容器是一个负责创建对象并自动注入依赖的工具。

```php
$container = new Container();

$container->set('UserRepository', function() {
    return new UserRepository();
});

$container->set('EmailService', function() {
    return new EmailService();
});

$container->set('UserRegistrationService', function($container) {
    return new UserRegistrationService(
        $container->get('UserRepository'),
        $container->get('EmailService')
    );
});

$userRegistrationService = $container->get('UserRegistrationService');
$userRegistrationService->registerUser($userData);
```

在这个例子中，我们使用了一个简单的依赖注入容器来管理 `UserRegistrationService` 及其依赖对象的创建。

## 总结

依赖注入是一种强大的设计模式，它通过将对象的依赖关系从代码内部转移到外部容器中，实现了松耦合的代码设计。通过依赖注入，我们可以更容易地测试、维护和扩展代码。

### 附加资源

- [PHP-DI](https://php-di.org/)：一个流行的PHP依赖注入容器。
- [Symfony DependencyInjection Component](https://symfony.com/doc/current/components/dependency_injection.html)：Symfony框架的依赖注入组件。

### 练习

1. 尝试在你的项目中实现依赖注入，并使用依赖注入容器管理对象的创建。
2. 编写一个测试用例，使用模拟对象替换依赖对象，测试你的服务类。

:::tip
依赖注入是构建可维护和可扩展应用程序的关键技术之一。掌握它，你将能够编写更加灵活和可测试的代码。
:::