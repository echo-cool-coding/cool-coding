---
title: C# 泛型约束
description: 了解 C# 中的泛型约束，掌握如何通过约束限制泛型类型参数的行为，提升代码的安全性和灵活性。
---

## 介绍

在 C# 中，泛型（Generics）是一种强大的特性，允许你编写可以处理多种数据类型的代码，而无需为每种类型编写单独的实现。然而，有时你可能希望对泛型类型参数进行限制，以确保它们满足某些条件。这就是**泛型约束**的用武之地。

泛型约束允许你指定泛型类型参数必须满足的条件，例如必须是某个类的子类、实现某个接口、具有无参构造函数等。通过使用泛型约束，你可以编写更安全、更灵活的代码。

## 泛型约束的类型

C# 提供了多种泛型约束类型，以下是常见的几种：

1. **类型约束**：指定泛型类型参数必须是某个类的子类或实现某个接口。
2. **引用类型约束**：指定泛型类型参数必须是引用类型。
3. **值类型约束**：指定泛型类型参数必须是值类型。
4. **构造函数约束**：指定泛型类型参数必须具有无参构造函数。
5. **组合约束**：可以组合多个约束条件。

接下来，我们将逐一介绍这些约束类型，并通过代码示例展示它们的用法。

### 1. 类型约束

类型约束是最常见的泛型约束类型之一。它允许你指定泛型类型参数必须是某个类的子类或实现某个接口。

```csharp
public class Animal { }
public class Dog : Animal { }

public class Zoo<T> where T : Animal
{
    public void Add(T animal)
    {
        Console.WriteLine($"Added {animal.GetType().Name} to the zoo.");
    }
}

Zoo<Dog> dogZoo = new Zoo<Dog>();
dogZoo.Add(new Dog()); // 输出: Added Dog to the zoo.
```

在上面的示例中，`Zoo<T>` 类使用了类型约束 `where T : Animal`，这意味着 `T` 必须是 `Animal` 类或其子类。因此，`Zoo<Dog>` 是合法的，因为 `Dog` 是 `Animal` 的子类。

### 2. 引用类型约束

引用类型约束允许你指定泛型类型参数必须是引用类型。使用 `class` 关键字来实现这一约束。

```csharp
public class Box<T> where T : class
{
    public T Content { get; set; }
}

Box<string> stringBox = new Box<string>();
stringBox.Content = "Hello, World!";
Console.WriteLine(stringBox.Content); // 输出: Hello, World!
```

在这个示例中，`Box<T>` 类使用了引用类型约束 `where T : class`，这意味着 `T` 必须是引用类型。因此，`Box<string>` 是合法的，因为 `string` 是引用类型。

### 3. 值类型约束

值类型约束允许你指定泛型类型参数必须是值类型。使用 `struct` 关键字来实现这一约束。

```csharp
public class Container<T> where T : struct
{
    public T Value { get; set; }
}

Container<int> intContainer = new Container<int>();
intContainer.Value = 42;
Console.WriteLine(intContainer.Value); // 输出: 42
```

在这个示例中，`Container<T>` 类使用了值类型约束 `where T : struct`，这意味着 `T` 必须是值类型。因此，`Container<int>` 是合法的，因为 `int` 是值类型。

### 4. 构造函数约束

构造函数约束允许你指定泛型类型参数必须具有无参构造函数。使用 `new()` 关键字来实现这一约束。

```csharp
public class Factory<T> where T : new()
{
    public T CreateInstance()
    {
        return new T();
    }
}

public class Product
{
    public Product()
    {
        Console.WriteLine("Product created.");
    }
}

Factory<Product> productFactory = new Factory<Product>();
Product product = productFactory.CreateInstance(); // 输出: Product created.
```

在这个示例中，`Factory<T>` 类使用了构造函数约束 `where T : new()`，这意味着 `T` 必须具有无参构造函数。因此，`Factory<Product>` 是合法的，因为 `Product` 类具有无参构造函数。

### 5. 组合约束

你可以组合多个约束条件，以进一步限制泛型类型参数。

```csharp
public class Repository<T> where T : class, IEntity, new()
{
    public void Add(T entity)
    {
        Console.WriteLine($"Added {entity.GetType().Name} to the repository.");
    }
}

public interface IEntity { }
public class Customer : IEntity
{
    public Customer()
    {
        Console.WriteLine("Customer created.");
    }
}

Repository<Customer> customerRepository = new Repository<Customer>();
customerRepository.Add(new Customer()); // 输出: Customer created. Added Customer to the repository.
```

在这个示例中，`Repository<T>` 类使用了组合约束 `where T : class, IEntity, new()`，这意味着 `T` 必须是引用类型、实现 `IEntity` 接口，并且具有无参构造函数。因此，`Repository<Customer>` 是合法的，因为 `Customer` 满足所有这些条件。

## 实际应用场景

泛型约束在实际开发中有广泛的应用。以下是一些常见的应用场景：

1. **数据访问层**：在数据访问层中，你可能希望泛型仓储类只能处理实现了特定接口的实体类。
2. **工厂模式**：在工厂模式中，你可能希望泛型工厂类只能创建具有无参构造函数的对象。
3. **集合类**：在自定义集合类中，你可能希望集合中的元素必须是某个类的子类或实现某个接口。

## 总结

泛型约束是 C# 中一个强大的特性，它允许你限制泛型类型参数的行为，从而编写更安全、更灵活的代码。通过使用类型约束、引用类型约束、值类型约束、构造函数约束以及组合约束，你可以确保泛型类或方法只处理符合特定条件的类型。

## 附加资源与练习

- **练习**：尝试创建一个泛型类 `Cache<T>`，要求 `T` 必须是引用类型，并且实现 `IDisposable` 接口。
- **进一步学习**：查阅 [C# 官方文档](https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/generics/constraints-on-type-parameters) 以了解更多关于泛型约束的详细信息。

:::tip
泛型约束不仅可以提高代码的安全性，还可以使代码更具可读性和可维护性。在实际开发中，合理使用泛型约束可以帮助你编写更高质量的代码。
:::