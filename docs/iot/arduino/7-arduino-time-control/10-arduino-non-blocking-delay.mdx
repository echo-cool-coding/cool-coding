---
title: Arduino 无阻塞延时
description: 学习如何在Arduino中实现无阻塞延时，避免使用`delay()`函数导致的程序停滞问题。
---

# Arduino 无阻塞延时

在Arduino编程中，`delay()`函数是一个常用的工具，用于在程序中暂停执行一段时间。然而，`delay()`函数会阻塞整个程序的执行，这意味着在延时期间，Arduino无法执行其他任务。这对于需要同时处理多个任务的应用场景来说，是一个严重的限制。

本文将介绍如何通过无阻塞延时技术，避免使用`delay()`函数，从而让Arduino能够在延时期间继续执行其他任务。

## 什么是无阻塞延时？

无阻塞延时是一种编程技术，允许程序在等待某个时间间隔的同时，继续执行其他任务。与`delay()`函数不同，无阻塞延时不会暂停整个程序的执行，而是通过检查时间是否已经到达预定的延时时间来实现延时效果。

## 实现无阻塞延时的基本方法

实现无阻塞延时的基本方法是使用`millis()`函数。`millis()`函数返回自Arduino启动以来的毫秒数。通过记录开始时间，并在循环中检查当前时间与开始时间的差值，我们可以实现无阻塞延时。

### 代码示例

以下是一个简单的无阻塞延时示例，LED灯每隔1秒切换一次状态：

```cpp
unsigned long previousMillis = 0;  // 用于存储上一次切换LED状态的时间
const long interval = 1000;        // 切换间隔时间（1秒）
bool ledState = LOW;               // LED的初始状态

void setup() {
  pinMode(LED_BUILTIN, OUTPUT);   // 设置内置LED引脚为输出模式
}

void loop() {
  unsigned long currentMillis = millis();  // 获取当前时间

  // 检查是否到达切换时间
  if (currentMillis - previousMillis >= interval) {
    previousMillis = currentMillis;  // 更新上一次切换时间

    // 切换LED状态
    ledState = !ledState;
    digitalWrite(LED_BUILTIN, ledState);
  }

  // 在这里可以添加其他任务
}
```

### 代码解释

1. **`previousMillis`**：用于存储上一次切换LED状态的时间。
2. **`interval`**：定义LED状态切换的时间间隔（1秒）。
3. **`ledState`**：存储LED的当前状态（`LOW`或`HIGH`）。
4. **`currentMillis`**：获取当前时间。
5. **`if (currentMillis - previousMillis >= interval)`**：检查是否到达切换时间。如果到达，则更新`previousMillis`并切换LED状态。

## 实际应用场景

无阻塞延时在许多实际应用中非常有用，尤其是在需要同时处理多个任务的场景中。以下是一些常见的应用场景：

1. **多任务处理**：在控制多个传感器或执行器的同时，保持程序的响应性。
2. **用户界面**：在等待用户输入的同时，保持界面的更新。
3. **通信协议**：在等待数据接收的同时，处理其他任务。

### 示例：多任务处理

假设我们需要同时控制两个LED灯，一个每隔1秒切换一次，另一个每隔500毫秒切换一次。使用无阻塞延时，我们可以轻松实现这一目标：

```cpp
unsigned long previousMillis1 = 0;
unsigned long previousMillis2 = 0;
const long interval1 = 1000;
const long interval2 = 500;
bool ledState1 = LOW;
bool ledState2 = LOW;

void setup() {
  pinMode(LED_BUILTIN, OUTPUT);
  pinMode(2, OUTPUT);
}

void loop() {
  unsigned long currentMillis = millis();

  // 控制第一个LED
  if (currentMillis - previousMillis1 >= interval1) {
    previousMillis1 = currentMillis;
    ledState1 = !ledState1;
    digitalWrite(LED_BUILTIN, ledState1);
  }

  // 控制第二个LED
  if (currentMillis - previousMillis2 >= interval2) {
    previousMillis2 = currentMillis;
    ledState2 = !ledState2;
    digitalWrite(2, ledState2);
  }

  // 在这里可以添加其他任务
}
```

## 总结

无阻塞延时是一种强大的技术，允许Arduino在等待某个时间间隔的同时，继续执行其他任务。通过使用`millis()`函数，我们可以避免使用`delay()`函数导致的程序停滞问题，从而实现更高效的多任务处理。

## 附加资源与练习

- **练习1**：尝试修改上述代码，使两个LED灯以不同的频率闪烁，并添加第三个LED灯，使其每隔2秒切换一次状态。
- **练习2**：在无阻塞延时的基础上，添加一个按钮，按下按钮时立即切换某个LED灯的状态。

通过实践这些练习，你将更好地理解无阻塞延时的概念，并能够在实际项目中灵活应用。

:::tip
**提示**：在编写无阻塞延时代码时，务必确保时间计算的准确性，避免因溢出或计算错误导致的问题。
:::