---
title: 51单片机串行中断
description: 本文详细介绍了51单片机中的串行中断机制，包括其工作原理、配置方法、代码示例以及实际应用场景，适合初学者学习。
---

# 51单片机串行中断

## 介绍

在51单片机中，串行中断是一种重要的中断机制，用于处理串行通信中的数据接收和发送。通过串行中断，单片机可以在接收到数据或发送完数据时自动触发中断服务程序，从而高效地处理串行通信任务。

串行中断通常与串行通信接口（如UART）配合使用，适用于需要实时处理串行数据的场景，例如与PC通信、无线模块通信等。

## 串行中断的工作原理

51单片机的串行中断由串行控制寄存器（SCON）和中断使能寄存器（IE）共同控制。当串行通信接口接收到数据或发送完数据时，会触发串行中断标志位（RI或TI），从而引发中断。

- **RI（Receive Interrupt）**：接收中断标志位。当单片机接收到一个完整的数据字节时，RI会被置1，触发接收中断。
- **TI（Transmit Interrupt）**：发送中断标志位。当单片机发送完一个数据字节时，TI会被置1，触发发送中断。

:::note
串行中断的中断向量地址为 `0x0023`，即当串行中断发生时，程序会跳转到该地址执行中断服务程序。
:::

## 配置串行中断

要使用串行中断，首先需要配置相关的寄存器。以下是配置步骤：

1. **设置串行通信模式**：通过配置SCON寄存器，选择串行通信的工作模式（如模式1，8位UART）。
2. **使能串行中断**：通过设置IE寄存器中的ES位（串行中断使能位）为1，使能串行中断。
3. **设置波特率**：通过配置定时器1（或定时器2）来生成所需的波特率。
4. **编写中断服务程序**：在中断服务程序中处理接收或发送的数据。

以下是一个简单的配置示例：

```c
#include <reg51.h>

void UART_Init() {
    SCON = 0x50;  // 设置串行模式1，8位UART，允许接收
    TMOD = 0x20;  // 设置定时器1为模式2（8位自动重装）
    TH1 = 0xFD;   // 设置波特率为9600（假设晶振为11.0592MHz）
    TL1 = 0xFD;
    TR1 = 1;      // 启动定时器1
    ES = 1;       // 使能串行中断
    EA = 1;       // 使能全局中断
}

void UART_ISR() interrupt 4 {
    if (RI == 1) {
        RI = 0;  // 清除接收中断标志
        // 处理接收到的数据
        unsigned char receivedData = SBUF;
        // 例如，将接收到的数据发送回去
        SBUF = receivedData;
    }
    if (TI == 1) {
        TI = 0;  // 清除发送中断标志
        // 处理发送完成后的操作
    }
}

void main() {
    UART_Init();
    while (1) {
        // 主循环
    }
}
```

:::tip
在实际应用中，建议在中断服务程序中尽量减少耗时操作，以确保中断响应的实时性。
:::

## 实际应用场景

串行中断广泛应用于需要实时处理串行数据的场景。以下是一个实际案例：

### 案例：通过串口与PC通信

假设我们需要通过串口与PC进行通信，单片机接收PC发送的数据并将其回显。以下是实现步骤：

1. **初始化串口**：配置波特率、串行模式，并启用串行中断。
2. **编写中断服务程序**：在中断服务程序中，读取接收到的数据并将其发送回去。
3. **主程序**：在主程序中保持空循环，等待中断触发。

```c
#include <reg51.h>

void UART_Init() {
    SCON = 0x50;  // 设置串行模式1，8位UART，允许接收
    TMOD = 0x20;  // 设置定时器1为模式2（8位自动重装）
    TH1 = 0xFD;   // 设置波特率为9600（假设晶振为11.0592MHz）
    TL1 = 0xFD;
    TR1 = 1;      // 启动定时器1
    ES = 1;       // 使能串行中断
    EA = 1;       // 使能全局中断
}

void UART_ISR() interrupt 4 {
    if (RI == 1) {
        RI = 0;  // 清除接收中断标志
        unsigned char receivedData = SBUF;
        SBUF = receivedData;  // 将接收到的数据发送回去
    }
    if (TI == 1) {
        TI = 0;  // 清除发送中断标志
    }
}

void main() {
    UART_Init();
    while (1) {
        // 主循环
    }
}
```

:::caution
在实际应用中，如果接收和发送的数据量较大，建议使用缓冲区来存储数据，以避免数据丢失。
:::

## 总结

51单片机的串行中断是一种高效处理串行通信数据的机制。通过合理配置寄存器和编写中断服务程序，可以实现实时数据的接收和发送。本文介绍了串行中断的工作原理、配置方法以及一个实际应用案例，帮助初学者理解和掌握这一重要概念。

## 附加资源与练习

- **练习1**：修改上述代码，使单片机在接收到特定字符（如`'A'`）时点亮LED。
- **练习2**：尝试使用定时器2来生成波特率，并比较与定时器1的差异。
- **资源**：查阅51单片机的数据手册，了解更多关于串行中断的细节和高级配置选项。

通过以上内容的学习和实践，您将能够熟练使用51单片机的串行中断功能，为后续的嵌入式开发打下坚实的基础。