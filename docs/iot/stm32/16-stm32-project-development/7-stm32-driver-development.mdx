---
title: STM32 驱动开发
description: 本教程将详细介绍STM32驱动开发的基础知识，帮助初学者理解如何为STM32微控制器编写驱动程序，并通过实际案例展示其应用。
---

# STM32 驱动开发

## 介绍

STM32驱动开发是指为STM32微控制器编写软件代码，以控制其硬件外设（如GPIO、UART、I2C、SPI等）。驱动程序是嵌入式系统的核心部分，它直接与硬件交互，并为上层应用程序提供接口。通过驱动程序，开发者可以轻松地控制硬件资源，而无需深入了解硬件的底层细节。

在本教程中，我们将从基础开始，逐步讲解如何为STM32编写驱动程序，并通过实际案例展示其应用。

## 1. 驱动开发基础

### 1.1 什么是驱动程序？

驱动程序是一段软件代码，用于控制硬件设备。它充当硬件与操作系统或应用程序之间的桥梁，使得应用程序可以通过简单的API调用与硬件交互。

### 1.2 STM32的外设

STM32微控制器集成了多种外设，包括：

- **GPIO**：通用输入输出引脚，用于控制LED、按钮等简单设备。
- **UART**：通用异步收发传输器，用于串行通信。
- **I2C**：两线式串行总线，用于连接低速设备。
- **SPI**：串行外设接口，用于高速数据传输。

每个外设都有其特定的寄存器，驱动程序通过配置这些寄存器来控制外设的行为。

## 2. GPIO驱动开发

### 2.1 GPIO简介

GPIO（General Purpose Input/Output）是STM32中最基本的外设之一。每个GPIO引脚都可以配置为输入或输出，并且可以设置为推挽、开漏等模式。

### 2.2 GPIO驱动示例

以下是一个简单的GPIO驱动示例，用于控制LED的亮灭。

```c
#include "stm32f4xx.h"  // 包含STM32F4系列的头文件

void GPIO_Init(void) {
    // 启用GPIOD时钟
    RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOD, ENABLE);

    // 配置GPIOD的引脚12为输出模式
    GPIO_InitTypeDef GPIO_InitStruct;
    GPIO_InitStruct.GPIO_Pin = GPIO_Pin_12;
    GPIO_InitStruct.GPIO_Mode = GPIO_Mode_OUT;
    GPIO_InitStruct.GPIO_OType = GPIO_OType_PP;
    GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz;
    GPIO_InitStruct.GPIO_PuPd = GPIO_PuPd_NOPULL;
    GPIO_Init(GPIOD, &GPIO_InitStruct);
}

void LED_On(void) {
    // 设置GPIOD的引脚12为高电平，点亮LED
    GPIO_SetBits(GPIOD, GPIO_Pin_12);
}

void LED_Off(void) {
    // 设置GPIOD的引脚12为低电平，熄灭LED
    GPIO_ResetBits(GPIOD, GPIO_Pin_12);
}

int main(void) {
    GPIO_Init();
    while (1) {
        LED_On();
        Delay(500);  // 延时500ms
        LED_Off();
        Delay(500);  // 延时500ms
    }
}
```

:::note
**注意**：在实际项目中，`Delay`函数需要根据系统时钟频率进行实现。
:::

### 2.3 GPIO驱动的工作流程

1. **启用GPIO时钟**：在使用GPIO之前，必须启用其时钟。
2. **配置GPIO引脚**：设置引脚的模式、输出类型、速度和上下拉电阻。
3. **控制GPIO引脚**：通过设置或清除引脚的电平来控制外设。

## 3. UART驱动开发

### 3.1 UART简介

UART（Universal Asynchronous Receiver/Transmitter）是一种常见的串行通信协议，用于在两个设备之间传输数据。STM32的UART外设支持多种配置，如波特率、数据位、停止位和校验位。

### 3.2 UART驱动示例

以下是一个简单的UART驱动示例，用于发送和接收数据。

```c
#include "stm32f4xx.h"

void UART_Init(void) {
    // 启用USART2时钟
    RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART2, ENABLE);
    RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOA, ENABLE);

    // 配置GPIOA的引脚2和3为USART2的TX和RX
    GPIO_InitTypeDef GPIO_InitStruct;
    GPIO_InitStruct.GPIO_Pin = GPIO_Pin_2 | GPIO_Pin_3;
    GPIO_InitStruct.GPIO_Mode = GPIO_Mode_AF;
    GPIO_InitStruct.GPIO_OType = GPIO_OType_PP;
    GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz;
    GPIO_InitStruct.GPIO_PuPd = GPIO_PuPd_UP;
    GPIO_Init(GPIOA, &GPIO_InitStruct);

    GPIO_PinAFConfig(GPIOA, GPIO_PinSource2, GPIO_AF_USART2);
    GPIO_PinAFConfig(GPIOA, GPIO_PinSource3, GPIO_AF_USART2);

    // 配置USART2
    USART_InitTypeDef USART_InitStruct;
    USART_InitStruct.USART_BaudRate = 9600;
    USART_InitStruct.USART_WordLength = USART_WordLength_8b;
    USART_InitStruct.USART_StopBits = USART_StopBits_1;
    USART_InitStruct.USART_Parity = USART_Parity_No;
    USART_InitStruct.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
    USART_InitStruct.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
    USART_Init(USART2, &USART_InitStruct);

    USART_Cmd(USART2, ENABLE);
}

void UART_SendChar(char ch) {
    while (USART_GetFlagStatus(USART2, USART_FLAG_TXE) == RESET);
    USART_SendData(USART2, ch);
}

char UART_ReceiveChar(void) {
    while (USART_GetFlagStatus(USART2, USART_FLAG_RXNE) == RESET);
    return USART_ReceiveData(USART2);
}

int main(void) {
    UART_Init();
    while (1) {
        char receivedChar = UART_ReceiveChar();
        UART_SendChar(receivedChar);  // 回显接收到的字符
    }
}
```

:::tip
**提示**：在实际应用中，UART通信通常用于与传感器、模块或其他微控制器进行数据交换。
:::

### 3.3 UART驱动的工作流程

1. **启用UART和GPIO时钟**：在使用UART之前，必须启用其时钟。
2. **配置GPIO引脚**：将GPIO引脚配置为UART的TX和RX功能。
3. **配置UART参数**：设置波特率、数据位、停止位和校验位等参数。
4. **发送和接收数据**：通过UART发送和接收数据。

## 4. 实际案例：温度传感器驱动开发

### 4.1 案例介绍

假设我们有一个基于I2C接口的温度传感器（如LM75），我们需要编写驱动程序来读取温度数据。

### 4.2 温度传感器驱动示例

以下是一个简单的温度传感器驱动示例。

```c
#include "stm32f4xx.h"

void I2C_Init(void) {
    // 启用I2C1时钟
    RCC_APB1PeriphClockCmd(RCC_APB1Periph_I2C1, ENABLE);
    RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOB, ENABLE);

    // 配置GPIOB的引脚6和7为I2C1的SCL和SDA
    GPIO_InitTypeDef GPIO_InitStruct;
    GPIO_InitStruct.GPIO_Pin = GPIO_Pin_6 | GPIO_Pin_7;
    GPIO_InitStruct.GPIO_Mode = GPIO_Mode_AF;
    GPIO_InitStruct.GPIO_OType = GPIO_OType_OD;
    GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz;
    GPIO_InitStruct.GPIO_PuPd = GPIO_PuPd_UP;
    GPIO_Init(GPIOB, &GPIO_InitStruct);

    GPIO_PinAFConfig(GPIOB, GPIO_PinSource6, GPIO_AF_I2C1);
    GPIO_PinAFConfig(GPIOB, GPIO_PinSource7, GPIO_AF_I2C1);

    // 配置I2C1
    I2C_InitTypeDef I2C_InitStruct;
    I2C_InitStruct.I2C_ClockSpeed = 100000;
    I2C_InitStruct.I2C_Mode = I2C_Mode_I2C;
    I2C_InitStruct.I2C_DutyCycle = I2C_DutyCycle_2;
    I2C_InitStruct.I2C_OwnAddress1 = 0;
    I2C_InitStruct.I2C_Ack = I2C_Ack_Enable;
    I2C_InitStruct.I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;
    I2C_Init(I2C1, &I2C_InitStruct);

    I2C_Cmd(I2C1, ENABLE);
}

uint16_t LM75_ReadTemperature(void) {
    uint8_t data[2];
    I2C_GenerateSTART(I2C1, ENABLE);
    while (!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_MODE_SELECT));

    I2C_Send7bitAddress(I2C1, 0x48 << 1, I2C_Direction_Receiver);
    while (!I2C_CheckEvent(I2C1, I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED));

    data[0] = I2C_ReceiveData(I2C1);
    data[1] = I2C_ReceiveData(I2C1);

    I2C_GenerateSTOP(I2C1, ENABLE);

    return (data[0] << 8) | data[1];
}

int main(void) {
    I2C_Init();
    while (1) {
        uint16_t temperature = LM75_ReadTemperature();
        // 处理温度数据
    }
}
```

:::caution
**注意**：在实际项目中，I2C通信的时序和错误处理需要特别注意。
:::

### 4.3 温度传感器驱动的工作流程

1. **启用I2C和GPIO时钟**：在使用I2C之前，必须启用其时钟。
2. **配置GPIO引脚**：将GPIO引脚配置为I2C的SCL和SDA功能。
3. **配置I2C参数**：设置时钟速度、模式等参数。
4. **读取温度数据**：通过I2C接口读取温度传感器的数据。

## 5. 总结

在本教程中，我们介绍了STM32驱动开发的基础知识，并通过GPIO、UART和I2C的驱动示例展示了如何为STM32编写驱动程序。我们还通过一个实际案例展示了如何为温度传感器编写驱动程序。

驱动开发是嵌入式系统开发的核心技能之一，掌握它可以帮助你更好地控制硬件资源，并开发出功能强大的嵌入式应用。

## 6. 附加资源与练习

- **练习1**：尝试为STM32的SPI接口编写驱动程序，并连接一个SPI设备（如SD卡或LCD显示屏）。
- **练习2**：扩展UART驱动，实现一个简单的命令行接口（CLI），用于控制STM32的外设。
- **资源**：参考STM32的官方参考手册和数据手册，了解更多关于外设寄存器的详细信息。

:::warning
**警告**：在编写驱动程序时，务必仔细阅读硬件文档，并确保代码的正确性和稳定性。
:::