---
title: STM32 外设概述
description: 本文详细介绍了STM32微控制器的外设功能，包括GPIO、UART、I2C、SPI、ADC等，帮助初学者理解STM32硬件架构中的外设模块及其应用。
---

## 介绍

STM32微控制器是STMicroelectronics公司推出的一系列高性能、低功耗的32位ARM Cortex-M内核微控制器。它们广泛应用于嵌入式系统中，得益于其丰富的外设资源。外设（Peripheral）是STM32微控制器中用于与外部设备或环境交互的功能模块。通过外设，STM32可以实现数据采集、通信、控制等多种功能。

本文将逐步介绍STM32的主要外设模块，并通过实际案例展示它们的应用场景。

## STM32 外设模块概述

STM32的外设模块可以分为以下几类：

1. **通用输入输出（GPIO）**
2. **串行通信接口（UART、I2C、SPI）**
3. **模拟数字转换器（ADC）**
4. **定时器（TIM）**
5. **直接内存访问（DMA）**
6. **中断控制器（NVIC）**

接下来，我们将逐一介绍这些外设模块。

---

### 1. 通用输入输出（GPIO）

GPIO是STM32中最基础的外设模块，用于控制微控制器的引脚状态。每个GPIO引脚可以配置为输入或输出模式，并支持多种功能，如推挽输出、开漏输出、上拉/下拉电阻等。

#### 代码示例：配置GPIO引脚为输出模式

```c
#include "stm32f4xx.h"

void GPIO_Config(void) {
    // 启用GPIOA时钟
    RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOA, ENABLE);

    // 配置PA5为输出模式
    GPIO_InitTypeDef GPIO_InitStruct;
    GPIO_InitStruct.GPIO_Pin = GPIO_Pin_5;
    GPIO_InitStruct.GPIO_Mode = GPIO_Mode_OUT;
    GPIO_InitStruct.GPIO_OType = GPIO_OType_PP;
    GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz;
    GPIO_InitStruct.GPIO_PuPd = GPIO_PuPd_NOPULL;
    GPIO_Init(GPIOA, &GPIO_InitStruct);
}

int main(void) {
    GPIO_Config();
    while (1) {
        GPIO_SetBits(GPIOA, GPIO_Pin_5); // 设置PA5为高电平
        Delay(1000); // 延时
        GPIO_ResetBits(GPIOA, GPIO_Pin_5); // 设置PA5为低电平
        Delay(1000); // 延时
    }
}
```

:::tip
在实际应用中，GPIO常用于控制LED、按钮、继电器等简单设备。
:::

---

### 2. 串行通信接口（UART、I2C、SPI）

串行通信接口是STM32与外部设备进行数据交换的重要方式。常见的串行通信接口包括UART、I2C和SPI。

#### UART（通用异步收发传输器）

UART是一种异步串行通信协议，常用于与PC、传感器等设备通信。

#### 代码示例：配置UART通信

```c
#include "stm32f4xx.h"

void UART_Config(void) {
    // 启用GPIOA和USART2时钟
    RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOA, ENABLE);
    RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART2, ENABLE);

    // 配置PA2为USART2_TX，PA3为USART2_RX
    GPIO_InitTypeDef GPIO_InitStruct;
    GPIO_InitStruct.GPIO_Pin = GPIO_Pin_2 | GPIO_Pin_3;
    GPIO_InitStruct.GPIO_Mode = GPIO_Mode_AF;
    GPIO_InitStruct.GPIO_OType = GPIO_OType_PP;
    GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz;
    GPIO_InitStruct.GPIO_PuPd = GPIO_PuPd_UP;
    GPIO_Init(GPIOA, &GPIO_InitStruct);

    GPIO_PinAFConfig(GPIOA, GPIO_PinSource2, GPIO_AF_USART2);
    GPIO_PinAFConfig(GPIOA, GPIO_PinSource3, GPIO_AF_USART2);

    // 配置USART2
    USART_InitTypeDef USART_InitStruct;
    USART_InitStruct.USART_BaudRate = 9600;
    USART_InitStruct.USART_WordLength = USART_WordLength_8b;
    USART_InitStruct.USART_StopBits = USART_StopBits_1;
    USART_InitStruct.USART_Parity = USART_Parity_No;
    USART_InitStruct.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
    USART_InitStruct.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
    USART_Init(USART2, &USART_InitStruct);

    USART_Cmd(USART2, ENABLE);
}

int main(void) {
    UART_Config();
    while (1) {
        USART_SendData(USART2, 'A'); // 发送字符'A'
        while (USART_GetFlagStatus(USART2, USART_FLAG_TXE) == RESET);
    }
}
```

:::note
UART常用于调试信息的输出，或与GPS模块、蓝牙模块等设备通信。
:::

---

### 3. 模拟数字转换器（ADC）

ADC用于将模拟信号（如电压）转换为数字信号，以便微控制器进行处理。

#### 代码示例：配置ADC采样

```c
#include "stm32f4xx.h"

void ADC_Config(void) {
    // 启用GPIOA和ADC1时钟
    RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOA, ENABLE);
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1, ENABLE);

    // 配置PA1为模拟输入
    GPIO_InitTypeDef GPIO_InitStruct;
    GPIO_InitStruct.GPIO_Pin = GPIO_Pin_1;
    GPIO_InitStruct.GPIO_Mode = GPIO_Mode_AN;
    GPIO_InitStruct.GPIO_PuPd = GPIO_PuPd_NOPULL;
    GPIO_Init(GPIOA, &GPIO_InitStruct);

    // 配置ADC1
    ADC_InitTypeDef ADC_InitStruct;
    ADC_InitStruct.ADC_Resolution = ADC_Resolution_12b;
    ADC_InitStruct.ADC_ScanConvMode = DISABLE;
    ADC_InitStruct.ADC_ContinuousConvMode = ENABLE;
    ADC_InitStruct.ADC_ExternalTrigConv = ADC_ExternalTrigConv_T1_CC1;
    ADC_InitStruct.ADC_DataAlign = ADC_DataAlign_Right;
    ADC_InitStruct.ADC_NbrOfConversion = 1;
    ADC_Init(ADC1, &ADC_InitStruct);

    ADC_Cmd(ADC1, ENABLE);
}

int main(void) {
    ADC_Config();
    while (1) {
        ADC_SoftwareStartConv(ADC1); // 启动ADC转换
        while (ADC_GetFlagStatus(ADC1, ADC_FLAG_EOC) == RESET);
        uint16_t adc_value = ADC_GetConversionValue(ADC1); // 获取ADC值
    }
}
```

:::caution
ADC的精度和采样速率会影响测量结果的准确性，需根据实际需求选择合适的配置。
:::

---

### 4. 定时器（TIM）

定时器是STM32中用于计时、PWM生成、输入捕获等功能的重要外设。

#### 代码示例：配置定时器生成PWM信号

```c
#include "stm32f4xx.h"

void TIM_Config(void) {
    // 启用GPIOA和TIM2时钟
    RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOA, ENABLE);
    RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2, ENABLE);

    // 配置PA0为TIM2_CH1
    GPIO_InitTypeDef GPIO_InitStruct;
    GPIO_InitStruct.GPIO_Pin = GPIO_Pin_0;
    GPIO_InitStruct.GPIO_Mode = GPIO_Mode_AF;
    GPIO_InitStruct.GPIO_OType = GPIO_OType_PP;
    GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz;
    GPIO_InitStruct.GPIO_PuPd = GPIO_PuPd_NOPULL;
    GPIO_Init(GPIOA, &GPIO_InitStruct);

    GPIO_PinAFConfig(GPIOA, GPIO_PinSource0, GPIO_AF_TIM2);

    // 配置TIM2
    TIM_TimeBaseInitTypeDef TIM_TimeBaseStruct;
    TIM_TimeBaseStruct.TIM_Period = 999; // 1kHz PWM
    TIM_TimeBaseStruct.TIM_Prescaler = 83; // 84MHz / 84 = 1MHz
    TIM_TimeBaseStruct.TIM_ClockDivision = 0;
    TIM_TimeBaseStruct.TIM_CounterMode = TIM_CounterMode_Up;
    TIM_TimeBaseInit(TIM2, &TIM_TimeBaseStruct);

    // 配置PWM模式
    TIM_OCInitTypeDef TIM_OCStruct;
    TIM_OCStruct.TIM_OCMode = TIM_OCMode_PWM1;
    TIM_OCStruct.TIM_OutputState = TIM_OutputState_Enable;
    TIM_OCStruct.TIM_Pulse = 500; // 50%占空比
    TIM_OCStruct.TIM_OCPolarity = TIM_OCPolarity_High;
    TIM_OC1Init(TIM2, &TIM_OCStruct);

    TIM_Cmd(TIM2, ENABLE);
}

int main(void) {
    TIM_Config();
    while (1) {
        // 主循环
    }
}
```

:::tip
PWM信号常用于控制电机速度、LED亮度等。
:::

---

### 5. 直接内存访问（DMA）

DMA是一种无需CPU干预的数据传输方式，可以显著提高数据传输效率。

#### 代码示例：配置DMA传输

```c
#include "stm32f4xx.h"

void DMA_Config(void) {
    // 启用DMA2时钟
    RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_DMA2, ENABLE);

    // 配置DMA2 Stream0
    DMA_InitTypeDef DMA_InitStruct;
    DMA_InitStruct.DMA_Channel = DMA_Channel_0;
    DMA_InitStruct.DMA_PeripheralBaseAddr = (uint32_t)&ADC1->DR;
    DMA_InitStruct.DMA_Memory0BaseAddr = (uint32_t)&adc_buffer;
    DMA_InitStruct.DMA_DIR = DMA_DIR_PeripheralToMemory;
    DMA_InitStruct.DMA_BufferSize = 100;
    DMA_InitStruct.DMA_PeripheralInc = DMA_PeripheralInc_Disable;
    DMA_InitStruct.DMA_MemoryInc = DMA_MemoryInc_Enable;
    DMA_InitStruct.DMA_PeripheralDataSize = DMA_PeripheralDataSize_HalfWord;
    DMA_InitStruct.DMA_MemoryDataSize = DMA_MemoryDataSize_HalfWord;
    DMA_InitStruct.DMA_Mode = DMA_Mode_Circular;
    DMA_InitStruct.DMA_Priority = DMA_Priority_High;
    DMA_InitStruct.DMA_FIFOMode = DMA_FIFOMode_Disable;
    DMA_InitStruct.DMA_FIFOThreshold = DMA_FIFOThreshold_HalfFull;
    DMA_InitStruct.DMA_MemoryBurst = DMA_MemoryBurst_Single;
    DMA_InitStruct.DMA_PeripheralBurst = DMA_PeripheralBurst_Single;
    DMA_Init(DMA2_Stream0, &DMA_InitStruct);

    DMA_Cmd(DMA2_Stream0, ENABLE);
}

int main(void) {
    DMA_Config();
    while (1) {
        // 主循环
    }
}
```

:::note
DMA常用于高速数据传输场景，如音频处理、图像采集等。
:::

---

### 6. 中断控制器（NVIC）

NVIC用于管理STM32的中断优先级和响应。

#### 代码示例：配置外部中断

```c
#include "stm32f4xx.h"

void EXTI_Config(void) {
    // 启用GPIOA和SYSCFG时钟
    RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOA, ENABLE);
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_SYSCFG, ENABLE);

    // 配置PA0为输入
    GPIO_InitTypeDef GPIO_InitStruct;
    GPIO_InitStruct.GPIO_Pin = GPIO_Pin_0;
    GPIO_InitStruct.GPIO_Mode = GPIO_Mode_IN;
    GPIO_InitStruct.GPIO_PuPd = GPIO_PuPd_NOPULL;
    GPIO_Init(GPIOA, &GPIO_InitStruct);

    // 配置EXTI0
    SYSCFG_EXTILineConfig(EXTI_PortSourceGPIOA, EXTI_PinSource0);
    EXTI_InitTypeDef EXTI_InitStruct;
    EXTI_InitStruct.EXTI_Line = EXTI_Line0;
    EXTI_InitStruct.EXTI_Mode = EXTI_Mode_Interrupt;
    EXTI_InitStruct.EXTI_Trigger = EXTI_Trigger_Rising;
    EXTI_InitStruct.EXTI_LineCmd = ENABLE;
    EXTI_Init(&EXTI_InitStruct);

    // 配置NVIC
    NVIC_InitTypeDef NVIC_InitStruct;
    NVIC_InitStruct.NVIC_IRQChannel = EXTI0_IRQn;
    NVIC_InitStruct.NVIC_IRQChannelPreemptionPriority = 0;
    NVIC_InitStruct.NVIC_IRQChannelSubPriority = 0;
    NVIC_InitStruct.NVIC_IRQChannelCmd = ENABLE;
    NVIC_Init(&NVIC_InitStruct);
}

void EXTI0_IRQHandler(void) {
    if (EXTI_GetITStatus(EXTI_Line0) != RESET) {
        // 处理中断
        EXTI_ClearITPendingBit(EXTI_Line0);
    }
}

int main(void) {
    EXTI_Config();
    while (1) {
        // 主循环
    }
}
```

:::caution
中断优先级配置不当可能导致系统响应异常，需谨慎设计。
:::

---

## 总结

STM32的外设模块为嵌入式系统开发提供了强大的支持。通过合理配置和使用这些外设，开发者可以实现复杂的功能需求。本文介绍了GPIO、UART、ADC、TIM、DMA和NVIC等主要外设模块，并通过代码示例展示了它们的应用场景。

---

## 附加资源与练习

1. **练习**：尝试使用STM32的I2C接口与EEPROM通信，并读取/写入数据。
2. **资源**：参考STM32官方参考手册和库函数指南，深入了解每个外设的详细配置选项。
3. **扩展阅读**：学习如何使用STM32CubeMX工具快速生成外设初始化代码。

:::tip
通过实践和阅读官方文档，您可以更深入地掌握STM32的外设功能。
:::