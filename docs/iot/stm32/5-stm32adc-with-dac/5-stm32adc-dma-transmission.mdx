---
title: STM32 ADC DMA传输
description: 本教程将详细介绍如何在STM32微控制器中使用DMA（直接内存访问）进行ADC（模数转换器）数据传输。适合初学者学习，包含代码示例和实际应用场景。
---

## 介绍

在STM32微控制器中，ADC（模数转换器）用于将模拟信号转换为数字信号。然而，当需要连续采样或高速采样时，频繁的中断处理可能会影响系统性能。为了解决这个问题，STM32提供了DMA（直接内存访问）功能，它可以在不占用CPU资源的情况下，直接将ADC转换结果传输到内存中。

DMA传输的核心思想是让外设（如ADC）直接与内存进行数据交换，而不需要CPU的干预。这种方式可以显著提高数据传输效率，特别是在需要处理大量数据时。

## STM32 ADC DMA传输的基本原理

在STM32中，ADC模块可以与DMA控制器配合使用，将转换结果直接传输到指定的内存区域。以下是DMA传输的基本步骤：

1. **配置ADC**：设置ADC的工作模式、采样时间、通道等参数。
2. **配置DMA**：设置DMA的源地址（ADC数据寄存器）、目标地址（内存缓冲区）、传输数据长度等。
3. **启动ADC和DMA**：启动ADC转换，并启用DMA传输。
4. **处理数据**：当DMA传输完成后，可以在内存缓冲区中访问ADC转换结果。

## 代码示例

以下是一个简单的代码示例，展示了如何在STM32中使用DMA进行ADC数据传输。

```c
#include "stm32f4xx.h"

#define ADC_BUFFER_SIZE 100

uint16_t adc_buffer[ADC_BUFFER_SIZE];

void ADC_DMA_Init(void) {
    // 启用ADC和DMA时钟
    RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_DMA2, ENABLE);
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1, ENABLE);

    // 配置ADC
    ADC_InitTypeDef ADC_InitStruct;
    ADC_InitStruct.ADC_Resolution = ADC_Resolution_12b;
    ADC_InitStruct.ADC_ScanConvMode = ENABLE;
    ADC_InitStruct.ADC_ContinuousConvMode = ENABLE;
    ADC_InitStruct.ADC_ExternalTrigConvEdge = ADC_ExternalTrigConvEdge_None;
    ADC_InitStruct.ADC_DataAlign = ADC_DataAlign_Right;
    ADC_InitStruct.ADC_NbrOfConversion = 1;
    ADC_Init(ADC1, &ADC_InitStruct);

    // 配置ADC通道
    ADC_RegularChannelConfig(ADC1, ADC_Channel_0, 1, ADC_SampleTime_3Cycles);

    // 配置DMA
    DMA_InitTypeDef DMA_InitStruct;
    DMA_InitStruct.DMA_Channel = DMA_Channel_0;
    DMA_InitStruct.DMA_PeripheralBaseAddr = (uint32_t)&ADC1->DR;
    DMA_InitStruct.DMA_Memory0BaseAddr = (uint32_t)adc_buffer;
    DMA_InitStruct.DMA_DIR = DMA_DIR_PeripheralToMemory;
    DMA_InitStruct.DMA_BufferSize = ADC_BUFFER_SIZE;
    DMA_InitStruct.DMA_PeripheralInc = DMA_PeripheralInc_Disable;
    DMA_InitStruct.DMA_MemoryInc = DMA_MemoryInc_Enable;
    DMA_InitStruct.DMA_PeripheralDataSize = DMA_PeripheralDataSize_HalfWord;
    DMA_InitStruct.DMA_MemoryDataSize = DMA_MemoryDataSize_HalfWord;
    DMA_InitStruct.DMA_Mode = DMA_Mode_Circular;
    DMA_InitStruct.DMA_Priority = DMA_Priority_High;
    DMA_InitStruct.DMA_FIFOMode = DMA_FIFOMode_Disable;
    DMA_InitStruct.DMA_FIFOThreshold = DMA_FIFOThreshold_HalfFull;
    DMA_InitStruct.DMA_MemoryBurst = DMA_MemoryBurst_Single;
    DMA_InitStruct.DMA_PeripheralBurst = DMA_PeripheralBurst_Single;
    DMA_Init(DMA2_Stream0, &DMA_InitStruct);

    // 启用DMA
    DMA_Cmd(DMA2_Stream0, ENABLE);

    // 启用ADC DMA请求
    ADC_DMACmd(ADC1, ENABLE);

    // 启用ADC
    ADC_Cmd(ADC1, ENABLE);

    // 启动ADC转换
    ADC_SoftwareStartConv(ADC1);
}

int main(void) {
    ADC_DMA_Init();

    while (1) {
        // 在此处处理ADC数据
        // adc_buffer中存储了ADC转换结果
    }
}
```

:::note
**注意**：在实际应用中，可能需要根据具体的STM32型号和开发环境调整代码。
:::

## 实际应用场景

### 音频信号采集

在音频信号采集系统中，通常需要以较高的采样率连续采集模拟信号。使用DMA传输可以确保数据的高效传输，而不会因为频繁的中断处理导致数据丢失或系统性能下降。

### 传感器数据采集

在传感器数据采集系统中，多个传感器可能需要同时进行数据采集。通过配置多个ADC通道并使用DMA传输，可以同时采集多个传感器的数据，并将结果存储在内存中，供后续处理。

## 总结

通过使用DMA传输，STM32微控制器可以高效地处理ADC转换结果，特别是在需要连续或高速采样的应用中。DMA传输不仅减少了CPU的负担，还提高了系统的整体性能。

## 附加资源与练习

- **练习1**：尝试修改代码，使其能够同时采集多个ADC通道的数据。
- **练习2**：研究如何在DMA传输完成后触发中断，并在中断服务程序中进行数据处理。
- **资源**：参考STM32官方文档，了解更多关于ADC和DMA的配置选项。

:::tip
**提示**：在实际项目中，建议使用STM32CubeMX工具来生成初始化代码，以减少手动配置的工作量。
:::