---
title: STM32 GPIO开漏推挽
description: 了解STM32 GPIO的开漏和推挽输出模式，掌握其工作原理、应用场景及代码实现。
---

# STM32 GPIO开漏推挽

在STM32微控制器中，GPIO（通用输入输出）引脚是连接外部世界的关键接口。GPIO引脚可以配置为多种模式，其中**开漏输出**和**推挽输出**是两种常见的输出模式。本文将详细介绍这两种模式的工作原理、区别以及实际应用场景。

## 1. 什么是开漏输出和推挽输出？

### 1.1 推挽输出（Push-Pull Output）
推挽输出模式是STM32 GPIO最常见的输出模式之一。在这种模式下，GPIO引脚可以通过两个晶体管（一个N型和一个P型）来驱动输出。当输出高电平时，P型晶体管导通，N型晶体管截止，引脚被拉高至VDD（电源电压）。当输出低电平时，N型晶体管导通，P型晶体管截止，引脚被拉低至GND（地）。

推挽输出的特点是能够提供较强的驱动能力，既可以输出高电平，也可以输出低电平。

### 1.2 开漏输出（Open-Drain Output）
开漏输出模式与推挽输出不同，它只有一个N型晶体管连接到引脚。当输出高电平时，N型晶体管截止，引脚处于高阻态（即“开漏”状态），此时需要外部上拉电阻将引脚拉至高电平。当输出低电平时，N型晶体管导通，引脚被拉低至GND。

开漏输出的特点是只能主动拉低电平，而不能主动拉高电平。它通常用于需要多个设备共享同一信号线的场景，例如I2C总线。

## 2. 推挽输出与开漏输出的对比

| 特性            | 推挽输出               | 开漏输出               |
|-----------------|------------------------|------------------------|
| 驱动能力        | 强                     | 弱（需要外部上拉电阻） |
| 输出高电平      | 主动拉高               | 高阻态（需外部上拉）   |
| 输出低电平      | 主动拉低               | 主动拉低               |
| 适用场景        | 单设备驱动、高速信号   | 多设备共享信号线       |

## 3. 代码示例

### 3.1 推挽输出配置
以下代码展示了如何将STM32的GPIO引脚配置为推挽输出模式：

```c
#include "stm32f4xx.h"

void GPIO_Config(void) {
    // 启用GPIOA时钟
    RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOA, ENABLE);

    // 配置GPIOA的第5引脚为推挽输出
    GPIO_InitTypeDef GPIO_InitStruct;
    GPIO_InitStruct.GPIO_Pin = GPIO_Pin_5;
    GPIO_InitStruct.GPIO_Mode = GPIO_Mode_OUT;
    GPIO_InitStruct.GPIO_OType = GPIO_OType_PP;  // 推挽输出
    GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz;
    GPIO_InitStruct.GPIO_PuPd = GPIO_PuPd_NOPULL;
    GPIO_Init(GPIOA, &GPIO_InitStruct);
}

int main(void) {
    GPIO_Config();

    // 设置GPIOA的第5引脚为高电平
    GPIO_SetBits(GPIOA, GPIO_Pin_5);

    while (1) {
        // 主循环
    }
}
```

### 3.2 开漏输出配置
以下代码展示了如何将STM32的GPIO引脚配置为开漏输出模式：

```c
#include "stm32f4xx.h"

void GPIO_Config(void) {
    // 启用GPIOA时钟
    RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOA, ENABLE);

    // 配置GPIOA的第5引脚为开漏输出
    GPIO_InitTypeDef GPIO_InitStruct;
    GPIO_InitStruct.GPIO_Pin = GPIO_Pin_5;
    GPIO_InitStruct.GPIO_Mode = GPIO_Mode_OUT;
    GPIO_InitStruct.GPIO_OType = GPIO_OType_OD;  // 开漏输出
    GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz;
    GPIO_InitStruct.GPIO_PuPd = GPIO_PuPd_UP;    // 内部上拉
    GPIO_Init(GPIOA, &GPIO_InitStruct);
}

int main(void) {
    GPIO_Config();

    // 设置GPIOA的第5引脚为低电平
    GPIO_ResetBits(GPIOA, GPIO_Pin_5);

    while (1) {
        // 主循环
    }
}
```

## 4. 实际应用场景

### 4.1 推挽输出的应用
推挽输出模式常用于驱动LED、继电器等需要较强驱动能力的设备。例如，在控制LED时，推挽输出可以直接驱动LED亮灭，而无需外部电路。

### 4.2 开漏输出的应用
开漏输出模式常用于I2C总线等需要多个设备共享信号线的场景。在I2C总线中，SDA（数据线）和SCL（时钟线）通常配置为开漏输出，并通过外部上拉电阻拉高电平。这样，多个设备可以共享同一信号线而不会发生冲突。

## 5. 总结

- **推挽输出**：适合单设备驱动，能够主动输出高电平和低电平，驱动能力强。
- **开漏输出**：适合多设备共享信号线，只能主动拉低电平，需要外部上拉电阻。

通过合理选择输出模式，可以优化电路设计并满足不同的应用需求。

## 6. 附加资源与练习

- **练习1**：尝试将STM32的GPIO引脚配置为开漏输出，并连接一个LED，观察其行为。
- **练习2**：使用推挽输出模式驱动一个继电器，并控制其开关状态。
- **参考文档**：STM32官方参考手册中的GPIO章节。

:::tip
在实际项目中，选择合适的输出模式可以显著提高电路的可靠性和性能。建议根据具体需求灵活选择推挽或开漏输出模式。
:::