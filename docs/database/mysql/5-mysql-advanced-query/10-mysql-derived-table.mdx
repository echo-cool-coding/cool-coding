---
title: MySQL 派生表
description: 了解MySQL中的派生表概念，掌握如何通过子查询创建临时表并在查询中使用它们。
---

# MySQL 派生表

在MySQL中，**派生表**是从查询结果中创建的临时表。它们通常用于简化复杂查询，或者将子查询的结果作为一个表来使用。派生表是SQL查询中非常强大的工具，尤其是在处理多层嵌套查询时。

## 什么是派生表？

派生表是通过子查询生成的临时表。它不是一个物理表，而是在查询执行期间动态生成的。派生表可以像普通表一样在查询中使用，但它们只在查询的生命周期内存在。

派生表的主要优点是：
- 简化复杂查询。
- 提高查询的可读性。
- 允许在查询中重用子查询的结果。

## 派生表的基本语法

派生表的基本语法如下：

```sql
SELECT column1, column2, ...
FROM (
    SELECT column1, column2, ...
    FROM table_name
    WHERE condition
) AS derived_table_name
WHERE condition;
```

在这个语法中：
- 子查询的结果被命名为 `derived_table_name`。
- 外部查询可以像使用普通表一样使用这个派生表。

## 示例：使用派生表

假设我们有一个 `orders` 表，包含以下数据：

```sql
+---------+------------+--------+
| order_id| order_date | amount |
+---------+------------+--------+
| 1       | 2023-01-01 | 100    |
| 2       | 2023-01-02 | 200    |
| 3       | 2023-01-03 | 150    |
| 4       | 2023-01-04 | 300    |
+---------+------------+--------+
```

我们想要查询所有订单金额大于150的订单，并按日期排序。可以使用派生表来实现：

```sql
SELECT order_id, order_date, amount
FROM (
    SELECT order_id, order_date, amount
    FROM orders
    WHERE amount > 150
) AS high_value_orders
ORDER BY order_date;
```

### 输出结果：

```sql
+---------+------------+--------+
| order_id| order_date | amount |
+---------+------------+--------+
| 2       | 2023-01-02 | 200    |
| 4       | 2023-01-04 | 300    |
+---------+------------+--------+
```

在这个例子中，子查询 `SELECT order_id, order_date, amount FROM orders WHERE amount > 150` 生成了一个派生表 `high_value_orders`，然后外部查询从这个派生表中选择数据并按日期排序。

## 派生表的实际应用场景

### 场景1：多层嵌套查询

假设我们有一个 `employees` 表和一个 `departments` 表，我们想要查询每个部门的平均工资，并找出高于公司平均工资的部门。

```sql
SELECT department_name, avg_salary
FROM (
    SELECT d.department_name, AVG(e.salary) AS avg_salary
    FROM employees e
    JOIN departments d ON e.department_id = d.department_id
    GROUP BY d.department_name
) AS department_avg_salary
WHERE avg_salary > (SELECT AVG(salary) FROM employees);
```

在这个查询中，派生表 `department_avg_salary` 计算了每个部门的平均工资，然后外部查询筛选出高于公司平均工资的部门。

### 场景2：复杂过滤

假设我们有一个 `sales` 表，我们想要查询每个销售员的最高销售额，并找出销售额超过1000的销售员。

```sql
SELECT salesperson_id, max_sale
FROM (
    SELECT salesperson_id, MAX(sale_amount) AS max_sale
    FROM sales
    GROUP BY salesperson_id
) AS max_sales
WHERE max_sale > 1000;
```

在这个查询中，派生表 `max_sales` 计算了每个销售员的最高销售额，然后外部查询筛选出销售额超过1000的销售员。

## 派生表的限制

虽然派生表非常有用，但它们也有一些限制：
- 派生表不能有索引，因此在处理大数据集时可能会影响性能。
- 派生表只能在查询的生命周期内使用，不能在多个查询之间共享。

:::tip
为了提高查询性能，尽量避免在派生表中使用复杂的子查询，尤其是在处理大数据集时。
:::

## 总结

派生表是MySQL中一个非常有用的工具，可以帮助我们简化复杂查询并提高查询的可读性。通过将子查询的结果作为临时表使用，我们可以在查询中重用这些结果，从而避免重复计算。

在实际应用中，派生表常用于多层嵌套查询和复杂过滤场景。然而，需要注意的是，派生表没有索引，因此在处理大数据集时可能会影响性能。

## 附加资源与练习

### 练习1
尝试在 `orders` 表中查询所有订单金额大于200的订单，并按金额降序排列。

### 练习2
在 `employees` 表中，查询每个部门的员工数量，并找出员工数量超过10的部门。

### 进一步学习
- [MySQL官方文档](https://dev.mysql.com/doc/)
- 《高性能MySQL》—— Baron Schwartz 等

通过不断练习和探索，你将能够更好地掌握MySQL派生表的使用技巧！