---
title: MySQL OLD 和 NEW 引用
description: 了解 MySQL 触发器中的 OLD 和 NEW 引用，掌握如何在触发器中使用它们来访问修改前后的数据。
---

# MySQL OLD 和 NEW 引用

在 MySQL 触发器中，`OLD` 和 `NEW` 是两个非常重要的关键字，它们允许你在触发器内部访问被修改的数据。`OLD` 用于引用修改前的数据，而 `NEW` 用于引用修改后的数据。理解这两个关键字的使用场景和方法，对于编写有效的触发器至关重要。

## 什么是 OLD 和 NEW？

在 MySQL 触发器中，`OLD` 和 `NEW` 是虚拟表，它们分别表示在触发器执行前和执行后的数据状态。具体来说：

- `OLD`：表示触发器执行前的数据状态。它通常用于 `UPDATE` 和 `DELETE` 操作中，因为这些操作会修改或删除现有数据。
- `NEW`：表示触发器执行后的数据状态。它通常用于 `INSERT` 和 `UPDATE` 操作中，因为这些操作会插入新数据或修改现有数据。

:::note
`OLD` 和 `NEW` 只能在触发器内部使用，不能在触发器外部直接访问。
:::

## OLD 和 NEW 的使用场景

### 1. INSERT 触发器

在 `INSERT` 触发器中，只有 `NEW` 是可用的，因为插入操作没有旧数据。你可以使用 `NEW` 来访问即将插入的新数据。

```sql
CREATE TRIGGER before_insert_trigger
BEFORE INSERT ON employees
FOR EACH ROW
BEGIN
    -- 使用 NEW 访问即将插入的数据
    SET NEW.salary = NEW.salary * 1.1; -- 将薪水增加 10%
END;
```

在这个例子中，`NEW.salary` 表示即将插入的 `salary` 字段的值。触发器在插入之前将薪水增加了 10%。

### 2. UPDATE 触发器

在 `UPDATE` 触发器中，`OLD` 和 `NEW` 都可用。`OLD` 表示更新前的数据，`NEW` 表示更新后的数据。

```sql
CREATE TRIGGER before_update_trigger
BEFORE UPDATE ON employees
FOR EACH ROW
BEGIN
    -- 使用 OLD 和 NEW 访问更新前后的数据
    IF OLD.salary <> NEW.salary THEN
        INSERT INTO salary_changes (employee_id, old_salary, new_salary, change_date)
        VALUES (OLD.employee_id, OLD.salary, NEW.salary, NOW());
    END IF;
END;
```

在这个例子中，触发器在更新 `employees` 表之前检查薪水是否发生了变化。如果薪水发生了变化，触发器会将变化记录到 `salary_changes` 表中。

### 3. DELETE 触发器

在 `DELETE` 触发器中，只有 `OLD` 是可用的，因为删除操作没有新数据。你可以使用 `OLD` 来访问即将被删除的数据。

```sql
CREATE TRIGGER before_delete_trigger
BEFORE DELETE ON employees
FOR EACH ROW
BEGIN
    -- 使用 OLD 访问即将被删除的数据
    INSERT INTO deleted_employees (employee_id, name, salary, delete_date)
    VALUES (OLD.employee_id, OLD.name, OLD.salary, NOW());
END;
```

在这个例子中，触发器在删除 `employees` 表中的记录之前，将被删除的数据插入到 `deleted_employees` 表中。

## 实际案例

假设你有一个 `orders` 表，用于存储订单信息。你希望在订单状态更新时，记录状态的变化。你可以使用 `UPDATE` 触发器来实现这个功能。

```sql
CREATE TRIGGER order_status_update_trigger
BEFORE UPDATE ON orders
FOR EACH ROW
BEGIN
    -- 检查订单状态是否发生变化
    IF OLD.status <> NEW.status THEN
        INSERT INTO order_status_history (order_id, old_status, new_status, change_date)
        VALUES (OLD.order_id, OLD.status, NEW.status, NOW());
    END IF;
END;
```

在这个案例中，触发器会在订单状态更新时，将状态变化记录到 `order_status_history` 表中。

## 总结

`OLD` 和 `NEW` 是 MySQL 触发器中非常重要的关键字，它们允许你在触发器内部访问修改前后的数据。通过合理使用 `OLD` 和 `NEW`，你可以实现诸如数据验证、日志记录、自动计算等功能。

:::tip
在实际开发中，触发器的使用需要谨慎，因为它们可能会对数据库性能产生影响。确保触发器的逻辑简洁高效，避免不必要的复杂操作。
:::

## 附加资源

- [MySQL 触发器官方文档](https://dev.mysql.com/doc/refman/8.0/en/triggers.html)
- [MySQL 触发器教程](https://www.mysqltutorial.org/mysql-triggers/)

## 练习

1. 创建一个 `BEFORE INSERT` 触发器，在插入新员工时自动将员工姓名转换为大写。
2. 创建一个 `AFTER UPDATE` 触发器，在更新产品价格时，将价格变化记录到 `price_changes` 表中。
3. 创建一个 `BEFORE DELETE` 触发器，在删除客户记录时，检查该客户是否有未完成的订单，如果有则阻止删除操作。

通过完成这些练习，你将更好地理解 `OLD` 和 `NEW` 的使用方法，并能够编写更复杂的触发器。