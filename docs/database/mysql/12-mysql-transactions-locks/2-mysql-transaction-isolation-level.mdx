---
title: MySQL 事务隔离级别
description: 了解MySQL事务隔离级别的基本概念、不同级别的作用及其在实际应用中的使用场景。
---

# MySQL 事务隔离级别

在数据库管理系统中，事务隔离级别是控制事务之间如何相互影响的重要机制。MySQL支持多种事务隔离级别，每种级别都定义了事务在并发执行时的可见性和一致性行为。理解这些隔离级别对于设计高效、可靠的数据库应用至关重要。

## 什么是事务隔离级别？

事务隔离级别定义了多个事务在并发执行时，一个事务的操作对其他事务的可见性。隔离级别越高，事务之间的干扰越少，但可能会影响性能；隔离级别越低，性能可能更好，但可能会导致数据不一致的问题。

MySQL支持以下四种事务隔离级别：

1. **读未提交（READ UNCOMMITTED）**
2. **读已提交（READ COMMITTED）**
3. **可重复读（REPEATABLE READ）**
4. **串行化（SERIALIZABLE）**

接下来，我们将逐一介绍这些隔离级别，并通过示例展示它们的行为。

## 1. 读未提交（READ UNCOMMITTED）

在`READ UNCOMMITTED`隔离级别下，一个事务可以读取另一个事务尚未提交的更改。这种隔离级别可能会导致“脏读”（Dirty Read），即读取到未提交的数据，这些数据可能会被回滚。

### 示例

假设有两个事务A和B：

```sql
-- 事务A
START TRANSACTION;
UPDATE accounts SET balance = balance - 100 WHERE id = 1;

-- 事务B
START TRANSACTION;
SELECT balance FROM accounts WHERE id = 1; -- 可能读取到未提交的更改
```

在`READ UNCOMMITTED`隔离级别下，事务B可能会读取到事务A尚未提交的更改，即使事务A最终可能会回滚。

## 2. 读已提交（READ COMMITTED）

在`READ COMMITTED`隔离级别下，一个事务只能读取另一个事务已经提交的更改。这种隔离级别避免了脏读，但可能会导致“不可重复读”（Non-Repeatable Read），即在同一个事务中，多次读取同一数据可能会得到不同的结果。

### 示例

```sql
-- 事务A
START TRANSACTION;
UPDATE accounts SET balance = balance - 100 WHERE id = 1;
COMMIT;

-- 事务B
START TRANSACTION;
SELECT balance FROM accounts WHERE id = 1; -- 读取到事务A提交后的数据
```

在`READ COMMITTED`隔离级别下，事务B只能读取到事务A已经提交的更改。

## 3. 可重复读（REPEATABLE READ）

`REPEATABLE READ`是MySQL的默认隔离级别。在这个级别下，一个事务在执行期间看到的数据是一致的，即使其他事务对数据进行了修改。这种隔离级别避免了脏读和不可重复读，但可能会导致“幻读”（Phantom Read），即在同一个事务中，多次查询可能会返回不同的行集。

### 示例

```sql
-- 事务A
START TRANSACTION;
SELECT * FROM accounts WHERE balance > 500; -- 第一次查询

-- 事务B
START TRANSACTION;
INSERT INTO accounts (id, balance) VALUES (3, 600);
COMMIT;

-- 事务A
SELECT * FROM accounts WHERE balance > 500; -- 第二次查询，结果可能与第一次不同
```

在`REPEATABLE READ`隔离级别下，事务A在第一次查询后，即使事务B插入了新的数据，事务A的第二次查询结果仍然与第一次一致。

## 4. 串行化（SERIALIZABLE）

`SERIALIZABLE`是最严格的隔离级别。在这个级别下，事务是串行执行的，即一个事务必须等待另一个事务完成后才能开始。这种隔离级别避免了脏读、不可重复读和幻读，但会显著降低并发性能。

### 示例

```sql
-- 事务A
START TRANSACTION;
SELECT * FROM accounts WHERE balance > 500 FOR UPDATE;

-- 事务B
START TRANSACTION;
INSERT INTO accounts (id, balance) VALUES (4, 700); -- 必须等待事务A完成
```

在`SERIALIZABLE`隔离级别下，事务B必须等待事务A完成后才能执行插入操作。

## 实际应用场景

### 银行转账

在银行转账场景中，`REPEATABLE READ`隔离级别可以确保在转账过程中，账户余额的一致性。例如，如果一个事务正在读取账户余额并进行转账操作，另一个事务不能同时修改该账户的余额，从而避免了数据不一致的问题。

### 电商库存管理

在电商库存管理中，`SERIALIZABLE`隔离级别可以确保在库存更新时，不会出现超卖的情况。例如，如果一个事务正在减少库存，另一个事务必须等待该事务完成后才能进行库存更新。

## 总结

MySQL的事务隔离级别提供了不同级别的数据一致性和并发控制。选择合适的隔离级别取决于应用的需求和性能要求。对于大多数应用，`REPEATABLE READ`是一个不错的选择，因为它提供了良好的数据一致性和并发性能。

## 附加资源与练习

- **练习1**：在MySQL中创建一个表，并尝试在不同隔离级别下执行事务，观察事务之间的相互影响。
- **练习2**：设计一个并发场景，使用`SERIALIZABLE`隔离级别来避免数据不一致的问题。

:::tip
建议在实际应用中，根据业务需求选择合适的隔离级别，并在必要时进行性能测试。
:::