---
title: MySQL 8.0 降序索引
description: 了解 MySQL 8.0 中的降序索引特性，掌握其工作原理、使用场景以及如何在实际项目中应用。
---

## 介绍

在 MySQL 8.0 之前，索引默认是按升序（ASC）存储的。虽然你可以指定降序（DESC）排序，但实际上索引仍然是按升序存储的，查询时需要通过额外的步骤来处理降序排序。MySQL 8.0 引入了真正的降序索引（Descending Indexes），这意味着索引可以按降序存储数据，从而优化降序查询的性能。

降序索引特别适用于需要按降序排序的查询场景，例如按时间倒序排列的日志记录、按分数从高到低排序的用户排名等。

## 降序索引的工作原理

在 MySQL 8.0 中，当你创建一个降序索引时，索引会按降序存储数据。这意味着查询时不需要额外的排序步骤，从而提高了查询效率。

### 创建降序索引

你可以通过在创建索引时指定 `DESC` 关键字来创建降序索引。例如：

```sql
CREATE TABLE users (
    id INT PRIMARY KEY,
    name VARCHAR(100),
    score INT,
    INDEX idx_score_desc (score DESC)
);
```

在这个例子中，`idx_score_desc` 是一个按 `score` 字段降序排列的索引。

### 查询降序索引

当你执行一个按 `score` 降序排列的查询时，MySQL 可以直接使用这个降序索引，而不需要额外的排序操作：

```sql
SELECT * FROM users ORDER BY score DESC;
```

由于 `idx_score_desc` 是按降序存储的，MySQL 可以直接使用这个索引来满足查询需求，从而提高查询性能。

## 实际应用场景

### 场景 1：按时间倒序排列的日志记录

假设你有一个日志表，记录了用户的操作日志，并且你经常需要按时间倒序查询最近的日志记录：

```sql
CREATE TABLE user_logs (
    id INT PRIMARY KEY,
    user_id INT,
    action VARCHAR(100),
    created_at DATETIME,
    INDEX idx_created_at_desc (created_at DESC)
);
```

在这个场景中，`idx_created_at_desc` 索引可以显著提高按时间倒序查询的性能：

```sql
SELECT * FROM user_logs ORDER BY created_at DESC LIMIT 10;
```

### 场景 2：按分数从高到低排序的用户排名

假设你有一个用户表，记录了用户的分数，并且你经常需要按分数从高到低查询用户排名：

```sql
CREATE TABLE user_scores (
    id INT PRIMARY KEY,
    name VARCHAR(100),
    score INT,
    INDEX idx_score_desc (score DESC)
);
```

在这个场景中，`idx_score_desc` 索引可以显著提高按分数降序查询的性能：

```sql
SELECT * FROM user_scores ORDER BY score DESC LIMIT 10;
```

## 总结

MySQL 8.0 的降序索引特性为需要按降序排序的查询场景提供了显著的性能优化。通过创建降序索引，你可以避免查询时的额外排序操作，从而提高查询效率。

在实际应用中，降序索引特别适用于按时间倒序排列的日志记录、按分数从高到低排序的用户排名等场景。

## 附加资源与练习

- **练习 1**：创建一个包含降序索引的表，并执行降序查询，观察查询性能的变化。
- **练习 2**：在一个现有的表中添加降序索引，并比较添加索引前后的查询性能。

:::tip
在实际项目中，使用降序索引时，建议结合 `EXPLAIN` 命令来查看查询执行计划，确保索引被正确使用。
:::

:::caution
虽然降序索引可以提高查询性能，但在某些情况下，过多的索引可能会影响写入性能。因此，在创建索引时需要权衡查询性能和写入性能。
:::