---
title: SQL 读已提交
description: 了解SQL中的读已提交隔离级别，掌握其工作原理、应用场景以及如何在实际中使用。
---

# SQL 读已提交

在数据库管理系统中，事务的隔离级别是控制并发事务之间如何相互影响的重要机制。**读已提交（Read Committed）**是SQL标准中定义的一种隔离级别，它确保事务只能读取到已经提交的数据，从而避免脏读问题。本文将详细介绍读已提交的概念、工作原理以及实际应用。

## 什么是读已提交？

**读已提交**是SQL标准中定义的四种隔离级别之一。它的核心特点是：在一个事务中，只能读取到其他事务已经提交的数据。这意味着，如果其他事务正在修改数据但尚未提交，当前事务将无法看到这些未提交的修改。

### 读已提交的特点

- **避免脏读**：事务只能读取到已经提交的数据，不会读取到未提交的修改。
- **允许不可重复读**：在同一事务中，多次读取同一数据可能会得到不同的结果，因为其他事务可能在两次读取之间提交了修改。
- **允许幻读**：在同一事务中，多次执行相同的查询可能会返回不同的结果集，因为其他事务可能在两次查询之间插入了新的数据。

## 读已提交的工作原理

为了更好地理解读已提交的工作原理，我们可以通过一个简单的例子来说明。

假设我们有一个名为 `accounts` 的表，其中包含用户的账户余额：

```sql
CREATE TABLE accounts (
    id INT PRIMARY KEY,
    name VARCHAR(50),
    balance DECIMAL(10, 2)
);

INSERT INTO accounts (id, name, balance) VALUES (1, 'Alice', 1000.00);
INSERT INTO accounts (id, name, balance) VALUES (2, 'Bob', 500.00);
```

现在，我们有两个事务同时操作这个表：

1. **事务A**：将Alice的余额减少100。
2. **事务B**：读取Alice的余额。

在**读已提交**隔离级别下，事务B只能读取到事务A已经提交的修改。如果事务A尚未提交，事务B将读取到事务A修改前的数据。

### 示例代码

```sql
-- 事务A
BEGIN;
UPDATE accounts SET balance = balance - 100 WHERE id = 1;

-- 事务B
BEGIN;
SELECT balance FROM accounts WHERE id = 1; -- 读取到的余额为1000.00

-- 事务A提交
COMMIT;

-- 事务B再次读取
SELECT balance FROM accounts WHERE id = 1; -- 读取到的余额为900.00
```

在这个例子中，事务B在事务A提交之前读取到的余额是1000.00，而在事务A提交之后读取到的余额是900.00。这展示了**读已提交**隔离级别如何避免脏读。

## 实际应用场景

**读已提交**隔离级别在实际应用中非常常见，特别是在需要保证数据一致性的场景中。以下是一些典型的应用场景：

1. **银行系统**：在银行系统中，账户余额的更新必须保证一致性。使用读已提交隔离级别可以确保事务只能读取到已经提交的余额更新，从而避免脏读。

2. **电商系统**：在电商系统中，库存的管理非常重要。使用读已提交隔离级别可以确保事务只能读取到已经提交的库存更新，从而避免超卖问题。

3. **订单处理系统**：在订单处理系统中，订单状态的更新必须保证一致性。使用读已提交隔离级别可以确保事务只能读取到已经提交的订单状态更新，从而避免订单状态不一致的问题。

## 总结

**读已提交**是SQL标准中定义的一种隔离级别，它确保事务只能读取到已经提交的数据，从而避免脏读问题。虽然它允许不可重复读和幻读，但在许多实际应用场景中，读已提交隔离级别已经足够满足需求。

通过本文的介绍，你应该对**读已提交**有了更深入的理解。如果你希望进一步学习SQL事务管理，可以参考以下资源：

- [SQL事务隔离级别详解](#)
- [SQL事务管理最佳实践](#)
- [SQL事务并发控制](#)

:::tip
**练习**：尝试在你的数据库中设置读已提交隔离级别，并模拟多个事务并发操作，观察事务之间的相互影响。
:::