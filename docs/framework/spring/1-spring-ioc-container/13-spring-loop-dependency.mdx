---
title: Spring 循环依赖
description: 了解Spring IoC容器中的循环依赖问题，学习如何识别、解决和避免循环依赖。
---

# Spring 循环依赖

在Spring框架中，**循环依赖**是指两个或多个Bean相互依赖，形成一个闭环。例如，Bean A依赖Bean B，而Bean B又依赖Bean A。这种情况下，Spring IoC容器在初始化Bean时会遇到问题，因为它无法确定应该先初始化哪个Bean。

## 什么是循环依赖？

循环依赖通常发生在以下场景中：

- **构造函数循环依赖**：两个Bean通过构造函数相互依赖。
- **Setter方法循环依赖**：两个Bean通过Setter方法相互依赖。

Spring IoC容器在初始化Bean时，会尝试解决这些依赖关系。然而，循环依赖可能会导致容器无法正确初始化Bean，从而抛出异常。

## 循环依赖的类型

### 1. 构造函数循环依赖

构造函数循环依赖是最难解决的问题，因为Spring在创建Bean时，必须首先调用构造函数。如果两个Bean通过构造函数相互依赖，Spring将无法确定应该先初始化哪个Bean。

```java
@Component
public class BeanA {
    private final BeanB beanB;

    @Autowired
    public BeanA(BeanB beanB) {
        this.beanB = beanB;
    }
}

@Component
public class BeanB {
    private final BeanA beanA;

    @Autowired
    public BeanB(BeanA beanA) {
        this.beanA = beanA;
    }
}
```

在上述代码中，`BeanA`和`BeanB`通过构造函数相互依赖，这将导致Spring无法初始化这两个Bean。

### 2. Setter方法循环依赖

Setter方法循环依赖相对容易解决，因为Spring可以在Bean初始化后通过Setter方法注入依赖。

```java
@Component
public class BeanA {
    private BeanB beanB;

    @Autowired
    public void setBeanB(BeanB beanB) {
        this.beanB = beanB;
    }
}

@Component
public class BeanB {
    private BeanA beanA;

    @Autowired
    public void setBeanA(BeanA beanA) {
        this.beanA = beanA;
    }
}
```

在这种情况下，Spring可以成功初始化`BeanA`和`BeanB`，因为它们在初始化后通过Setter方法注入依赖。

## Spring 如何解决循环依赖？

Spring通过**三级缓存**机制来解决Setter方法循环依赖问题。三级缓存分别是：

1. **Singleton Objects**：存放已经完全初始化的Bean。
2. **Early Singleton Objects**：存放已经实例化但尚未完全初始化的Bean。
3. **Singleton Factories**：存放Bean的工厂对象，用于创建早期Bean实例。

当Spring检测到循环依赖时，它会通过三级缓存机制提前暴露一个尚未完全初始化的Bean实例，从而解决循环依赖问题。

:::note
Spring无法解决构造函数循环依赖，因为构造函数必须在Bean初始化时调用，而三级缓存机制无法在这种情况下工作。
:::

## 实际案例

假设我们有一个电商系统，其中`OrderService`依赖`PaymentService`，而`PaymentService`又依赖`OrderService`。这种情况下，我们可以通过Setter方法来解决循环依赖问题。

```java
@Service
public class OrderService {
    private PaymentService paymentService;

    @Autowired
    public void setPaymentService(PaymentService paymentService) {
        this.paymentService = paymentService;
    }
}

@Service
public class PaymentService {
    private OrderService orderService;

    @Autowired
    public void setOrderService(OrderService orderService) {
        this.orderService = orderService;
    }
}
```

在这个案例中，Spring可以通过Setter方法成功解决`OrderService`和`PaymentService`之间的循环依赖。

## 如何避免循环依赖？

虽然Spring可以解决Setter方法循环依赖，但最好的做法是尽量避免循环依赖。以下是一些避免循环依赖的建议：

1. **重新设计类结构**：检查是否存在不必要的依赖关系，尝试通过重新设计类结构来消除循环依赖。
2. **使用接口**：通过接口来解耦类之间的依赖关系。
3. **使用`@Lazy`注解**：在依赖关系上使用`@Lazy`注解，延迟加载Bean，从而避免循环依赖。

```java
@Service
public class OrderService {
    private final PaymentService paymentService;

    @Autowired
    public OrderService(@Lazy PaymentService paymentService) {
        this.paymentService = paymentService;
    }
}
```

## 总结

循环依赖是Spring IoC容器中常见的问题，尤其是在复杂的应用程序中。Spring通过三级缓存机制解决了Setter方法循环依赖问题，但无法解决构造函数循环依赖。为了避免循环依赖，建议重新设计类结构、使用接口或`@Lazy`注解。

## 附加资源

- [Spring官方文档 - Bean依赖](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-dependencies)
- [Spring循环依赖详解](https://www.baeldung.com/circular-dependencies-in-spring)

## 练习

1. 尝试创建一个构造函数循环依赖的例子，并观察Spring的行为。
2. 修改上面的例子，使用Setter方法解决循环依赖问题。
3. 使用`@Lazy`注解解决一个循环依赖问题，并解释其工作原理。