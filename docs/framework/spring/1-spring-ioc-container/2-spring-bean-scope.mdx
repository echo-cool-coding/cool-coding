---
title: Spring Bean作用域
description: 了解Spring IoC容器中的Bean作用域，掌握单例、原型、请求、会话和应用作用域的使用场景和配置方法。
---

# Spring Bean作用域

在Spring框架中，Bean是应用程序的核心组件，而Bean的作用域（Scope）决定了这些Bean的生命周期和可见性。理解Bean作用域对于构建高效、灵活的Spring应用程序至关重要。本文将详细介绍Spring中的Bean作用域，并通过代码示例和实际案例帮助你掌握这一概念。

## 什么是Bean作用域？

Bean作用域定义了Bean的生命周期和可见范围。Spring框架支持多种作用域，每种作用域适用于不同的场景。默认情况下，Spring Bean的作用域是单例（Singleton），但你可以根据需要选择其他作用域。

## Spring 支持的Bean作用域

Spring框架支持以下五种Bean作用域：

1. **Singleton（单例）**：在整个Spring IoC容器中，Bean只有一个实例。
2. **Prototype（原型）**：每次请求时都会创建一个新的Bean实例。
3. **Request（请求）**：每个HTTP请求都会创建一个新的Bean实例，仅适用于Web应用。
4. **Session（会话）**：每个HTTP会话都会创建一个新的Bean实例，仅适用于Web应用。
5. **Application（应用）**：在整个Web应用中，Bean只有一个实例，类似于单例，但范围更广。

### 1. Singleton作用域

Singleton是Spring默认的作用域。在这种作用域下，Spring IoC容器只会创建一个Bean实例，并在所有请求中共享该实例。

```java
@Component
@Scope("singleton")
public class SingletonBean {
    // Bean的具体实现
}
```

**示例：**

```java
@Autowired
private SingletonBean singletonBean1;

@Autowired
private SingletonBean singletonBean2;

// singletonBean1 和 singletonBean2 是同一个实例
System.out.println(singletonBean1 == singletonBean2); // 输出：true
```

### 2. Prototype作用域

Prototype作用域表示每次请求时都会创建一个新的Bean实例。这种作用域适用于需要保持独立状态的Bean。

```java
@Component
@Scope("prototype")
public class PrototypeBean {
    // Bean的具体实现
}
```

**示例：**

```java
@Autowired
private ApplicationContext context;

PrototypeBean prototypeBean1 = context.getBean(PrototypeBean.class);
PrototypeBean prototypeBean2 = context.getBean(PrototypeBean.class);

// prototypeBean1 和 prototypeBean2 是不同的实例
System.out.println(prototypeBean1 == prototypeBean2); // 输出：false
```

### 3. Request作用域

Request作用域表示每个HTTP请求都会创建一个新的Bean实例。这种作用域适用于Web应用程序中需要为每个请求保持独立状态的Bean。

```java
@Component
@Scope(value = WebApplicationContext.SCOPE_REQUEST, proxyMode = ScopedProxyMode.TARGET_CLASS)
public class RequestBean {
    // Bean的具体实现
}
```

**示例：**

```java
@Autowired
private RequestBean requestBean;

// 每次HTTP请求时，requestBean都会是一个新的实例
```

### 4. Session作用域

Session作用域表示每个HTTP会话都会创建一个新的Bean实例。这种作用域适用于Web应用程序中需要为每个用户会话保持独立状态的Bean。

```java
@Component
@Scope(value = WebApplicationContext.SCOPE_SESSION, proxyMode = ScopedProxyMode.TARGET_CLASS)
public class SessionBean {
    // Bean的具体实现
}
```

**示例：**

```java
@Autowired
private SessionBean sessionBean;

// 每个用户会话中，sessionBean都会是一个新的实例
```

### 5. Application作用域

Application作用域表示在整个Web应用中，Bean只有一个实例。这种作用域类似于单例，但范围更广，适用于需要在整个Web应用中共享的Bean。

```java
@Component
@Scope(value = WebApplicationContext.SCOPE_APPLICATION, proxyMode = ScopedProxyMode.TARGET_CLASS)
public class ApplicationBean {
    // Bean的具体实现
}
```

**示例：**

```java
@Autowired
private ApplicationBean applicationBean1;

@Autowired
private ApplicationBean applicationBean2;

// applicationBean1 和 applicationBean2 是同一个实例
System.out.println(applicationBean1 == applicationBean2); // 输出：true
```

## 实际应用场景

### 场景1：单例作用域的应用

假设你有一个配置类，其中包含一些全局配置信息。这些配置信息在整个应用程序中应该是唯一的，因此你可以使用单例作用域来确保只有一个实例。

```java
@Configuration
public class AppConfig {

    @Bean
    @Scope("singleton")
    public GlobalConfig globalConfig() {
        return new GlobalConfig();
    }
}
```

### 场景2：原型作用域的应用

假设你有一个任务处理器，每次处理任务时都需要一个新的实例来保持任务的独立性。你可以使用原型作用域来实现这一点。

```java
@Component
@Scope("prototype")
public class TaskProcessor {
    // 任务处理逻辑
}
```

### 场景3：请求作用域的应用

假设你有一个用户请求处理器，每个HTTP请求都需要一个新的实例来处理用户请求。你可以使用请求作用域来实现这一点。

```java
@Component
@Scope(value = WebApplicationContext.SCOPE_REQUEST, proxyMode = ScopedProxyMode.TARGET_CLASS)
public class UserRequestProcessor {
    // 用户请求处理逻辑
}
```

## 总结

Spring Bean作用域是Spring框架中的一个重要概念，它决定了Bean的生命周期和可见性。通过合理选择Bean作用域，你可以构建出高效、灵活的Spring应用程序。本文介绍了Spring支持的五种Bean作用域，并通过代码示例和实际案例帮助你理解它们的应用场景。

## 附加资源

- [Spring官方文档 - Bean作用域](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-scopes)
- [Spring IoC容器深入理解](https://www.baeldung.com/spring-ioc)
- [Spring Bean生命周期](https://www.baeldung.com/spring-bean-lifecycle)

## 练习

1. 创建一个单例Bean，并在多个地方注入该Bean，验证它们是否是同一个实例。
2. 创建一个原型Bean，并在多个地方注入该Bean，验证它们是否是不同的实例。
3. 在Web应用中创建一个请求作用域的Bean，并在不同的HTTP请求中验证其行为。

通过完成这些练习，你将更好地理解Spring Bean作用域的概念和应用。