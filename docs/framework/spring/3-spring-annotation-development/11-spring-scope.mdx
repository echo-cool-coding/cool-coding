---
title: Spring @Scope
description: "了解 Spring 框架中的 @Scope 注解，掌握如何控制 Bean 的作用域，并通过实际案例加深理解。"
---

## 介绍

在 Spring 框架中，Bean 的作用域（Scope）定义了 Bean 的生命周期和可见范围。默认情况下，Spring 中的 Bean 是单例（Singleton）的，这意味着在整个 Spring 容器中，每个 Bean 只有一个实例。然而，在某些情况下，我们可能需要不同的作用域，例如每次请求都创建一个新的 Bean 实例，或者每个会话中只使用一个 Bean 实例。

Spring 提供了 `@Scope` 注解，允许我们灵活地定义 Bean 的作用域。本文将详细介绍 `@Scope` 的使用方法，并通过实际案例帮助你理解其应用场景。

## @Scope 注解的基本用法

`@Scope` 注解可以用于类或方法级别，用于指定 Bean 的作用域。它的基本语法如下：

```java
@Scope(value = "作用域类型", proxyMode = ScopedProxyMode.XXX)
```

- `value`：指定 Bean 的作用域类型，例如 `singleton`、`prototype`、`request`、`session` 等。
- `proxyMode`：可选参数，用于指定代理模式，通常在需要延迟初始化或跨作用域引用时使用。

### 常见的作用域类型

Spring 支持以下几种常见的作用域：

1. **Singleton**：默认作用域，每个 Spring 容器中只有一个 Bean 实例。
2. **Prototype**：每次请求时都会创建一个新的 Bean 实例。
3. **Request**：每个 HTTP 请求都会创建一个新的 Bean 实例，仅适用于 Web 应用。
4. **Session**：每个 HTTP 会话都会创建一个新的 Bean 实例，仅适用于 Web 应用。
5. **Application**：每个 `ServletContext` 生命周期内只有一个 Bean 实例，仅适用于 Web 应用。
6. **WebSocket**：每个 WebSocket 会话内只有一个 Bean 实例，仅适用于 WebSocket 应用。

## 代码示例

### 示例 1：使用 Singleton 作用域

```java
@Component
@Scope("singleton")
public class SingletonBean {
    public SingletonBean() {
        System.out.println("SingletonBean 实例化");
    }
}
```

在这个例子中，`SingletonBean` 是一个单例 Bean，Spring 容器只会创建一个实例。

### 示例 2：使用 Prototype 作用域

```java
@Component
@Scope("prototype")
public class PrototypeBean {
    public PrototypeBean() {
        System.out.println("PrototypeBean 实例化");
    }
}
```

在这个例子中，`PrototypeBean` 是一个原型 Bean，每次请求时都会创建一个新的实例。

### 示例 3：使用 Request 作用域

```java
@Component
@Scope(value = "request", proxyMode = ScopedProxyMode.TARGET_CLASS)
public class RequestBean {
    public RequestBean() {
        System.out.println("RequestBean 实例化");
    }
}
```

在这个例子中，`RequestBean` 是一个请求作用域的 Bean，每个 HTTP 请求都会创建一个新的实例。`proxyMode` 参数用于指定代理模式，确保在需要时能够正确注入 Bean。

## 实际应用场景

### 场景 1：用户会话管理

在 Web 应用中，我们通常需要为每个用户会话创建一个独立的 Bean 实例，用于存储用户的会话信息。这时可以使用 `@Scope("session")` 注解。

```java
@Component
@Scope(value = "session", proxyMode = ScopedProxyMode.TARGET_CLASS)
public class UserSession {
    private String userId;

    public void setUserId(String userId) {
        this.userId = userId;
    }

    public String getUserId() {
        return userId;
    }
}
```

在这个例子中，`UserSession` Bean 的作用域是会话级别的，每个用户会话都会有一个独立的实例。

### 场景 2：请求级别的数据存储

在某些情况下，我们需要在请求级别存储一些临时数据，例如请求的上下文信息。这时可以使用 `@Scope("request")` 注解。

```java
@Component
@Scope(value = "request", proxyMode = ScopedProxyMode.TARGET_CLASS)
public class RequestContext {
    private String requestId;

    public void setRequestId(String requestId) {
        this.requestId = requestId;
    }

    public String getRequestId() {
        return requestId;
    }
}
```

在这个例子中，`RequestContext` Bean 的作用域是请求级别的，每个 HTTP 请求都会创建一个新的实例。

## 总结

`@Scope` 注解是 Spring 框架中用于控制 Bean 作用域的重要工具。通过合理使用 `@Scope`，我们可以灵活地管理 Bean 的生命周期和可见范围，从而满足不同的应用需求。

:::tip 提示
在实际开发中，选择合适的作用域非常重要。单例作用域适合无状态的 Bean，而原型作用域适合有状态的 Bean。对于 Web 应用，请求和会话作用域可以帮助我们更好地管理用户数据。
:::

## 附加资源

- [Spring 官方文档 - Bean Scopes](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-factory-scopes)
- [Spring @Scope 注解详解](https://www.baeldung.com/spring-bean-scopes)

## 练习

1. 创建一个名为 `PrototypeService` 的 Bean，并使用 `@Scope("prototype")` 注解。在 `Main` 类中多次获取该 Bean，观察输出结果。
2. 修改 `PrototypeService` 的作用域为 `singleton`，再次运行程序，观察输出结果的变化。
3. 在 Web 应用中创建一个 `SessionBean`，并使用 `@Scope("session")` 注解，模拟用户登录和注销的场景。

通过以上练习，你将更好地理解 `@Scope` 注解的使用方法和应用场景。