---
title: Spring 反应式编程
description: 了解Spring框架中的反应式编程模型，掌握如何使用Reactive Streams和Spring WebFlux构建高性能、非阻塞的应用程序。
---

# Spring 反应式编程

## 介绍

在现代应用程序开发中，处理高并发和实时数据流变得越来越重要。传统的同步阻塞模型在处理大量请求时可能会遇到性能瓶颈。为了解决这个问题，反应式编程（Reactive Programming）应运而生。Spring框架通过Spring WebFlux和Reactive Streams提供了对反应式编程的支持，使开发者能够构建高性能、非阻塞的应用程序。

反应式编程的核心思想是**异步数据流**。它允许开发者以声明式的方式处理数据流，而不是通过传统的回调或阻塞操作。Spring的反应式编程模型基于Reactive Streams规范，提供了一组强大的工具和API来处理异步数据流。

## 反应式编程的核心概念

### 1. 数据流（Data Streams）

在反应式编程中，数据流是核心概念。数据流可以是从数据库、消息队列、HTTP请求等来源发出的异步事件流。这些事件流可以被观察（Observe）、过滤（Filter）、转换（Transform）和组合（Combine）。

### 2. 发布者（Publisher）和订阅者（Subscriber）

Reactive Streams规范定义了两种主要角色：

- **Publisher**：负责生成数据流。
- **Subscriber**：负责消费数据流。

Spring WebFlux中的`Flux`和`Mono`是两种常见的Publisher实现。

### 3. 背压（Backpressure）

背压是反应式编程中的一个重要概念。它允许Subscriber控制Publisher的发布速度，从而避免因数据流过快而导致的内存溢出或性能问题。

## Spring WebFlux 简介

Spring WebFlux是Spring框架中用于构建反应式Web应用程序的模块。它基于Reactive Streams规范，提供了非阻塞的HTTP请求处理能力。与传统的Spring MVC不同，Spring WebFlux使用异步和非阻塞的I/O模型，能够更好地处理高并发场景。

### 1. Flux 和 Mono

在Spring WebFlux中，`Flux`和`Mono`是两个核心类：

- **Flux**：表示一个包含0到N个元素的异步序列。
- **Mono**：表示一个包含0或1个元素的异步序列。

以下是一个简单的`Flux`示例：

```java
Flux<String> flux = Flux.just("Hello", "World");
flux.subscribe(System.out::println);
```

**输出：**
```
Hello
World
```

### 2. 反应式控制器

在Spring WebFlux中，控制器方法可以返回`Flux`或`Mono`类型。以下是一个简单的反应式控制器示例：

```java
@RestController
public class ReactiveController {

    @GetMapping("/hello")
    public Mono<String> hello() {
        return Mono.just("Hello, World!");
    }
}
```

在这个例子中，`/hello`端点返回一个`Mono<String>`，表示一个异步的字符串结果。

## 实际案例：实时股票价格更新

假设我们正在构建一个实时股票价格更新系统。我们可以使用Spring WebFlux来处理来自股票市场的实时数据流，并将其推送到前端。

### 1. 模拟股票数据流

首先，我们创建一个模拟的股票数据流：

```java
Flux<StockPrice> stockPriceFlux = Flux.interval(Duration.ofSeconds(1))
    .map(tick -> new StockPrice("AAPL", 100 + tick * 0.1));
```

在这个例子中，`Flux.interval`每秒生成一个递增的数字，我们将其转换为一个模拟的股票价格。

### 2. 创建反应式控制器

接下来，我们创建一个反应式控制器来提供股票价格数据流：

```java
@RestController
public class StockController {

    @GetMapping(value = "/stock-prices", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
    public Flux<StockPrice> getStockPrices() {
        return Flux.interval(Duration.ofSeconds(1))
            .map(tick -> new StockPrice("AAPL", 100 + tick * 0.1));
    }
}
```

在这个例子中，`/stock-prices`端点返回一个`Flux<StockPrice>`，并使用`MediaType.TEXT_EVENT_STREAM_VALUE`来支持服务器发送事件（Server-Sent Events, SSE）。

### 3. 前端订阅数据流

前端可以使用EventSource API来订阅这个数据流：

```javascript
const eventSource = new EventSource('/stock-prices');
eventSource.onmessage = (event) => {
    console.log('Received stock price:', event.data);
};
```

每当服务器推送新的股票价格时，前端会收到通知并更新UI。

## 总结

Spring反应式编程为构建高性能、非阻塞的应用程序提供了强大的工具和API。通过使用Spring WebFlux和Reactive Streams，开发者可以轻松处理异步数据流，构建实时、高并发的应用程序。

:::tip
**提示**：反应式编程适用于需要处理大量并发请求或实时数据流的场景。如果你的应用程序主要是CPU密集型任务，传统的同步模型可能更适合。
:::

## 附加资源

- [Spring WebFlux官方文档](https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html)
- [Reactive Streams规范](https://www.reactive-streams.org/)
- [Project Reactor文档](https://projectreactor.io/docs/core/release/reference/)

## 练习

1. 创建一个简单的Spring WebFlux应用程序，返回一个包含10个随机数的`Flux`。
2. 修改上面的股票价格示例，使其支持多个股票代码（如"AAPL"和"GOOGL"）。
3. 尝试在前端使用WebSocket代替SSE来接收股票价格更新。

通过完成这些练习，你将更深入地理解Spring反应式编程的概念和应用。