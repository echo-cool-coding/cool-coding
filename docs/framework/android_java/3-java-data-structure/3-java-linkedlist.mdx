---
title: Java LinkedList
description: 了解 Java 中的 LinkedList，掌握其基本概念、操作方法以及实际应用场景。
---

## 介绍

在 Java 中，`LinkedList` 是一种常用的数据结构，它是 `List` 接口的一个实现类。与 `ArrayList` 不同，`LinkedList` 是基于双向链表实现的，这意味着它在插入和删除操作上具有更高的效率，但在随机访问时性能较差。

`LinkedList` 的每个元素都是一个节点（Node），节点中包含了数据以及指向前后节点的引用。这种结构使得 `LinkedList` 在动态添加和删除元素时非常高效。

## LinkedList 的基本操作

### 创建 LinkedList

要创建一个 `LinkedList`，可以使用以下代码：

```java
import java.util.LinkedList;

public class Main {
    public static void main(String[] args) {
        // 创建一个 LinkedList
        LinkedList<String> list = new LinkedList<>();

        // 添加元素
        list.add("Apple");
        list.add("Banana");
        list.add("Cherry");

        // 输出 LinkedList
        System.out.println(list); // 输出: [Apple, Banana, Cherry]
    }
}
```

### 添加元素

`LinkedList` 提供了多种添加元素的方法：

- `add(E e)`：在列表末尾添加元素。
- `add(int index, E element)`：在指定位置插入元素。
- `addFirst(E e)`：在列表开头添加元素。
- `addLast(E e)`：在列表末尾添加元素。

```java
list.addFirst("Apricot"); // 在开头添加元素
list.addLast("Date");     // 在末尾添加元素
System.out.println(list); // 输出: [Apricot, Apple, Banana, Cherry, Date]
```

### 删除元素

`LinkedList` 也提供了多种删除元素的方法：

- `remove()`：删除并返回列表的第一个元素。
- `remove(int index)`：删除指定位置的元素。
- `remove(Object o)`：删除第一次出现的指定元素。
- `removeFirst()`：删除并返回列表的第一个元素。
- `removeLast()`：删除并返回列表的最后一个元素。

```java
list.removeFirst(); // 删除第一个元素
list.removeLast();  // 删除最后一个元素
System.out.println(list); // 输出: [Apple, Banana, Cherry]
```

### 访问元素

`LinkedList` 提供了多种访问元素的方法：

- `get(int index)`：返回指定位置的元素。
- `getFirst()`：返回列表的第一个元素。
- `getLast()`：返回列表的最后一个元素。

```java
String firstElement = list.getFirst(); // 获取第一个元素
String lastElement = list.getLast();   // 获取最后一个元素
System.out.println("First Element: " + firstElement); // 输出: First Element: Apple
System.out.println("Last Element: " + lastElement);   // 输出: Last Element: Cherry
```

### 遍历 LinkedList

可以使用 `for-each` 循环或迭代器来遍历 `LinkedList`：

```java
for (String fruit : list) {
    System.out.println(fruit);
}

// 使用迭代器
Iterator<String> iterator = list.iterator();
while (iterator.hasNext()) {
    System.out.println(iterator.next());
}
```

## LinkedList 的实际应用场景

`LinkedList` 在许多场景中都非常有用，尤其是在需要频繁插入和删除元素的场合。以下是一些常见的应用场景：

1. **实现队列和栈**：`LinkedList` 可以用来实现队列（FIFO）和栈（LIFO）数据结构。
2. **浏览器历史记录**：浏览器的前进和后退功能可以使用 `LinkedList` 来实现。
3. **任务调度**：在任务调度系统中，`LinkedList` 可以用来管理待执行的任务列表。

### 示例：实现队列

```java
import java.util.LinkedList;
import java.util.Queue;

public class Main {
    public static void main(String[] args) {
        Queue<String> queue = new LinkedList<>();

        // 入队
        queue.add("Task 1");
        queue.add("Task 2");
        queue.add("Task 3");

        // 出队
        while (!queue.isEmpty()) {
            System.out.println("Processing: " + queue.poll());
        }
    }
}
```

输出：
```
Processing: Task 1
Processing: Task 2
Processing: Task 3
```

## 总结

`LinkedList` 是 Java 中一种基于链表实现的数据结构，适用于频繁插入和删除元素的场景。与 `ArrayList` 相比，`LinkedList` 在插入和删除操作上具有更高的效率，但在随机访问时性能较差。

通过本文，你已经了解了 `LinkedList` 的基本操作、实际应用场景以及如何在实际编程中使用它。希望这些知识能够帮助你在编程中更好地选择和使用数据结构。

## 附加资源与练习

- **练习 1**：尝试使用 `LinkedList` 实现一个简单的栈（LIFO）数据结构。
- **练习 2**：比较 `LinkedList` 和 `ArrayList` 在插入、删除和访问操作上的性能差异。
- **附加资源**：阅读 [Java 官方文档](https://docs.oracle.com/javase/8/docs/api/java/util/LinkedList.html) 以了解更多关于 `LinkedList` 的详细信息。

:::tip
在实际开发中，选择合适的数据结构非常重要。`LinkedList` 适合频繁插入和删除的场景，而 `ArrayList` 则适合频繁访问的场景。
:::