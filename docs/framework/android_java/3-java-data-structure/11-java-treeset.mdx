---
title: Java TreeSet
description: 了解 Java 中的 TreeSet，掌握其特性、用法以及实际应用场景。
---

# Java TreeSet

## 介绍

`TreeSet` 是 Java 集合框架中的一个重要类，它实现了 `SortedSet` 接口。`TreeSet` 基于红黑树（Red-Black Tree）数据结构实现，因此它能够自动对元素进行排序。与 `HashSet` 不同，`TreeSet` 中的元素是有序的，并且不允许存储重复值。

`TreeSet` 的主要特点包括：
- 元素自动排序（默认按自然顺序升序排列）。
- 不允许存储重复元素。
- 支持高效的查找、插入和删除操作（时间复杂度为 O(log n)）。

## 基本用法

### 创建 TreeSet

要使用 `TreeSet`，首先需要导入 `java.util.TreeSet` 包。然后可以通过以下方式创建一个 `TreeSet` 实例：

```java
import java.util.TreeSet;

public class TreeSetExample {
    public static void main(String[] args) {
        // 创建一个 TreeSet
        TreeSet<Integer> numbers = new TreeSet<>();

        // 添加元素
        numbers.add(5);
        numbers.add(3);
        numbers.add(8);
        numbers.add(1);

        // 输出 TreeSet
        System.out.println(numbers); // 输出: [1, 3, 5, 8]
    }
}
```

:::note
`TreeSet` 会自动对元素进行排序，因此输出的顺序是 `[1, 3, 5, 8]`，而不是插入的顺序。
:::

### 自定义排序

`TreeSet` 默认使用自然顺序（如数字的升序、字符串的字典序）进行排序。如果需要自定义排序规则，可以通过传递一个 `Comparator` 对象来实现。

```java
import java.util.Comparator;
import java.util.TreeSet;

public class TreeSetCustomSort {
    public static void main(String[] args) {
        // 创建一个按降序排序的 TreeSet
        TreeSet<Integer> numbers = new TreeSet<>(Comparator.reverseOrder());

        // 添加元素
        numbers.add(5);
        numbers.add(3);
        numbers.add(8);
        numbers.add(1);

        // 输出 TreeSet
        System.out.println(numbers); // 输出: [8, 5, 3, 1]
    }
}
```

:::tip
`Comparator.reverseOrder()` 是一个内置的比较器，用于实现降序排序。你也可以自定义 `Comparator` 来实现更复杂的排序逻辑。
:::

### 常用方法

`TreeSet` 提供了许多有用的方法，以下是一些常用的方法：

- `add(E e)`：添加元素。
- `remove(Object o)`：删除元素。
- `contains(Object o)`：检查是否包含某个元素。
- `first()`：返回第一个（最小）元素。
- `last()`：返回最后一个（最大）元素。
- `pollFirst()`：移除并返回第一个元素。
- `pollLast()`：移除并返回最后一个元素。

```java
import java.util.TreeSet;

public class TreeSetMethods {
    public static void main(String[] args) {
        TreeSet<String> fruits = new TreeSet<>();
        fruits.add("Apple");
        fruits.add("Banana");
        fruits.add("Cherry");

        System.out.println("First fruit: " + fruits.first()); // 输出: Apple
        System.out.println("Last fruit: " + fruits.last());  // 输出: Cherry

        fruits.pollFirst(); // 移除第一个元素
        System.out.println("After pollFirst: " + fruits); // 输出: [Banana, Cherry]
    }
}
```

## 实际应用场景

### 场景 1：维护有序数据

假设你需要维护一个有序的学生成绩列表，并且需要快速获取最高分和最低分。`TreeSet` 是一个理想的选择。

```java
import java.util.TreeSet;

public class StudentScores {
    public static void main(String[] args) {
        TreeSet<Integer> scores = new TreeSet<>();
        scores.add(85);
        scores.add(90);
        scores.add(78);
        scores.add(92);

        System.out.println("Highest score: " + scores.last()); // 输出: 92
        System.out.println("Lowest score: " + scores.first()); // 输出: 78
    }
}
```

### 场景 2：去重并排序

如果你有一个包含重复元素的列表，并且需要去重并排序，`TreeSet` 可以轻松实现。

```java
import java.util.TreeSet;

public class UniqueSortedNames {
    public static void main(String[] args) {
        String[] names = {"Alice", "Bob", "Alice", "Charlie", "Bob"};
        TreeSet<String> uniqueNames = new TreeSet<>();

        for (String name : names) {
            uniqueNames.add(name);
        }

        System.out.println("Unique and sorted names: " + uniqueNames);
        // 输出: [Alice, Bob, Charlie]
    }
}
```

## 总结

`TreeSet` 是 Java 中一个非常有用的集合类，特别适用于需要维护有序且唯一元素的场景。它基于红黑树实现，提供了高效的查找、插入和删除操作。通过自定义 `Comparator`，你可以灵活地控制元素的排序规则。

## 附加资源与练习

- **练习 1**：创建一个 `TreeSet`，存储一组字符串，并尝试使用自定义的 `Comparator` 按字符串长度排序。
- **练习 2**：编写一个程序，使用 `TreeSet` 存储一组整数，并找出其中的中位数。

:::caution
在使用 `TreeSet` 时，请确保元素类型实现了 `Comparable` 接口，或者提供一个自定义的 `Comparator`，否则会抛出 `ClassCastException`。
:::

希望这篇内容能帮助你更好地理解和使用 `TreeSet`！如果你有任何问题，欢迎在评论区留言。