---
title: Java并发包
description: 了解Java并发包（java.util.concurrent）的核心概念、工具类及其在实际开发中的应用，帮助初学者掌握多线程编程的高级特性。
---

## 介绍

Java并发包（`java.util.concurrent`）是Java标准库中用于简化多线程编程的工具包。它提供了一系列强大的工具类和接口，帮助开发者更高效地处理并发任务，避免常见的多线程问题，如死锁、竞态条件等。对于初学者来说，掌握并发包的使用是迈向高级Java开发的重要一步。

本文将逐步介绍Java并发包的核心组件，并通过代码示例和实际案例帮助你理解其用法。

---

## 核心组件

Java并发包包含以下几个主要组件：

1. **线程池（ThreadPoolExecutor）**
2. **并发集合（Concurrent Collections）**
3. **同步工具（Synchronizers）**
4. **原子变量（Atomic Variables）**
5. **锁（Locks）**

接下来，我们将逐一讲解这些组件。

---

### 1. 线程池（ThreadPoolExecutor）

线程池是管理多个线程的工具，它可以减少线程创建和销毁的开销，提高系统性能。Java提供了`ExecutorService`接口及其实现类`ThreadPoolExecutor`来管理线程池。

#### 示例：创建线程池并执行任务

```java
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class ThreadPoolExample {
    public static void main(String[] args) {
        // 创建一个固定大小的线程池
        ExecutorService executor = Executors.newFixedThreadPool(3);

        // 提交任务
        for (int i = 0; i < 5; i++) {
            executor.submit(() -> {
                System.out.println("Task executed by " + Thread.currentThread().getName());
            });
        }

        // 关闭线程池
        executor.shutdown();
    }
}
```

#### 输出
```
Task executed by pool-1-thread-1
Task executed by pool-1-thread-2
Task executed by pool-1-thread-3
Task executed by pool-1-thread-1
Task executed by pool-1-thread-2
```

:::tip
使用线程池时，务必在任务完成后调用`shutdown()`方法，否则线程池会一直运行。
:::

---

### 2. 并发集合（Concurrent Collections）

并发集合是线程安全的集合类，适用于多线程环境。常见的并发集合包括`ConcurrentHashMap`、`CopyOnWriteArrayList`等。

#### 示例：使用`ConcurrentHashMap`

```java
import java.util.concurrent.ConcurrentHashMap;

public class ConcurrentHashMapExample {
    public static void main(String[] args) {
        ConcurrentHashMap<String, Integer> map = new ConcurrentHashMap<>();

        // 添加元素
        map.put("A", 1);
        map.put("B", 2);

        // 获取元素
        System.out.println("Value of A: " + map.get("A"));
    }
}
```

#### 输出
```
Value of A: 1
```

:::note
`ConcurrentHashMap`通过分段锁机制实现线程安全，适合高并发场景。
:::

---

### 3. 同步工具（Synchronizers）

同步工具用于协调多个线程的执行顺序。常见的同步工具包括`CountDownLatch`、`CyclicBarrier`和`Semaphore`。

#### 示例：使用`CountDownLatch`

```java
import java.util.concurrent.CountDownLatch;

public class CountDownLatchExample {
    public static void main(String[] args) throws InterruptedException {
        CountDownLatch latch = new CountDownLatch(3);

        for (int i = 0; i < 3; i++) {
            new Thread(() -> {
                System.out.println("Thread " + Thread.currentThread().getName() + " is running");
                latch.countDown();
            }).start();
        }

        // 等待所有线程完成
        latch.await();
        System.out.println("All threads have finished");
    }
}
```

#### 输出
```
Thread Thread-0 is running
Thread Thread-1 is running
Thread Thread-2 is running
All threads have finished
```

:::caution
`CountDownLatch`是一次性的，计数归零后无法重置。
:::

---

### 4. 原子变量（Atomic Variables）

原子变量提供了一种无锁的线程安全操作方式。常见的原子变量包括`AtomicInteger`、`AtomicLong`等。

#### 示例：使用`AtomicInteger`

```java
import java.util.concurrent.atomic.AtomicInteger;

public class AtomicIntegerExample {
    public static void main(String[] args) {
        AtomicInteger counter = new AtomicInteger(0);

        // 增加计数
        counter.incrementAndGet();
        System.out.println("Counter: " + counter.get());
    }
}
```

#### 输出
```
Counter: 1
```

:::tip
原子变量适合在高并发场景下替代`synchronized`关键字。
:::

---

### 5. 锁（Locks）

Java并发包提供了比`synchronized`更灵活的锁机制，如`ReentrantLock`。

#### 示例：使用`ReentrantLock`

```java
import java.util.concurrent.locks.ReentrantLock;

public class ReentrantLockExample {
    private static final ReentrantLock lock = new ReentrantLock();

    public static void main(String[] args) {
        lock.lock();
        try {
            System.out.println("Locked by " + Thread.currentThread().getName());
        } finally {
            lock.unlock();
        }
    }
}
```

#### 输出
```
Locked by main
```

:::warning
使用`ReentrantLock`时，务必在`finally`块中释放锁，以避免死锁。
:::

---

## 实际案例：多线程下载器

以下是一个使用线程池和`CountDownLatch`实现的多线程下载器示例：

```java
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class MultiThreadDownloader {
    public static void main(String[] args) throws InterruptedException {
        int totalFiles = 5;
        CountDownLatch latch = new CountDownLatch(totalFiles);
        ExecutorService executor = Executors.newFixedThreadPool(3);

        for (int i = 0; i < totalFiles; i++) {
            executor.submit(() -> {
                System.out.println("Downloading file: " + Thread.currentThread().getName());
                latch.countDown();
            });
        }

        latch.await();
        System.out.println("All files downloaded");
        executor.shutdown();
    }
}
```

#### 输出
```
Downloading file: pool-1-thread-1
Downloading file: pool-1-thread-2
Downloading file: pool-1-thread-3
Downloading file: pool-1-thread-1
Downloading file: pool-1-thread-2
All files downloaded
```

---

## 总结

Java并发包为多线程编程提供了强大的工具，包括线程池、并发集合、同步工具、原子变量和锁。通过合理使用这些工具，可以显著提高程序的性能和可靠性。

---

## 附加资源

- [Java并发编程实战](https://book.douban.com/subject/10484692/)
- [Java官方文档 - java.util.concurrent](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/package-summary.html)

---

## 练习

1. 修改线程池示例，使用`CachedThreadPool`代替`FixedThreadPool`，并观察线程数量的变化。
2. 使用`CyclicBarrier`实现一个多线程任务协调的场景。
3. 尝试用`AtomicInteger`实现一个线程安全的计数器。

Happy coding! 🚀