---
title: Java线程同步
description: 了解Java线程同步的基本概念、实现方式及其在实际开发中的应用场景。
---

# Java线程同步

在多线程编程中，线程同步是一个非常重要的概念。当多个线程同时访问共享资源时，可能会导致数据不一致或程序行为异常。为了解决这些问题，Java提供了多种线程同步机制。本文将详细介绍Java线程同步的概念、实现方式以及实际应用场景。

## 什么是线程同步？

线程同步是指多个线程在访问共享资源时，通过某种机制确保同一时间只有一个线程可以访问该资源，从而避免数据竞争和不一致性问题。Java提供了多种线程同步机制，包括`synchronized`关键字、`ReentrantLock`、`Semaphore`等。

## `synchronized`关键字

`synchronized`是Java中最常用的线程同步机制。它可以用来修饰方法或代码块，确保同一时间只有一个线程可以执行被修饰的代码。

### 同步方法

```java
public class Counter {
    private int count = 0;

    public synchronized void increment() {
        count++;
    }

    public synchronized int getCount() {
        return count;
    }
}
```

在上面的代码中，`increment`和`getCount`方法都被`synchronized`修饰，这意味着同一时间只有一个线程可以执行这些方法。

### 同步代码块

```java
public class Counter {
    private int count = 0;
    private final Object lock = new Object();

    public void increment() {
        synchronized (lock) {
            count++;
        }
    }

    public int getCount() {
        synchronized (lock) {
            return count;
        }
    }
}
```

在这个例子中，我们使用了一个对象`lock`作为锁，确保同一时间只有一个线程可以执行同步代码块中的代码。

## `ReentrantLock`

`ReentrantLock`是Java 5引入的一个更灵活的线程同步机制。与`synchronized`相比，`ReentrantLock`提供了更多的功能，例如可中断的锁获取、超时锁获取、公平锁等。

```java
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

public class Counter {
    private int count = 0;
    private final Lock lock = new ReentrantLock();

    public void increment() {
        lock.lock();
        try {
            count++;
        } finally {
            lock.unlock();
        }
    }

    public int getCount() {
        lock.lock();
        try {
            return count;
        } finally {
            lock.unlock();
        }
    }
}
```

在这个例子中，我们使用`ReentrantLock`来确保线程安全。注意，`lock`和`unlock`操作必须在`try-finally`块中，以确保锁在发生异常时也能被正确释放。

## 实际应用场景

### 银行账户转账

假设我们有一个银行账户类`BankAccount`，多个线程可能会同时进行转账操作。为了确保转账操作的线程安全，我们可以使用`synchronized`或`ReentrantLock`。

```java
public class BankAccount {
    private double balance;
    private final Object lock = new Object();

    public BankAccount(double initialBalance) {
        this.balance = initialBalance;
    }

    public void transfer(BankAccount target, double amount) {
        synchronized (lock) {
            if (this.balance >= amount) {
                this.balance -= amount;
                target.balance += amount;
            }
        }
    }

    public double getBalance() {
        return balance;
    }
}
```

在这个例子中，`transfer`方法被`synchronized`修饰，确保同一时间只有一个线程可以执行转账操作。

## 总结

线程同步是多线程编程中的一个重要概念，它确保多个线程在访问共享资源时不会导致数据不一致或程序行为异常。Java提供了多种线程同步机制，包括`synchronized`关键字、`ReentrantLock`等。在实际开发中，选择合适的线程同步机制非常重要。

:::tip
在实际开发中，尽量避免过度使用线程同步，因为过多的同步操作可能会导致性能问题。尽量使用线程安全的集合类（如`ConcurrentHashMap`）来减少显式的同步操作。
:::

## 附加资源

- [Java并发编程实战](https://book.douban.com/subject/10484692/)
- [Java并发编程的艺术](https://book.douban.com/subject/26591326/)
- [Oracle官方文档 - 并发](https://docs.oracle.com/javase/tutorial/essential/concurrency/)

## 练习

1. 修改上面的`BankAccount`类，使用`ReentrantLock`代替`synchronized`来实现线程安全。
2. 编写一个多线程程序，模拟多个线程同时访问一个共享资源，并观察不加同步机制时的行为。
3. 使用`Semaphore`实现一个简单的资源池，确保同一时间只有固定数量的线程可以访问资源。
