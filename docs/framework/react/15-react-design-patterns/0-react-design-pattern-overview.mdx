---
title: React 设计模式概述
description: 了解React设计模式的基本概念、常见模式及其在实际开发中的应用场景，帮助初学者掌握React开发中的最佳实践。
---

# React 设计模式概述

React是一个用于构建用户界面的JavaScript库，它的组件化特性使得开发人员能够以模块化的方式构建复杂的应用程序。然而，随着应用程序规模的扩大，如何组织和管理组件之间的交互成为一个重要问题。React设计模式提供了一些最佳实践，帮助开发者编写更高效、可维护和可扩展的代码。

本文将介绍React中常见的设计模式，并通过实际案例展示它们的使用场景。

---

## 什么是React设计模式？

React设计模式是指在React开发中，经过验证的、用于解决特定问题的代码组织方式或架构模式。这些模式帮助开发者更好地管理组件的状态、逻辑和交互，从而提高代码的可读性和可维护性。

常见的React设计模式包括：
- **容器组件与展示组件模式**
- **高阶组件（HOC）模式**
- **Render Props模式**
- **复合组件模式**
- **受控组件与非受控组件模式**

接下来，我们将逐一介绍这些模式。

---

## 1. 容器组件与展示组件模式

容器组件与展示组件模式（Container-Presentational Pattern）是React中最基础的设计模式之一。它将组件的逻辑与UI分离，使得代码更易于理解和维护。

- **容器组件**：负责处理业务逻辑、数据获取和状态管理。
- **展示组件**：负责渲染UI，通常是无状态的（stateless）或纯函数组件。

### 示例代码

```jsx
// 容器组件
function UserListContainer() {
  const [users, setUsers] = React.useState([]);

  React.useEffect(() => {
    fetch('/api/users')
      .then(response => response.json())
      .then(data => setUsers(data));
  }, []);

  return <UserList users={users} />;
}

// 展示组件
function UserList({ users }) {
  return (
    <ul>
      {users.map(user => (
        <li key={user.id}>{user.name}</li>
      ))}
    </ul>
  );
}
```

### 实际应用场景
- 当需要将数据获取逻辑与UI渲染逻辑分离时。
- 当展示组件需要被复用时。

---

## 2. 高阶组件（HOC）模式

高阶组件（Higher-Order Component, HOC）是一个函数，它接收一个组件并返回一个新的组件。HOC通常用于复用组件逻辑。

### 示例代码

```jsx
function withLoading(WrappedComponent) {
  return function WithLoadingComponent({ isLoading, ...props }) {
    if (isLoading) {
      return <div>Loading...</div>;
    }
    return <WrappedComponent {...props} />;
  };
}

const UserListWithLoading = withLoading(UserList);
```

### 实际应用场景
- 当需要在多个组件中复用相同的逻辑时（例如加载状态、权限检查等）。

:::tip
HOC模式可能会导致组件层级过深，因此在使用时需谨慎。
:::

---

## 3. Render Props模式

Render Props模式是一种通过将函数作为props传递给组件来实现逻辑复用的方式。这个函数通常命名为`render`或`children`。

### 示例代码

```jsx
function DataFetcher({ url, render }) {
  const [data, setData] = React.useState(null);

  React.useEffect(() => {
    fetch(url)
      .then(response => response.json())
      .then(data => setData(data));
  }, [url]);

  return render(data);
}

function App() {
  return (
    <DataFetcher
      url="/api/users"
      render={data => (
        <ul>
          {data?.map(user => (
            <li key={user.id}>{user.name}</li>
          ))}
        </ul>
      )}
    />
  );
}
```

### 实际应用场景
- 当需要将数据获取逻辑与UI渲染逻辑分离，同时避免HOC的嵌套问题时。

---

## 4. 复合组件模式

复合组件模式（Compound Components Pattern）通过将多个组件组合在一起，形成一个功能完整的组件。这种模式通常用于构建复杂的UI组件（如表格、下拉菜单等）。

### 示例代码

```jsx
function Tabs({ children }) {
  const [activeIndex, setActiveIndex] = React.useState(0);

  return React.Children.map(children, (child, index) =>
    React.cloneElement(child, {
      isActive: index === activeIndex,
      onClick: () => setActiveIndex(index),
    })
  );
}

function Tab({ isActive, onClick, children }) {
  return (
    <button
      style={{ fontWeight: isActive ? 'bold' : 'normal' }}
      onClick={onClick}
    >
      {children}
    </button>
  );
}

function App() {
  return (
    <Tabs>
      <Tab>Tab 1</Tab>
      <Tab>Tab 2</Tab>
      <Tab>Tab 3</Tab>
    </Tabs>
  );
}
```

### 实际应用场景
- 当需要构建复杂的、可定制的UI组件时。

---

## 5. 受控组件与非受控组件模式

在React中，表单元素（如`<input>`、`<textarea>`等）可以通过两种方式管理其状态：
- **受控组件**：组件的状态由React管理。
- **非受控组件**：组件的状态由DOM管理。

### 示例代码

```jsx
// 受控组件
function ControlledInput() {
  const [value, setValue] = React.useState('');

  return (
    <input
      type="text"
      value={value}
      onChange={e => setValue(e.target.value)}
    />
  );
}

// 非受控组件
function UncontrolledInput() {
  const inputRef = React.useRef();

  const handleSubmit = () => {
    alert(inputRef.current.value);
  };

  return (
    <div>
      <input type="text" ref={inputRef} />
      <button onClick={handleSubmit}>Submit</button>
    </div>
  );
}
```

### 实际应用场景
- 受控组件适用于需要实时验证或处理的表单。
- 非受控组件适用于简单的表单或需要与第三方库集成时。

---

## 总结

React设计模式为开发者提供了一系列解决常见问题的工具和方法。通过合理使用这些模式，你可以编写出更高效、可维护和可扩展的React应用程序。

:::note
建议初学者在学习设计模式时，结合实际项目进行练习，以加深理解。
:::

---

## 附加资源与练习

- **资源**：
  - [React官方文档](https://reactjs.org/docs/getting-started.html)
  - [React Patterns](https://reactpatterns.com/)
- **练习**：
  - 尝试将容器组件与展示组件模式应用到你的项目中。
  - 使用高阶组件模式实现一个通用的加载状态组件。