---
title: TypeScript装饰器
description: 了解TypeScript装饰器的基本概念、用法以及实际应用场景，帮助初学者掌握这一强大的特性。
---

# TypeScript装饰器

TypeScript装饰器（Decorators）是一种特殊类型的声明，它可以被附加到类声明、方法、访问器、属性或参数上，以修改类的行为或元数据。装饰器在Angular、NestJS等框架中被广泛使用，是TypeScript中非常强大的特性之一。

## 什么是装饰器？

装饰器本质上是一个函数，它会在运行时被调用，并接收目标对象的相关信息作为参数。通过装饰器，我们可以在不修改原始代码的情况下，为类或方法添加额外的功能或元数据。

### 装饰器的基本语法

装饰器的语法非常简单，使用 `@` 符号后跟装饰器函数名即可。例如：

```typescript
function log(target: any, propertyKey: string, descriptor: PropertyDescriptor) {
    console.log(`Method ${propertyKey} is called`);
}

class MyClass {
    @log
    myMethod() {
        console.log('Hello, World!');
    }
}

const instance = new MyClass();
instance.myMethod();
```

在这个例子中，`@log` 装饰器会在 `myMethod` 方法被调用时，打印出方法的名称。

## 装饰器的类型

TypeScript支持以下几种类型的装饰器：

1. **类装饰器**：应用于类构造函数，用于观察、修改或替换类定义。
2. **方法装饰器**：应用于类的方法，用于观察、修改或替换方法定义。
3. **访问器装饰器**：应用于类的访问器（getter/setter），用于观察、修改或替换访问器定义。
4. **属性装饰器**：应用于类的属性，用于观察、修改或替换属性定义。
5. **参数装饰器**：应用于类方法的参数，用于观察、修改或替换参数定义。

### 类装饰器

类装饰器是最常见的装饰器类型之一。它接收类的构造函数作为参数，并可以返回一个新的构造函数来替换原来的类。

```typescript
function sealed(constructor: Function) {
    Object.seal(constructor);
    Object.seal(constructor.prototype);
}

@sealed
class MyClass {
    myMethod() {
        console.log('Hello, World!');
    }
}
```

在这个例子中，`@sealed` 装饰器会阻止类及其原型被修改。

### 方法装饰器

方法装饰器可以用于修改或替换类的方法。它接收三个参数：类的原型、方法名和方法的属性描述符。

```typescript
function log(target: any, propertyKey: string, descriptor: PropertyDescriptor) {
    const originalMethod = descriptor.value;
    descriptor.value = function (...args: any[]) {
        console.log(`Calling ${propertyKey} with arguments: ${JSON.stringify(args)}`);
        const result = originalMethod.apply(this, args);
        console.log(`Method ${propertyKey} returned: ${result}`);
        return result;
    };
}

class MyClass {
    @log
    myMethod(a: number, b: number) {
        return a + b;
    }
}

const instance = new MyClass();
instance.myMethod(1, 2);
```

在这个例子中，`@log` 装饰器会在 `myMethod` 方法被调用时，打印出方法的参数和返回值。

### 属性装饰器

属性装饰器可以用于观察或修改类的属性。它接收两个参数：类的原型和属性名。

```typescript
function format(target: any, propertyKey: string) {
    let value: string;
    const getter = function () {
        return value;
    };
    const setter = function (newVal: string) {
        value = newVal.toUpperCase();
    };
    Object.defineProperty(target, propertyKey, {
        get: getter,
        set: setter,
    });
}

class MyClass {
    @format
    name: string;
}

const instance = new MyClass();
instance.name = 'John Doe';
console.log(instance.name); // 输出: JOHN DOE
```

在这个例子中，`@format` 装饰器会将 `name` 属性的值转换为大写。

### 参数装饰器

参数装饰器可以用于观察或修改类方法的参数。它接收三个参数：类的原型、方法名和参数在参数列表中的索引。

```typescript
function validate(target: any, propertyKey: string, parameterIndex: number) {
    const originalMethod = target[propertyKey];
    target[propertyKey] = function (...args: any[]) {
        if (args[parameterIndex] === undefined) {
            throw new Error(`Parameter at index ${parameterIndex} is required`);
        }
        return originalMethod.apply(this, args);
    };
}

class MyClass {
    myMethod(@validate name: string) {
        console.log(`Hello, ${name}`);
    }
}

const instance = new MyClass();
instance.myMethod('John'); // 输出: Hello, John
instance.myMethod(); // 抛出错误: Parameter at index 0 is required
```

在这个例子中，`@validate` 装饰器会检查 `name` 参数是否存在，如果不存在则抛出错误。

## 实际应用场景

装饰器在实际开发中有很多应用场景，以下是一些常见的例子：

1. **日志记录**：通过方法装饰器记录方法的调用和返回值。
2. **验证**：通过参数装饰器验证方法参数的有效性。
3. **缓存**：通过方法装饰器缓存方法的返回值，避免重复计算。
4. **权限控制**：通过类装饰器或方法装饰器控制访问权限。

### 示例：缓存装饰器

```typescript
function cache(target: any, propertyKey: string, descriptor: PropertyDescriptor) {
    const originalMethod = descriptor.value;
    const cacheMap = new Map();
    descriptor.value = function (...args: any[]) {
        const key = JSON.stringify(args);
        if (cacheMap.has(key)) {
            return cacheMap.get(key);
        }
        const result = originalMethod.apply(this, args);
        cacheMap.set(key, result);
        return result;
    };
}

class MyClass {
    @cache
    expensiveCalculation(a: number, b: number) {
        console.log('Calculating...');
        return a + b;
    }
}

const instance = new MyClass();
console.log(instance.expensiveCalculation(1, 2)); // 输出: Calculating... 3
console.log(instance.expensiveCalculation(1, 2)); // 输出: 3 (从缓存中获取)
```

在这个例子中，`@cache` 装饰器会缓存 `expensiveCalculation` 方法的返回值，避免重复计算。

## 总结

TypeScript装饰器是一种强大的工具，它可以帮助我们在不修改原始代码的情况下，为类或方法添加额外的功能或元数据。通过装饰器，我们可以实现日志记录、验证、缓存、权限控制等功能，极大地提高了代码的可维护性和可扩展性。

### 附加资源

- [TypeScript官方文档 - 装饰器](https://www.typescriptlang.org/docs/handbook/decorators.html)
- [深入理解TypeScript装饰器](https://www.digitalocean.com/community/tutorials/typescript-decorators)

### 练习

1. 创建一个类装饰器，用于记录类的实例化次数。
2. 创建一个方法装饰器，用于限制方法的调用频率（例如每秒最多调用一次）。
3. 创建一个属性装饰器，用于将属性值转换为小写。

通过练习，你将更深入地理解TypeScript装饰器的用法和应用场景。