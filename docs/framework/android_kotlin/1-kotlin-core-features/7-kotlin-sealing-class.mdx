---
title: Kotlin密封类
description: 了解Kotlin中的密封类（Sealed Class），掌握其核心特性、使用场景以及如何通过密封类实现更安全的类型控制。
---

# Kotlin密封类

Kotlin中的密封类（Sealed Class）是一种特殊的类，它允许你定义一个受限的类层次结构。密封类的子类必须在同一个文件中声明，这使得编译器能够完全了解所有可能的子类类型。这种特性使得密封类在处理有限集合的类型时非常有用，尤其是在需要确保类型安全的情况下。

## 什么是密封类？

密封类是一种抽象类，它的子类数量是有限的，并且这些子类必须在密封类所在的文件中定义。密封类的主要目的是限制类的继承层次结构，从而在编译时提供更强的类型检查。

密封类的定义方式如下：

```kotlin
sealed class Result
```

在这个例子中，`Result` 是一个密封类，它的子类必须在同一个文件中定义。

## 密封类的特性

1. **受限的继承**：密封类的子类必须在同一个文件中声明，这限制了类的继承层次结构。
2. **类型安全**：由于所有子类都是已知的，编译器可以在 `when` 表达式中检查是否所有可能的子类都被处理，从而避免遗漏。
3. **不可实例化**：密封类本身是抽象的，不能直接实例化。

## 密封类的使用场景

密封类通常用于表示一组有限的、已知的类型。例如，在处理网络请求的结果时，可以使用密封类来表示成功或失败的结果。

```kotlin
sealed class Result
data class Success(val data: String) : Result()
data class Error(val message: String) : Result()
```

在这个例子中，`Result` 是一个密封类，它有两个子类：`Success` 和 `Error`。`Success` 表示成功的请求，包含返回的数据；`Error` 表示失败的请求，包含错误信息。

## 密封类与 `when` 表达式

密封类与 `when` 表达式结合使用时，可以确保所有可能的子类都被处理，从而避免遗漏。

```kotlin
fun handleResult(result: Result) {
    when (result) {
        is Success -> println("Success: ${result.data}")
        is Error -> println("Error: ${result.message}")
    }
}
```

在这个例子中，`when` 表达式处理了 `Result` 的所有子类。由于 `Result` 是密封类，编译器可以确保所有可能的子类都被处理，从而避免遗漏。

## 实际案例

假设你正在开发一个应用程序，需要处理用户登录的结果。你可以使用密封类来表示登录结果。

```kotlin
sealed class LoginResult
data class Success(val user: User) : LoginResult()
data class Error(val message: String) : LoginResult()
object Loading : LoginResult()
```

在这个例子中，`LoginResult` 是一个密封类，它有三个子类：`Success`、`Error` 和 `Loading`。`Success` 表示登录成功，包含用户信息；`Error` 表示登录失败，包含错误信息；`Loading` 表示登录正在进行中。

```kotlin
fun handleLoginResult(result: LoginResult) {
    when (result) {
        is Success -> println("Login successful: ${result.user.name}")
        is Error -> println("Login failed: ${result.message}")
        Loading -> println("Loading...")
    }
}
```

在这个例子中，`when` 表达式处理了 `LoginResult` 的所有子类，确保所有可能的登录结果都被处理。

## 总结

Kotlin的密封类是一种强大的工具，它允许你定义一个受限的类层次结构，从而在编译时提供更强的类型检查。密封类通常用于表示一组有限的、已知的类型，尤其是在需要确保类型安全的情况下。通过结合 `when` 表达式，密封类可以确保所有可能的子类都被处理，从而避免遗漏。

## 附加资源

- [Kotlin官方文档 - 密封类](https://kotlinlang.org/docs/sealed-classes.html)
- [Kotlin密封类与枚举类的区别](https://kotlinlang.org/docs/sealed-classes.html#sealed-classes-vs-enum-classes)

## 练习

1. 定义一个密封类 `NetworkResult`，包含 `Success`、`Error` 和 `Loading` 三个子类。
2. 编写一个函数 `handleNetworkResult`，使用 `when` 表达式处理 `NetworkResult` 的所有子类。
3. 尝试在 `handleNetworkResult` 函数中遗漏一个子类，观察编译器的提示。