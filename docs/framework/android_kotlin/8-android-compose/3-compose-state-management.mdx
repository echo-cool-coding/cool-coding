---
title: Compose状态管理
description: 了解如何在Jetpack Compose中管理状态，掌握状态提升、状态托管等核心概念，并通过实际案例加深理解。
---

# Compose状态管理

在Jetpack Compose中，状态管理是构建动态UI的核心。Compose是一个声明式UI框架，这意味着UI的更新是基于状态的变化。理解如何有效地管理状态，是构建高效、可维护的Compose应用的关键。

## 什么是状态？

在Compose中，**状态**是指可以随时间变化的数据。当状态发生变化时，Compose会自动重新绘制（recompose）依赖于该状态的UI组件。例如，一个按钮的文本、颜色或可见性都可以是状态。

### 状态的基本使用

在Compose中，最简单的状态管理方式是使用 `mutableStateOf`。以下是一个简单的例子：

```kotlin
@Composable
fun Counter() {
    val count = remember { mutableStateOf(0) }

    Button(onClick = { count.value++ }) {
        Text("Clicked ${count.value} times")
    }
}
```

在这个例子中，`count` 是一个状态变量，每次点击按钮时，`count` 的值会增加，UI会自动更新以显示新的点击次数。

:::note
`remember` 是Compose中的一个关键函数，它确保状态在重组（recompose）时不会被重置。
:::

## 状态提升（State Hoisting）

状态提升是一种将状态从子组件移动到父组件的模式。这样做的好处是使子组件更加可重用，并且更容易测试。

### 状态提升示例

假设我们有一个 `Counter` 组件，我们希望将状态提升到父组件中：

```kotlin
@Composable
fun Counter(count: Int, onIncrement: () -> Unit) {
    Button(onClick = onIncrement) {
        Text("Clicked $count times")
    }
}

@Composable
fun CounterParent() {
    val count = remember { mutableStateOf(0) }

    Counter(count = count.value, onIncrement = { count.value++ })
}
```

在这个例子中，`Counter` 组件不再直接管理状态，而是通过参数接收状态和回调函数。这使得 `Counter` 组件更加灵活，可以在不同的上下文中使用。

:::tip
状态提升是Compose中推荐的做法，尤其是在构建复杂的UI时。
:::

## 状态托管（State Hosting）

状态托管是指将状态集中管理，通常通过ViewModel或其他状态管理工具来实现。这种方式适用于需要跨多个组件共享状态的场景。

### 使用ViewModel托管状态

以下是一个使用ViewModel托管状态的例子：

```kotlin
class CounterViewModel : ViewModel() {
    private val _count = mutableStateOf(0)
    val count: State<Int> get() = _count

    fun increment() {
        _count.value++
    }
}

@Composable
fun CounterScreen(viewModel: CounterViewModel = viewModel()) {
    val count by viewModel.count

    Button(onClick = { viewModel.increment() }) {
        Text("Clicked $count times")
    }
}
```

在这个例子中，`CounterViewModel` 负责管理状态，`CounterScreen` 组件通过 `viewModel` 获取状态并更新UI。

:::caution
在使用ViewModel时，确保不要将UI逻辑与业务逻辑混在一起，保持组件的单一职责。
:::

## 实际案例：Todo列表

让我们通过一个实际的案例来展示状态管理的应用。我们将构建一个简单的Todo列表应用。

### Todo列表实现

```kotlin
data class TodoItem(val id: Int, val task: String, val isDone: Boolean)

@Composable
fun TodoList() {
    val todos = remember {
        mutableStateListOf(
            TodoItem(1, "Learn Compose", false),
            TodoItem(2, "Build a project", false)
        )
    }

    Column {
        todos.forEach { todo ->
            Row {
                Checkbox(
                    checked = todo.isDone,
                    onCheckedChange = { isChecked ->
                        todos[todos.indexOf(todo)] = todo.copy(isDone = isChecked)
                    }
                )
                Text(todo.task)
            }
        }
    }
}
```

在这个例子中，`todos` 是一个状态列表，表示所有的Todo项。当用户勾选复选框时，`todos` 列表会更新，UI会自动重新绘制。

:::warning
在处理列表状态时，确保使用 `mutableStateListOf` 或其他可观察的集合类型，以便Compose能够正确跟踪状态变化。
:::

## 总结

在Jetpack Compose中，状态管理是构建动态UI的核心。通过使用 `mutableStateOf`、状态提升和状态托管，你可以有效地管理应用的状态，并构建出高效、可维护的UI组件。

### 附加资源

- [Jetpack Compose官方文档](https://developer.android.com/jetpack/compose)
- [Compose状态管理指南](https://developer.android.com/jetpack/compose/state)
- [Compose状态提升示例](https://developer.android.com/jetpack/compose/state-hoisting)

### 练习

1. 修改 `Counter` 组件，使其支持减少计数的功能。
2. 扩展 `TodoList` 组件，添加一个输入框和按钮，允许用户添加新的Todo项。
3. 尝试将 `TodoList` 的状态提升到父组件中，并观察其变化。

通过实践这些练习，你将更深入地理解Compose中的状态管理。