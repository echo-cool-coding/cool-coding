---
title: Django 视图装饰器
description: 了解如何使用Django视图装饰器来增强视图功能，简化代码并提高可维护性。
---

# Django 视图装饰器

在Django中，视图（View）是处理请求并返回响应的核心组件。为了增强视图的功能或简化代码，Django提供了**视图装饰器**。装饰器是一种Python语法糖，允许我们在不修改函数本身的情况下，动态地扩展函数的行为。

本文将详细介绍Django中常用的视图装饰器，并通过实际案例展示它们的应用场景。

## 什么是视图装饰器？

视图装饰器是用于修改视图行为的函数。它们通常用于以下场景：

- 权限验证
- 缓存控制
- 请求方法限制
- 日志记录
- 异常处理

Django内置了许多实用的装饰器，同时你也可以自定义装饰器以满足特定需求。

## 常用Django视图装饰器

### 1. `@login_required`

`@login_required` 装饰器用于限制只有登录用户才能访问某个视图。如果未登录用户尝试访问，Django会将其重定向到登录页面。

```python
from django.contrib.auth.decorators import login_required
from django.http import HttpResponse

@login_required
def my_view(request):
    return HttpResponse("只有登录用户才能看到这个页面！")
```

**输入**：未登录用户访问 `/my-view/`  
**输出**：重定向到登录页面，登录后返回原页面。

:::tip
你可以通过设置 `LOGIN_URL` 来指定登录页面的URL。
:::

### 2. `@permission_required`

`@permission_required` 装饰器用于检查用户是否具有特定权限。如果用户没有权限，Django会返回403 Forbidden错误。

```python
from django.contrib.auth.decorators import permission_required
from django.http import HttpResponse

@permission_required('polls.can_vote')
def my_view(request):
    return HttpResponse("只有具有 'polls.can_vote' 权限的用户才能看到这个页面！")
```

**输入**：用户访问 `/my-view/`  
**输出**：如果用户没有 `polls.can_vote` 权限，返回403 Forbidden。

### 3. `@require_http_methods`

`@require_http_methods` 装饰器用于限制视图只能处理特定的HTTP方法（如GET、POST等）。

```python
from django.views.decorators.http import require_http_methods
from django.http import HttpResponse

@require_http_methods(["GET", "POST"])
def my_view(request):
    if request.method == "GET":
        return HttpResponse("这是一个GET请求！")
    elif request.method == "POST":
        return HttpResponse("这是一个POST请求！")
```

**输入**：用户通过PUT方法访问 `/my-view/`  
**输出**：返回405 Method Not Allowed。

### 4. `@cache_page`

`@cache_page` 装饰器用于缓存视图的响应结果，以减少服务器负载并提高性能。

```python
from django.views.decorators.cache import cache_page
from django.http import HttpResponse

@cache_page(60 * 15)  # 缓存15分钟
def my_view(request):
    return HttpResponse("这个页面的响应将被缓存15分钟！")
```

**输入**：用户访问 `/my-view/`  
**输出**：第一次访问时生成响应并缓存，后续访问直接从缓存中返回结果。

:::caution
缓存适用于不经常变化的内容，对于动态内容需谨慎使用。
:::

## 自定义视图装饰器

除了使用Django内置的装饰器，你还可以自定义装饰器以满足特定需求。以下是一个简单的自定义装饰器示例：

```python
def my_decorator(view_func):
    def wrapper(request, *args, **kwargs):
        # 在调用视图之前执行的操作
        print("视图被调用之前")
        response = view_func(request, *args, **kwargs)
        # 在调用视图之后执行的操作
        print("视图被调用之后")
        return response
    return wrapper

@my_decorator
def my_view(request):
    return HttpResponse("这是一个自定义装饰器的示例！")
```

**输入**：用户访问 `/my-view/`  
**输出**：在调用视图前后分别打印日志。

## 实际应用场景

### 场景1：用户权限验证

假设你正在开发一个博客系统，只有管理员才能发布文章。你可以使用 `@permission_required` 装饰器来限制访问：

```python
@permission_required('blog.add_post')
def create_post(request):
    # 处理创建文章的代码
    return HttpResponse("文章创建成功！")
```

### 场景2：缓存热门页面

如果你的网站有一个热门页面，访问量很大，你可以使用 `@cache_page` 装饰器来缓存页面：

```python
@cache_page(60 * 60)  # 缓存1小时
def popular_page(request):
    # 处理热门页面的代码
    return HttpResponse("这是热门页面！")
```

## 总结

Django视图装饰器是增强视图功能的强大工具。通过使用内置装饰器或自定义装饰器，你可以轻松实现权限验证、缓存控制、请求方法限制等功能。掌握装饰器的使用将帮助你编写更简洁、可维护的代码。

## 附加资源与练习

- **练习1**：尝试为你的视图添加 `@login_required` 装饰器，并测试未登录用户的行为。
- **练习2**：自定义一个装饰器，记录每个视图的调用时间。
- **阅读**：[Django官方文档 - 视图装饰器](https://docs.djangoproject.com/en/stable/topics/http/decorators/)

通过实践和阅读文档，你将更深入地理解Django视图装饰器的强大功能！