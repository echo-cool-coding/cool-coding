---
title: Django 与Vue.js集成
description: 学习如何将Django后端与Vue.js前端框架集成，构建现代化的全栈Web应用。
---

## 介绍

在现代Web开发中，前后端分离的架构越来越流行。Django作为一个强大的后端框架，提供了丰富的功能来构建API和数据处理逻辑，而Vue.js则是一个灵活的前端框架，专注于构建用户界面。将两者结合，可以创建出功能强大且用户体验良好的Web应用。

本文将逐步讲解如何将Django与Vue.js集成，并通过实际案例展示其应用场景。

## 1. 设置Django项目

首先，我们需要创建一个Django项目。如果你还没有安装Django，可以通过以下命令安装：

```bash
pip install django
```

然后，创建一个新的Django项目：

```bash
django-admin startproject myproject
```

进入项目目录：

```bash
cd myproject
```

## 2. 创建Django API

为了与Vue.js前端进行通信，我们需要在Django中创建一个API。我们可以使用Django REST framework（DRF）来简化API的创建。

首先，安装DRF：

```bash
pip install djangorestframework
```

然后，在`settings.py`中添加`rest_framework`到`INSTALLED_APPS`：

```python
INSTALLED_APPS = [
    ...
    'rest_framework',
]
```

接下来，创建一个简单的API。假设我们要创建一个用于管理任务的API。首先，创建一个新的Django应用：

```bash
python manage.py startapp tasks
```

在`tasks/models.py`中定义一个`Task`模型：

```python
from django.db import models

class Task(models.Model):
    title = models.CharField(max_length=200)
    completed = models.BooleanField(default=False)

    def __str__(self):
        return self.title
```

然后，在`tasks/serializers.py`中创建一个序列化器：

```python
from rest_framework import serializers
from .models import Task

class TaskSerializer(serializers.ModelSerializer):
    class Meta:
        model = Task
        fields = '__all__'
```

接下来，在`tasks/views.py`中创建一个视图：

```python
from rest_framework import viewsets
from .models import Task
from .serializers import TaskSerializer

class TaskViewSet(viewsets.ModelViewSet):
    queryset = Task.objects.all()
    serializer_class = TaskSerializer
```

最后，在`myproject/urls.py`中配置路由：

```python
from django.contrib import admin
from django.urls import path, include
from rest_framework.routers import DefaultRouter
from tasks.views import TaskViewSet

router = DefaultRouter()
router.register(r'tasks', TaskViewSet)

urlpatterns = [
    path('admin/', admin.site.urls),
    path('api/', include(router.urls)),
]
```

现在，你可以运行Django开发服务器并访问`http://127.0.0.1:8000/api/tasks/`来查看API。

## 3. 设置Vue.js项目

接下来，我们需要创建一个Vue.js项目。如果你还没有安装Vue CLI，可以通过以下命令安装：

```bash
npm install -g @vue/cli
```

然后，创建一个新的Vue.js项目：

```bash
vue create my-vue-app
```

进入项目目录：

```bash
cd my-vue-app
```

## 4. 集成Vue.js与Django API

在Vue.js项目中，我们可以使用`axios`来与Django API进行通信。首先，安装`axios`：

```bash
npm install axios
```

然后，在`src/main.js`中配置`axios`：

```javascript
import Vue from 'vue'
import App from './App.vue'
import axios from 'axios'

Vue.config.productionTip = false

axios.defaults.baseURL = 'http://127.0.0.1:8000/api/'

new Vue({
  render: h => h(App),
}).$mount('#app')
```

接下来，在`src/components/TaskList.vue`中创建一个组件来显示任务列表：

```vue
<template>
  <div>
    <h1>Tasks</h1>
    <ul>
      <li v-for="task in tasks" :key="task.id">
        {{ task.title }} - {{ task.completed ? 'Completed' : 'Not Completed' }}
      </li>
    </ul>
  </div>
</template>

<script>
import axios from 'axios'

export default {
  data() {
    return {
      tasks: []
    }
  },
  created() {
    this.fetchTasks()
  },
  methods: {
    fetchTasks() {
      axios.get('tasks/')
        .then(response => {
          this.tasks = response.data
        })
        .catch(error => {
          console.error('There was an error fetching the tasks!', error)
        })
    }
  }
}
</script>
```

最后，在`src/App.vue`中使用`TaskList`组件：

```vue
<template>
  <div id="app">
    <TaskList />
  </div>
</template>

<script>
import TaskList from './components/TaskList.vue'

export default {
  components: {
    TaskList
  }
}
</script>
```

现在，你可以运行Vue.js开发服务器并访问`http://localhost:8080`来查看任务列表。

## 5. 实际案例

假设我们正在开发一个任务管理应用。用户可以通过前端界面添加、编辑和删除任务，而Django后端负责存储和处理这些任务。通过将Django与Vue.js集成，我们可以实现一个功能完善的任务管理应用。

## 6. 总结

通过本文，我们学习了如何将Django与Vue.js集成，构建一个现代化的全栈Web应用。我们创建了一个Django API，并使用Vue.js前端框架来与API进行通信。这种前后端分离的架构不仅提高了开发效率，还增强了应用的可维护性和扩展性。

## 7. 附加资源与练习

- **练习**：尝试在Vue.js中添加一个表单，允许用户创建新任务并将其保存到Django后端。
- **资源**：
  - [Django官方文档](https://docs.djangoproject.com/)
  - [Vue.js官方文档](https://vuejs.org/v2/guide/)
  - [Django REST framework文档](https://www.django-rest-framework.org/)

通过不断练习和探索，你将能够熟练掌握Django与Vue.js的集成，并构建出更加复杂的Web应用。