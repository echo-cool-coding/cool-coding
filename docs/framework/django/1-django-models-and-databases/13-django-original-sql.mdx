---
title: Django 原始SQL
description: 了解如何在Django中使用原始SQL查询与数据库交互，掌握直接执行SQL语句的方法及其适用场景。
---

# Django 原始SQL

在Django中，ORM（对象关系映射）是处理数据库的主要方式。它允许开发者使用Python代码来操作数据库，而无需直接编写SQL语句。然而，在某些情况下，ORM可能无法满足复杂查询的需求，或者你可能需要直接执行SQL语句以获得更高的性能或灵活性。这时，Django提供了**原始SQL**的支持。

## 什么是Django原始SQL？

Django原始SQL允许你直接编写和执行SQL查询，而不是通过ORM生成查询。这种方式适用于以下场景：
- 需要执行复杂的SQL查询，ORM无法轻松实现。
- 需要优化查询性能，直接使用SQL可能更高效。
- 需要使用数据库特定的功能或语法。

:::note
虽然原始SQL提供了更大的灵活性，但它也增加了代码的复杂性和维护难度。因此，建议在必要时才使用原始SQL。
:::

## 如何使用原始SQL

Django提供了两种主要方式来执行原始SQL查询：
1. 使用 `Manager.raw()` 方法。
2. 使用 `django.db.connection` 直接执行SQL。

### 1. 使用 `Manager.raw()`

`Manager.raw()` 方法允许你执行原始SQL查询，并将结果映射到Django模型实例。以下是一个简单的示例：

```python
from myapp.models import Person

# 执行原始SQL查询
people = Person.objects.raw('SELECT * FROM myapp_person WHERE age > %s', [18])

# 遍历查询结果
for person in people:
    print(person.name)
```

在这个例子中，`Person.objects.raw()` 执行了一个SQL查询，返回所有年龄大于18的 `Person` 对象。`%s` 是参数占位符，`[18]` 是传递给查询的参数列表。

:::tip
使用 `raw()` 方法时，SQL查询的字段必须与模型字段匹配，否则会引发异常。
:::

### 2. 使用 `django.db.connection`

如果你需要执行更复杂的SQL查询，或者不需要将结果映射到模型实例，可以使用 `django.db.connection`。以下是一个示例：

```python
from django.db import connection

# 创建游标对象
with connection.cursor() as cursor:
    # 执行SQL查询
    cursor.execute("SELECT * FROM myapp_person WHERE age > %s", [18])
    
    # 获取查询结果
    rows = cursor.fetchall()
    
    # 处理结果
    for row in rows:
        print(row)
```

在这个例子中，`cursor.execute()` 执行了一个SQL查询，`cursor.fetchall()` 获取了所有结果行。你可以根据需要处理这些行。

:::caution
使用 `connection.cursor()` 时，你需要手动处理数据库连接和游标的生命周期。建议使用 `with` 语句来确保资源被正确释放。
:::

## 实际应用场景

### 场景1：复杂查询

假设你需要查询一个包含多个表的复杂查询，ORM无法轻松实现。例如，查询所有购买了特定产品的用户：

```sql
SELECT u.name, p.product_name
FROM auth_user u
JOIN orders o ON u.id = o.user_id
JOIN products p ON o.product_id = p.id
WHERE p.product_name = 'Laptop';
```

在Django中，你可以使用原始SQL来执行这个查询：

```python
from django.db import connection

with connection.cursor() as cursor:
    cursor.execute("""
        SELECT u.name, p.product_name
        FROM auth_user u
        JOIN orders o ON u.id = o.user_id
        JOIN products p ON o.product_id = p.id
        WHERE p.product_name = %s
    """, ['Laptop'])
    
    rows = cursor.fetchall()
    for row in rows:
        print(row)
```

### 场景2：数据库特定功能

某些数据库提供了特定的功能或语法，ORM可能不支持。例如，PostgreSQL的 `JSONB` 类型支持复杂的JSON查询。你可以使用原始SQL来利用这些功能：

```python
from django.db import connection

with connection.cursor() as cursor:
    cursor.execute("""
        SELECT data->>'name' AS name
        FROM myapp_mymodel
        WHERE data @> '{"status": "active"}'
    """)
    
    rows = cursor.fetchall()
    for row in rows:
        print(row)
```

## 总结

Django原始SQL提供了直接执行SQL查询的能力，适用于复杂查询、性能优化和数据库特定功能的场景。虽然它提供了更大的灵活性，但也增加了代码的复杂性和维护难度。因此，建议在必要时才使用原始SQL。

:::tip
在使用原始SQL时，务必注意SQL注入的风险。始终使用参数化查询来避免安全问题。
:::

## 附加资源与练习

- **官方文档**: [Django原始SQL文档](https://docs.djangoproject.com/en/stable/topics/db/sql/)
- **练习**: 尝试在你的Django项目中使用原始SQL查询，执行一个复杂的多表查询，并将结果映射到模型实例。

通过掌握Django原始SQL，你将能够更灵活地与数据库交互，处理更复杂的查询需求。