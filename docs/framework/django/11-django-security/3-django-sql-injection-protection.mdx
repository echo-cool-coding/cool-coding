---
title: Django SQL注入防护
description: 了解如何在Django中防止SQL注入攻击，保护你的Web应用程序免受恶意数据输入的威胁。
---

# Django SQL注入防护

SQL注入是一种常见的Web应用程序安全漏洞，攻击者可以通过恶意构造的输入数据操纵数据库查询，从而获取、修改或删除敏感数据。Django作为一个强大的Web框架，提供了多种机制来防止SQL注入攻击。本文将详细介绍这些机制，并通过实际案例帮助你理解如何保护你的Django应用程序。

## 什么是SQL注入？

SQL注入是一种攻击技术，攻击者通过在输入字段中插入恶意SQL代码，试图操纵后端数据库查询。例如，如果一个登录表单没有正确处理用户输入，攻击者可以通过输入类似 `' OR '1'='1` 的字符串绕过身份验证。

### 示例：SQL注入攻击

假设我们有以下Django视图函数：

```python
from django.db import connection

def get_user_data(username):
    with connection.cursor() as cursor:
        cursor.execute(f"SELECT * FROM users WHERE username = '{username}'")
        return cursor.fetchall()
```

如果用户输入 `admin' --`，生成的SQL查询将变为：

```sql
SELECT * FROM users WHERE username = 'admin' --'
```

这将导致查询忽略掉后面的条件，从而返回所有用户数据。

## Django 如何防止SQL注入？

Django通过使用ORM（对象关系映射）和参数化查询来防止SQL注入。ORM将Python代码转换为安全的SQL查询，而参数化查询确保用户输入不会被解释为SQL代码。

### 使用Django ORM

Django ORM会自动转义用户输入，防止SQL注入。例如：

```python
from myapp.models import User

def get_user_data(username):
    return User.objects.filter(username=username).all()
```

在这个例子中，Django会自动处理 `username` 参数，确保它不会被解释为SQL代码。

### 使用参数化查询

如果你需要直接执行SQL查询，Django提供了参数化查询的功能：

```python
from django.db import connection

def get_user_data(username):
    with connection.cursor() as cursor:
        cursor.execute("SELECT * FROM users WHERE username = %s", [username])
        return cursor.fetchall()
```

在这个例子中，`%s` 是一个占位符，Django会自动将 `username` 参数安全地插入到查询中。

## 实际案例

假设我们有一个博客应用程序，用户可以搜索博客文章。以下是一个不安全的实现：

```python
def search_posts(keyword):
    with connection.cursor() as cursor:
        cursor.execute(f"SELECT * FROM posts WHERE title LIKE '%{keyword}%'")
        return cursor.fetchall()
```

如果用户输入 `'; DROP TABLE posts; --`，生成的SQL查询将变为：

```sql
SELECT * FROM posts WHERE title LIKE '%'; DROP TABLE posts; --%'
```

这将导致 `posts` 表被删除。为了防止这种情况，我们应该使用参数化查询：

```python
def search_posts(keyword):
    with connection.cursor() as cursor:
        cursor.execute("SELECT * FROM posts WHERE title LIKE %s", [f'%{keyword}%'])
        return cursor.fetchall()
```

## 总结

SQL注入是一种严重的安全威胁，但通过使用Django ORM和参数化查询，我们可以有效地防止这种攻击。始终避免直接拼接用户输入到SQL查询中，并确保使用Django提供的安全机制来处理数据库操作。

## 附加资源

- [Django官方文档：数据库访问优化](https://docs.djangoproject.com/en/stable/topics/db/optimization/)
- [OWASP SQL注入防护指南](https://owasp.org/www-community/attacks/SQL_Injection)
- [Django安全最佳实践](https://docs.djangoproject.com/en/stable/topics/security/)

## 练习

1. 修改以下不安全的Django视图函数，使其免受SQL注入攻击：

```python
def get_user_profile(user_id):
    with connection.cursor() as cursor:
        cursor.execute(f"SELECT * FROM profiles WHERE user_id = {user_id}")
        return cursor.fetchone()
```

2. 创建一个Django模型，并使用ORM编写一个安全的查询，获取所有用户名以特定字符串开头的用户。

```python
from django.db import models

class User(models.Model):
    username = models.CharField(max_length=100)
    email = models.EmailField()

# 你的代码
```

通过完成这些练习，你将更好地理解如何在Django中防止SQL注入攻击。